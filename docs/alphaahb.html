<HTML>
 <HEAD>
 <TITLE>The Alpha Architecture Handbook</TITLE></HEAD>
<BODY>
<A href="#DocumentBody">Document Body</A>
<A href="#PageLinks">Page Navigation Panel</A>
<A href="#OutlineTree">Document Outline</A>
<H1> <A name=OutlineTree>Document Outline</H1>
 <UL>
 <UL>
<LI> <A HREF="#page3"> Table of Contents </A>
 <UL>
<LI> <A HREF="#page3"> 1 Introduction </A>
<LI> <A HREF="#page3"> 2 Basic Architecture </A>
<LI> <A HREF="#page4"> 3 Instruction Formats </A>
<LI> <A HREF="#page4"> 4 Instruction Descriptions </A>
<LI> <A HREF="#page7"> 5 System Architecture and Programming Implications </A>
<LI> <A HREF="#page7"> 6 Common PALcode Architecture </A>
<LI> <A HREF="#page8"> 7 Console Subsystem Overview </A>
<LI> <A HREF="#page8"> 8 Input/Output Overview </A>
<LI> <A HREF="#page8"> 9 OpenVMS Alpha </A>
<LI> <A HREF="#page8"> 10 Digital UNIX </A>
<LI> <A HREF="#page8"> 11 Windows NT Alpha </A>
<LI> <A HREF="#page8"> A Software Considerations </A>
<LI> <A HREF="#page9"> B IEEE Floating-Point Conformance </A>
<LI> <A HREF="#page9"> C Instruction Summary </A>
<LI> <A HREF="#page9"> D Registered System and Processor Identifiers </A>
<LI> <A HREF="#page9"> E Waivers and Implementation-Dependent Functionality </A>
</UL>
<LI> <A HREF="#page11"> Figures </A>
<LI> <A HREF="#page12"> Tables </A>
<LI> <A HREF="#page15"> Preface </A>
<LI> <A HREF="#page17"> Introduction </A>
 <UL>
<LI> <A HREF="#page17"> 1.1 The Alpha Approach to RISC Architecture </A>
<LI> <A HREF="#page19"> 1.2 Data Format Overview </A>
<LI> <A HREF="#page20"> 1.3 Instruction Format Overview </A>
<LI> <A HREF="#page20"> 1.4 Instruction Overview </A>
<LI> <A HREF="#page22"> 1.5 Instruction Set Characteristics </A>
<LI> <A HREF="#page22"> 1.6 Terminology and Conventions </A>
 <UL>
<LI> <A HREF="#page23"> 1.6.1 Numbering </A>
<LI> <A HREF="#page23"> 1.6.2 Security Holes </A>
<LI> <A HREF="#page23"> 1.6.3 UNPREDICTABLE and UNDEFINED </A>
<LI> <A HREF="#page24"> 1.6.4 Ranges and Extents </A>
<LI> <A HREF="#page24"> 1.6.5 ALIGNED and UNALIGNED </A>
<LI> <A HREF="#page25"> 1.6.6 Must Be Zero (MBZ) </A>
<LI> <A HREF="#page25"> 1.6.7 Read As Zero (RAZ) </A>
<LI> <A HREF="#page25"> 1.6.8 Should Be Zero (SBZ) </A>
<LI> <A HREF="#page25"> 1.6.9 Ignore (IGN) </A>
<LI> <A HREF="#page25"> 1.6.10 Implementation Dependent (IMP) </A>
<LI> <A HREF="#page25"> 1.6.11 Illustration Conventions </A>
<LI> <A HREF="#page25"> 1.6.12 Macro Code Example Conventions </A>
</UL>
</UL>
<LI> <A HREF="#page27"> Basic Architecture </A>
 <UL>
<LI> <A HREF="#page27"> 2.1 Addressing </A>
<LI> <A HREF="#page27"> 2.2 Data Types </A>
 <UL>
<LI> <A HREF="#page27"> 2.2.1 Byte </A>
<LI> <A HREF="#page27"> 2.2.2 Word </A>
<LI> <A HREF="#page28"> 2.2.3 Longword </A>
<LI> <A HREF="#page28"> 2.2.4 Quadword </A>
<LI> <A HREF="#page29"> 2.2.5 VAX Floating-Point Formats </A>
 <UL>
<LI> <A HREF="#page29"> 2.2.5.1 F_floating </A>
<LI> <A HREF="#page30"> 2.2.5.2 G_floating </A>
<LI> <A HREF="#page31"> 2.2.5.3 D_floating </A>
</UL>
<LI> <A HREF="#page32"> 2.2.6 IEEE Floating-Point Formats </A>
 <UL>
<LI> <A HREF="#page33"> 2.2.6.1 S_Floating </A>
<LI> <A HREF="#page34"> 2.2.6.2 T_floating </A>
<LI> <A HREF="#page35"> 2.2.6.3 X_Floating </A>
</UL>
<LI> <A HREF="#page37"> 2.2.7 Longword Integer Format in Floating-Point Unit </A>
<LI> <A HREF="#page38"> 2.2.8 Quadword Integer Format in Floating-Point Unit </A>
<LI> <A HREF="#page38"> 2.2.9 Data Types with No Hardware Support </A>
</UL>
<LI> <A HREF="#page39"> 2.3 Big-Endian Addressing Support </A>
</UL>
<LI> <A HREF="#page41"> Instruction Formats </A>
 <UL>
<LI> <A HREF="#page41"> 3.1 Alpha Registers </A>
 <UL>
<LI> <A HREF="#page41"> 3.1.1 Program Counter </A>
<LI> <A HREF="#page41"> 3.1.2 Integer Registers </A>
<LI> <A HREF="#page42"> 3.1.3 Floating-Point Registers </A>
<LI> <A HREF="#page42"> 3.1.4 Lock Registers </A>
<LI> <A HREF="#page43"> 3.1.5 Processor Cycle Counter (PCC) Register </A>
<LI> <A HREF="#page43"> 3.1.6 Optional Registers </A>
 <UL>
<LI> <A HREF="#page43"> 3.1.6.1 Memory Prefetch Registers </A>
<LI> <A HREF="#page43"> 3.1.6.2 VAX Compatibility Register </A>
</UL>
</UL>
<LI> <A HREF="#page43"> 3.2 Notation </A>
 <UL>
<LI> <A HREF="#page44"> 3.2.1 Operand Notation </A>
<LI> <A HREF="#page45"> 3.2.2 Instruction Operand Notation </A>
 <UL>
<LI> <A HREF="#page45"> 3.2.2.1 Operand Name Notation </A>
<LI> <A HREF="#page45"> 3.2.2.2 Operand Access Type Notation </A>
<LI> <A HREF="#page46"> 3.2.2.3 Operand Data Type Notation </A>
</UL>
<LI> <A HREF="#page46"> 3.2.3 Operators </A>
<LI> <A HREF="#page50"> 3.2.4 Notation Conventions </A>
</UL>
<LI> <A HREF="#page50"> 3.3 Instruction Formats </A>
 <UL>
<LI> <A HREF="#page51"> 3.3.1 Memory Instruction Format </A>
 <UL>
<LI> <A HREF="#page51"> 3.3.1.1 Memory Format Instructions with a Function Code </A>
<LI> <A HREF="#page52"> 3.3.1.2 Memory Format Jump Instructions </A>
</UL>
<LI> <A HREF="#page52"> 3.3.2 Branch Instruction Format </A>
<LI> <A HREF="#page52"> 3.3.3 Operate Instruction Format </A>
<LI> <A HREF="#page53"> 3.3.4 Floating-Point Operate Instruction Format </A>
 <UL>
<LI> <A HREF="#page54"> 3.3.4.1 Floating-Point Convert Instructions </A>
<LI> <A HREF="#page54"> 3.3.4.2 Floating-Point/Integer Register Moves </A>
</UL>
<LI> <A HREF="#page54"> 3.3.5 PALcode Instruction Format </A>
</UL>
</UL>
<LI> <A HREF="#page57"> Instruction Descriptions </A>
 <UL>
<LI> <A HREF="#page57"> 4.1 Instruction Set Overview </A>
 <UL>
<LI> <A HREF="#page58"> 4.1.1 Subsetting Rules </A>
<LI> <A HREF="#page58"> 4.1.2 Floating-Point Subsets </A>
<LI> <A HREF="#page59"> 4.1.3 Software Emulation Rules </A>
<LI> <A HREF="#page59"> 4.1.4 Opcode Qualifiers </A>
</UL>
<LI> <A HREF="#page60"> 4.2 Memory Integer Load/Store Instructions </A>
 <UL>
<LI> <A HREF="#page61"> 4.2.1 Load Address </A>
<LI> <A HREF="#page62"> 4.2.2 Load Memory Data into Integer Register </A>
<LI> <A HREF="#page64"> 4.2.3 Load Unaligned Memory Data into Integer Register </A>
<LI> <A HREF="#page65"> 4.2.4 Load Memory Data into Integer Register Locked </A>
<LI> <A HREF="#page68"> 4.2.5 Store Integer Register Data into Memory Conditional </A>
<LI> <A HREF="#page71"> 4.2.6 Store Integer Register Data into Memory </A>
<LI> <A HREF="#page73"> 4.2.7 Store Unaligned Integer Register Data into Memory </A>
</UL>
<LI> <A HREF="#page74"> 4.3 Control Instructions </A>
 <UL>
<LI> <A HREF="#page76"> 4.3.1 Conditional Branch </A>
<LI> <A HREF="#page77"> 4.3.2 Unconditional Branch </A>
<LI> <A HREF="#page78"> 4.3.3 Jumps </A>
</UL>
<LI> <A HREF="#page80"> 4.4 Integer Arithmetic Instructions </A>
 <UL>
<LI> <A HREF="#page81"> 4.4.1 Longword Add </A>
<LI> <A HREF="#page82"> 4.4.2 Scaled Longword Add </A>
<LI> <A HREF="#page83"> 4.4.3 Quadword Add </A>
<LI> <A HREF="#page84"> 4.4.4 Scaled Quadword Add </A>
<LI> <A HREF="#page85"> 4.4.5 Integer Signed Compare </A>
<LI> <A HREF="#page86"> 4.4.6 Integer Unsigned Compare </A>
<LI> <A HREF="#page87"> 4.4.7 Count Leading Zero </A>
<LI> <A HREF="#page88"> 4.4.8 Count Population </A>
<LI> <A HREF="#page89"> 4.4.9 Count Trailing Zero </A>
<LI> <A HREF="#page90"> 4.4.10 Longword Multiply </A>
<LI> <A HREF="#page91"> 4.4.11 Quadword Multiply </A>
<LI> <A HREF="#page92"> 4.4.12 Unsigned Quadword Multiply High </A>
<LI> <A HREF="#page93"> 4.4.13 Longword Subtract </A>
<LI> <A HREF="#page94"> 4.4.14 Scaled Longword Subtract </A>
<LI> <A HREF="#page95"> 4.4.15 Quadword Subtract </A>
<LI> <A HREF="#page96"> 4.4.16 Scaled Quadword Subtract </A>
</UL>
<LI> <A HREF="#page97"> 4.5 Logical and Shift Instructions </A>
 <UL>
<LI> <A HREF="#page98"> 4.5.1 Logical Functions </A>
<LI> <A HREF="#page99"> 4.5.2 Conditional Move Integer </A>
<LI> <A HREF="#page101"> 4.5.3 Shift Logical </A>
<LI> <A HREF="#page102"> 4.5.4 Shift Arithmetic </A>
</UL>
<LI> <A HREF="#page103"> 4.6 Byte Manipulation Instructions </A>
 <UL>
<LI> <A HREF="#page105"> 4.6.1 Compare Byte </A>
<LI> <A HREF="#page107"> 4.6.2 Extract Byte </A>
<LI> <A HREF="#page111"> 4.6.3 Byte Insert </A>
<LI> <A HREF="#page113"> 4.6.4 Byte Mask </A>
<LI> <A HREF="#page116"> 4.6.5 Sign Extend </A>
<LI> <A HREF="#page117"> 4.6.6 Zero Bytes </A>
</UL>
<LI> <A HREF="#page118"> 4.7 Floating-Point Instructions </A>
 <UL>
<LI> <A HREF="#page118"> 4.7.1 Single-Precision Operations </A>
<LI> <A HREF="#page118"> 4.7.2 Subsets and Faults </A>
<LI> <A HREF="#page119"> 4.7.3 Definitions </A>
<LI> <A HREF="#page121"> 4.7.4 Encodings </A>
<LI> <A HREF="#page122"> 4.7.5 Rounding Modes </A>
<LI> <A HREF="#page123"> 4.7.6 Computational Models </A>
 <UL>
<LI> <A HREF="#page123"> 4.7.6.1 VAX-Format Arithmetic with Precise Exceptions </A>
<LI> <A HREF="#page124"> 4.7.6.2 High-Performance VAX-Format Arithmetic </A>
<LI> <A HREF="#page124"> 4.7.6.3 IEEE-Compliant Arithmetic </A>
<LI> <A HREF="#page124"> 4.7.6.4 IEEE-Compliant Arithmetic Without Inexact Exception </A>
<LI> <A HREF="#page125"> 4.7.6.5 High-Performance IEEE-Format Arithmetic </A>
</UL>
<LI> <A HREF="#page125"> 4.7.7 Trapping Modes </A>
 <UL>
<LI> <A HREF="#page125"> 4.7.7.1 VAX Trapping Modes </A>
<LI> <A HREF="#page127"> 4.7.7.2 IEEE Trapping Modes </A>
<LI> <A HREF="#page129"> 4.7.7.3 Arithmetic Trap Completion </A>
 <UL>
<LI> <A HREF="#page129"> 4.7.7.3.1 Trap Shadow Rules </A>
<LI> <A HREF="#page130"> 4.7.7.3.2 Trap Shadow Length Rules </A>
</UL>
<LI> <A HREF="#page132"> 4.7.7.4 Invalid Operation (INV) Arithmetic Trap </A>
<LI> <A HREF="#page133"> 4.7.7.5 Division by Zero (DZE) Arithmetic Trap </A>
<LI> <A HREF="#page133"> 4.7.7.6 Overflow (OVF) Arithmetic Trap </A>
<LI> <A HREF="#page134"> 4.7.7.7 Underflow (UNF) Arithmetic Trap </A>
<LI> <A HREF="#page134"> 4.7.7.8 Inexact Result (INE) Arithmetic Trap </A>
<LI> <A HREF="#page134"> 4.7.7.9 Integer Overflow (IOV) Arithmetic Trap </A>
<LI> <A HREF="#page134"> 4.7.7.10 IEEE Floating-Point Trap Disable Bits </A>
<LI> <A HREF="#page135"> 4.7.7.11 IEEE Denormal Control Bits </A>
</UL>
<LI> <A HREF="#page135"> 4.7.8 Floating-Point Control Register (FPCR) </A>
 <UL>
<LI> <A HREF="#page138"> 4.7.8.1 Accessing the FPCR </A>
<LI> <A HREF="#page139"> 4.7.8.2 Default Values of the FPCR </A>
<LI> <A HREF="#page139"> 4.7.8.3 Saving and Restoring the FPCR </A>
</UL>
<LI> <A HREF="#page140"> 4.7.9 Floating-Point Instruction Function Field Format </A>
<LI> <A HREF="#page144"> 4.7.10 IEEE Standard </A>
 <UL>
<LI> <A HREF="#page144"> 4.7.10.1 Conversion of NaN and Infinity Values </A>
<LI> <A HREF="#page145"> 4.7.10.2 Copying NaN Values </A>
<LI> <A HREF="#page145"> 4.7.10.3 Generating NaN Values </A>
<LI> <A HREF="#page145"> 4.7.10.4 Propagating NaN Values </A>
</UL>
</UL>
<LI> <A HREF="#page146"> 4.8 Memory Format Floating-Point Instructions </A>
 <UL>
<LI> <A HREF="#page147"> 4.8.1 Load F_floating </A>
<LI> <A HREF="#page148"> 4.8.2 Load G_floating </A>
<LI> <A HREF="#page149"> 4.8.3 Load S_floating </A>
<LI> <A HREF="#page150"> 4.8.4 Load T_floating </A>
<LI> <A HREF="#page151"> 4.8.5 Store F_floating </A>
<LI> <A HREF="#page152"> 4.8.6 Store G_floating </A>
<LI> <A HREF="#page153"> 4.8.7 Store S_floating </A>
<LI> <A HREF="#page154"> 4.8.8 Store T_floating </A>
</UL>
<LI> <A HREF="#page155"> 4.9 Branch Format Floating-Point Instructions </A>
 <UL>
<LI> <A HREF="#page156"> 4.9.1 Conditional Branch </A>
</UL>
<LI> <A HREF="#page158"> 4.10 Floating-Point Operate Format Instructions </A>
 <UL>
<LI> <A HREF="#page161"> 4.10.1 Copy Sign </A>
<LI> <A HREF="#page162"> 4.10.2 Convert Integer to Integer </A>
<LI> <A HREF="#page163"> 4.10.3 Floating-Point Conditional Move </A>
<LI> <A HREF="#page165"> 4.10.4 Move from/to Floating-Point Control Register </A>
<LI> <A HREF="#page166"> 4.10.5 VAX Floating Add </A>
<LI> <A HREF="#page167"> 4.10.6 IEEE Floating Add </A>
<LI> <A HREF="#page168"> 4.10.7 VAX Floating Compare </A>
<LI> <A HREF="#page169"> 4.10.8 IEEE Floating Compare </A>
<LI> <A HREF="#page170"> 4.10.9 Convert VAX Floating to Integer </A>
<LI> <A HREF="#page171"> 4.10.10 Convert Integer to VAX Floating </A>
<LI> <A HREF="#page172"> 4.10.11 Convert VAX Floating to VAX Floating </A>
<LI> <A HREF="#page173"> 4.10.12 Convert IEEE Floating to Integer </A>
<LI> <A HREF="#page174"> 4.10.13 Convert Integer to IEEE Floating </A>
<LI> <A HREF="#page175"> 4.10.14 Convert IEEE S_Floating to IEEE T_Floating </A>
<LI> <A HREF="#page176"> 4.10.15 Convert IEEE T_Floating to IEEE S_Floating </A>
<LI> <A HREF="#page177"> 4.10.16 VAX Floating Divide </A>
<LI> <A HREF="#page178"> 4.10.17 IEEE Floating Divide </A>
<LI> <A HREF="#page179"> 4.10.18 Floating-Point Register to Integer Register Move </A>
<LI> <A HREF="#page180"> 4.10.19 Integer Register to Floating-Point Register Move </A>
<LI> <A HREF="#page182"> 4.10.20 VAX Floating Multiply </A>
<LI> <A HREF="#page183"> 4.10.21 IEEE Floating Multiply </A>
<LI> <A HREF="#page184"> 4.10.22 VAX Floating Square Root </A>
<LI> <A HREF="#page185"> 4.10.23 IEEE Floating Square Root </A>
<LI> <A HREF="#page186"> 4.10.24 VAX Floating Subtract </A>
<LI> <A HREF="#page187"> 4.10.25 IEEE Floating Subtract </A>
</UL>
<LI> <A HREF="#page188"> 4.11 Miscellaneous Instructions </A>
 <UL>
<LI> <A HREF="#page189"> 4.11.1 Architecture Mask </A>
<LI> <A HREF="#page191"> 4.11.2 Call Privileged Architecture Library </A>
<LI> <A HREF="#page192"> 4.11.3 Evict Data Cache Block </A>
<LI> <A HREF="#page194"> 4.11.4 Exception Barrier </A>
<LI> <A HREF="#page195"> 4.11.5 Prefetch Data </A>
<LI> <A HREF="#page197"> 4.11.6 Implementation Version </A>
<LI> <A HREF="#page198"> 4.11.7 Memory Barrier </A>
<LI> <A HREF="#page199"> 4.11.8 Read Processor Cycle Counter </A>
<LI> <A HREF="#page200"> 4.11.9 Trap Barrier </A>
<LI> <A HREF="#page201"> 4.11.10 Write Hint </A>
<LI> <A HREF="#page203"> 4.11.11 Write Memory Barrier </A>
</UL>
<LI> <A HREF="#page205"> 4.12 VAX Compatibility Instructions </A>
 <UL>
<LI> <A HREF="#page206"> 4.12.1 VAX Compatibility Instructions </A>
</UL>
<LI> <A HREF="#page207"> 4.13 Multimedia (Graphics and Video) Support </A>
 <UL>
<LI> <A HREF="#page208"> 4.13.1 Byte and Word Minimum and Maximum </A>
<LI> <A HREF="#page210"> 4.13.2 Pixel Error </A>
<LI> <A HREF="#page211"> 4.13.3 Pack Bytes </A>
<LI> <A HREF="#page212"> 4.13.4 Unpack Bytes </A>
</UL>
</UL>
<LI> <A HREF="#page213"> System Architecture and Programming Implications </A>
 <UL>
<LI> <A HREF="#page213"> 5.1 Introduction </A>
<LI> <A HREF="#page213"> 5.2 Physical Address Space Characteristics </A>
 <UL>
<LI> <A HREF="#page213"> 5.2.1 Coherency of Memory Access </A>
<LI> <A HREF="#page214"> 5.2.2 Granularity of Memory Access </A>
<LI> <A HREF="#page215"> 5.2.3 Width of Memory Access </A>
<LI> <A HREF="#page215"> 5.2.4 Memory-Like and Non-Memory-Like Behavior </A>
</UL>
<LI> <A HREF="#page216"> 5.3 Translation Buffers and Virtual Caches </A>
<LI> <A HREF="#page216"> 5.4 Caches and Write Buffers </A>
<LI> <A HREF="#page218"> 5.5 Data Sharing </A>
 <UL>
<LI> <A HREF="#page218"> 5.5.1 Atomic Change of a Single Datum </A>
<LI> <A HREF="#page218"> 5.5.2 Atomic Update of a Single Datum </A>
<LI> <A HREF="#page219"> 5.5.3 Atomic Update of Data Structures </A>
<LI> <A HREF="#page221"> 5.5.4 Ordering Considerations for Shared Data Structures </A>
</UL>
<LI> <A HREF="#page222"> 5.6 Read/Write Ordering </A>
 <UL>
<LI> <A HREF="#page222"> 5.6.1 Alpha Shared Memory Model </A>
 <UL>
<LI> <A HREF="#page224"> 5.6.1.1 Architectural Definition of Processor Issue Sequence </A>
<LI> <A HREF="#page224"> 5.6.1.2 Definition of Before and After </A>
<LI> <A HREF="#page224"> 5.6.1.3 Definition of Processor Issue Constraints </A>
<LI> <A HREF="#page226"> 5.6.1.4 Definition of Location Access Constraints </A>
<LI> <A HREF="#page226"> 5.6.1.5 Definition of Visibility </A>
<LI> <A HREF="#page226"> 5.6.1.6 Definition of Storage </A>
<LI> <A HREF="#page227"> 5.6.1.7 Definition of Dependence Constraint </A>
<LI> <A HREF="#page228"> 5.6.1.8 Definition of Load-Locked and Store-Conditional </A>
<LI> <A HREF="#page229"> 5.6.1.9 Timeliness </A>
</UL>
<LI> <A HREF="#page229"> 5.6.2 Litmus Tests </A>
 <UL>
<LI> <A HREF="#page229"> 5.6.2.1 Litmus Test 1 (Impossible Sequence) </A>
<LI> <A HREF="#page230"> 5.6.2.2 Litmus Test 2 (Impossible Sequence) </A>
<LI> <A HREF="#page230"> 5.6.2.3 Litmus Test 3 (Impossible Sequence) </A>
<LI> <A HREF="#page231"> 5.6.2.4 Litmus Test 4 (Sequence Okay) </A>
<LI> <A HREF="#page231"> 5.6.2.5 Litmus Test 5 (Sequence Okay) </A>
<LI> <A HREF="#page231"> 5.6.2.6 Litmus Test 6 (Sequence Okay) </A>
<LI> <A HREF="#page232"> 5.6.2.7 Litmus Test 7 (Impossible Sequence) </A>
<LI> <A HREF="#page232"> 5.6.2.8 Litmus Test 8 (Impossible Sequence) </A>
<LI> <A HREF="#page233"> 5.6.2.9 Litmus Test 9 (Impossible Sequence) </A>
<LI> <A HREF="#page233"> 5.6.2.10 Litmus Test 10 (Sequence Okay) </A>
<LI> <A HREF="#page233"> 5.6.2.11 Litmus Test 11 (Impossible Sequence) </A>
</UL>
<LI> <A HREF="#page234"> 5.6.3 Implied Barriers </A>
<LI> <A HREF="#page234"> 5.6.4 Implications for Software </A>
 <UL>
<LI> <A HREF="#page234"> 5.6.4.1 Single Processor Data Stream </A>
<LI> <A HREF="#page234"> 5.6.4.2 Single Processor Instruction Stream </A>
<LI> <A HREF="#page234"> 5.6.4.3 Multiprocessor Data Stream (Including Single Processor with DMA I/O) </A>
<LI> <A HREF="#page235"> 5.6.4.4 Multiprocessor Instruction Stream (Including Single Processor with DMA I/O) </A>
<LI> <A HREF="#page236"> 5.6.4.5 Multiprocessor Context Switch </A>
<LI> <A HREF="#page238"> 5.6.4.6 Multiprocessor Send/Receive Interrupt </A>
<LI> <A HREF="#page239"> 5.6.4.7 Implications for Memory Mapped I/O </A>
<LI> <A HREF="#page240"> 5.6.4.8 Multiple Processors Writing to a Single I/O Device </A>
</UL>
<LI> <A HREF="#page241"> 5.6.5 Implications for Hardware </A>
</UL>
<LI> <A HREF="#page242"> 5.7 Arithmetic Traps </A>
</UL>
<LI> <A HREF="#page243"> Common PALcode Architecture </A>
 <UL>
<LI> <A HREF="#page243"> 6.1 PALcode </A>
<LI> <A HREF="#page243"> 6.2 PALcode Instructions and Functions </A>
<LI> <A HREF="#page244"> 6.3 PALcode Environment </A>
<LI> <A HREF="#page244"> 6.4 Special Functions Required for PALcode </A>
<LI> <A HREF="#page245"> 6.5 PALcode Effects on System Code </A>
<LI> <A HREF="#page245"> 6.6 PALcode Replacement </A>
<LI> <A HREF="#page246"> 6.7 Required PALcode Instructions </A>
 <UL>
<LI> <A HREF="#page248"> 6.7.1 Drain Aborts </A>
<LI> <A HREF="#page249"> 6.7.2 Halt </A>
<LI> <A HREF="#page250"> 6.7.3 Instruction Memory Barrier </A>
</UL>
</UL>
<LI> <A HREF="#page251"> Console Subsystem Overview </A>
<LI> <A HREF="#page253"> Input/Output Overview </A>
<LI> <A HREF="#page255"> OpenVMS Alpha </A>
 <UL>
<LI> <A HREF="#page255"> 9.1 Unprivileged OpenVMS Alpha PALcode </A>
<LI> <A HREF="#page262"> 9.2 Privileged OpenVMS Alpha Palcode </A>
</UL>
<LI> <A HREF="#page265"> Digital UNIX </A>
 <UL>
<LI> <A HREF="#page265"> 10.1 Unprivileged Digital UNIX PALcode </A>
<LI> <A HREF="#page266"> 10.2 Privileged Digital UNIX PALcode </A>
</UL>
<LI> <A HREF="#page269"> Windows NT Alpha </A>
 <UL>
<LI> <A HREF="#page269"> 11.1 Unprivileged Windows NT Alpha PALcode </A>
<LI> <A HREF="#page270"> 11.2 Privileged Windows NT Alpha PALcode </A>
</UL>
<LI> <A HREF="#page275"> Software Considerations </A>
 <UL>
<LI> <A HREF="#page275"> A.1 Hardware-Software Compact </A>
<LI> <A HREF="#page276"> A.2 Instruction-Stream Considerations </A>
 <UL>
<LI> <A HREF="#page276"> A.2.1 Instruction Alignment </A>
<LI> <A HREF="#page276"> A.2.2 Branch Prediction and Minimizing Branch-Taken „ Factor of 3 </A>
<LI> <A HREF="#page278"> A.2.3 Improving I-Stream Density „ Factor of 3 </A>
<LI> <A HREF="#page278"> A.2.4 Instruction Scheduling „ Factor of 3 </A>
</UL>
<LI> <A HREF="#page278"> A.3 Data-Stream Considerations </A>
 <UL>
<LI> <A HREF="#page278"> A.3.1 Data Alignment „ Factor of 10 </A>
<LI> <A HREF="#page279"> A.3.2 Shared Data in Multiple Processors „ Factor of 3 </A>
<LI> <A HREF="#page280"> A.3.3 Avoiding Cache/TB Conflicts „ Factor of 1 </A>
<LI> <A HREF="#page282"> A.3.4 Sequential Read/Write „ Factor of 1 </A>
<LI> <A HREF="#page282"> A.3.5 Prefetching „ Factor of 3 </A>
</UL>
<LI> <A HREF="#page283"> A.4 Code Sequences </A>
 <UL>
<LI> <A HREF="#page283"> A.4.1 Aligned Byte/Word (Within Register) Memory Accesses </A>
<LI> <A HREF="#page284"> A.4.2 Division </A>
<LI> <A HREF="#page285"> A.4.3 Byte Swap </A>
<LI> <A HREF="#page285"> A.4.4 Stylized Code Forms </A>
 <UL>
<LI> <A HREF="#page285"> A.4.4.1 NOP </A>
<LI> <A HREF="#page286"> A.4.4.2 Clear a Register </A>
<LI> <A HREF="#page286"> A.4.4.3 Load Literal </A>
<LI> <A HREF="#page287"> A.4.4.4 Register-to-Register Move </A>
<LI> <A HREF="#page287"> A.4.4.5 Negate </A>
<LI> <A HREF="#page287"> A.4.4.6 NOT </A>
<LI> <A HREF="#page287"> A.4.4.7 Booleans </A>
</UL>
<LI> <A HREF="#page288"> A.4.5 Exceptions and Trap Barriers </A>
<LI> <A HREF="#page288"> A.4.6 Pseudo-Operations (Stylized Code Forms) </A>
</UL>
<LI> <A HREF="#page290"> A.5 Timing Considerations: Atomic Sequences </A>
</UL>
<LI> <A HREF="#page291"> IEEE Floating-Point Conformance </A>
 <UL>
<LI> <A HREF="#page291"> B.1 Alpha Choices for IEEE Options </A>
<LI> <A HREF="#page293"> B.2 Alpha Support for OS Completion Handlers </A>
 <UL>
<LI> <A HREF="#page294"> B.2.1 IEEE Floating-Point Control (FP_C) Quadword </A>
</UL>
<LI> <A HREF="#page296"> B.3 Mapping to IEEE Standard </A>
</UL>
<LI> <A HREF="#page303"> Instruction Summary </A>
 <UL>
<LI> <A HREF="#page303"> C.1 Common Architecture Instruction Summary </A>
<LI> <A HREF="#page308"> C.2 IEEE Floating-Point Instructions </A>
<LI> <A HREF="#page309"> C.3 VAX Floating-Point Instructions </A>
<LI> <A HREF="#page310"> C.4 Independent Floating-Point Instructions </A>
<LI> <A HREF="#page310"> C.5 Opcode Summary </A>
<LI> <A HREF="#page312"> C.6 Common Architecture Opcodes in Numerical Order </A>
<LI> <A HREF="#page316"> C.7 OpenVMS Alpha PALcode Instruction Summary </A>
<LI> <A HREF="#page318"> C.8 DIGITAL UNIX PALcode Instruction Summary </A>
<LI> <A HREF="#page319"> C.9 Windows NT Alpha Instruction Summary </A>
<LI> <A HREF="#page320"> C.10 PALcode Opcodes in Numerical Order </A>
<LI> <A HREF="#page322"> C.11 Required PALcode Opcodes </A>
<LI> <A HREF="#page322"> C.12 Opcodes Reserved to PALcode </A>
<LI> <A HREF="#page323"> C.13 Opcodes Reserved to Compaq </A>
<LI> <A HREF="#page323"> C.14 Unused Function Code Behavior </A>
<LI> <A HREF="#page324"> C.15 ASCII Character Set </A>
</UL>
<LI> <A HREF="#page325"> Registered System and Processor Identifiers </A>
 <UL>
<LI> <A HREF="#page325"> D.1 Processor Type Assignments </A>
<LI> <A HREF="#page326"> D.2 PALcode Variation Assignments </A>
<LI> <A HREF="#page327"> D.3 Architecture Mask and Implementation Values </A>
</UL>
<LI> <A HREF="#page329"> Waivers and Implementation-Dependent Functionality </A>
 <UL>
<LI> <A HREF="#page329"> E.1 Waivers </A>
 <UL>
<LI> <A HREF="#page329"> E.1.1 DECchip 21064, DECchip 21066, and DECchip 21068 IEEE Divide Instruction Violation </A>
<LI> <A HREF="#page330"> E.1.2 DECchip 21064, DECchip 21066, and DECchip 21068 Write Buffer Violation </A>
<LI> <A HREF="#page330"> E.1.3 DECchip 21264 LDx_L/STx_C with WH64 Violation </A>
</UL>
<LI> <A HREF="#page331"> E.2 Implementation-Specific Functionality </A>
 <UL>
<LI> <A HREF="#page331"> E.2.1 DECchip 21064/21066/21068 Performance Monitoring </A>
 <UL>
<LI> <A HREF="#page332"> E.2.1.1 DECchip 21064/21066/21068 Performance Monitor Interrupt Mechanism </A>
<LI> <A HREF="#page333"> E.2.1.2 Functions and Arguments for the DECchip 21064/21066/21068 </A>
</UL>
<LI> <A HREF="#page337"> E.2.2 DECchip 21164/21164PC Performance Monitoring </A>
 <UL>
<LI> <A HREF="#page337"> E.2.2.1 Performance Monitor Interrupt Mechanism </A>
<LI> <A HREF="#page338"> E.2.2.2 Windows NT Alpha Functions and Argument </A>
<LI> <A HREF="#page340"> E.2.2.3 OpenVMS Alpha and DIGITAL UNIX Functions and Arguments </A>
</UL>
<LI> <A HREF="#page351"> E.2.3 21264 Performance Monitoring </A>
 <UL>
<LI> <A HREF="#page351"> E.2.3.1 Performance Monitor Interrupt Mechanism </A>
<LI> <A HREF="#page352"> E.2.3.2 Windows NT Alpha Functions and Argument </A>
<LI> <A HREF="#page353"> E.2.3.3 OpenVMS Alpha and DIGITAL UNIX Functions and Arguments </A>
</UL>
</UL>
</UL>
<LI> <A HREF="#page359"> Index </A>
 <UL>
<LI> <A HREF="#page359"> A </A>
<LI> <A HREF="#page360"> B </A>
<LI> <A HREF="#page360"> C </A>
<LI> <A HREF="#page361"> D </A>
<LI> <A HREF="#page362"> E </A>
<LI> <A HREF="#page362"> F </A>
<LI> <A HREF="#page363"> G </A>
<LI> <A HREF="#page363"> H </A>
<LI> <A HREF="#page364"> I </A>
<LI> <A HREF="#page365"> J </A>
<LI> <A HREF="#page365"> L </A>
<LI> <A HREF="#page366"> M </A>
<LI> <A HREF="#page367"> N </A>
<LI> <A HREF="#page367"> O </A>
<LI> <A HREF="#page367"> P </A>
<LI> <A HREF="#page368"> Q </A>
<LI> <A HREF="#page368"> R </A>
<LI> <A HREF="#page368"> S </A>
<LI> <A HREF="#page369"> T </A>
<LI> <A HREF="#page370"> U </A>
<LI> <A HREF="#page370"> V </A>
<LI> <A HREF="#page370"> W </A>
<LI> <A HREF="#page370"> X </A>
<LI> <A HREF="#page371"> Y </A>
<LI> <A HREF="#page371"> Z </A>
</UL>
</UL>
</UL>
 <H1><A name="DocumentBody">Pages 1--371 from  Untitled Document</A></H1>
<BR>
<strong><A name=page1> Page 1</A></strong>
<A href=#page2>2</A>
<BR>
<B>Compaq Computer Corporation <BR>
</B>Alpha Architecture Handbook <BR>
Order Number: EC– QD2KC– TE <BR>
<P>
<B>Revision/ Update Information: </B>This is Version 4 of the Alpha <BR>
Architecture Handbook. 
1
<BR>
<A href=#page1>1</A>
<strong><A name=page2> Page 2</A></strong>
<A href=#page3>3</A>
<BR>
<B>October 1998 <BR>
</B>The information in this publication is subject to change without notice. <BR>
COMPAQ COMPUTER CORPORATION SHALL NOT BE LIABLE FOR TECHNICAL OR EDITORIAL <BR>
ERRORS OR OMISSIONS CONTAINED HEREIN, NOR FOR INCIDENTAL OR CONSEQUENTIAL DAM-AGES <BR>
RESULTING FROM THE FURNISHING, PERFORMANCE, OR USE OF THIS MATERIAL. THIS <BR>
INFORMATION IS PROVIDED "AS IS" AND COMPAQ COMPUTER CORPORATION DISCLAIMS ANY <BR>
WARRANTIES, EXPRESS, IMPLIED OR STATUTORY AND EXPRESSLY DISCLAIMS THE IMPLIED WAR-RANTIES <BR>
OF MERCHANTABILITY, FITNESS FOR PARTICULAR PURPOSE, GOOD TITLE AND AGAINST <BR>
INFRINGEMENT. <BR>
<P>
This publication contains information protected by copyright. No part of this publication may be photocopied or <BR>
reproduced in any form without prior written consent from Compaq Computer Corporation. <BR>
<P>
© Compaq Computer Corporation 1998. <BR>
All rights reserved. Printed in the U. S. A. <BR>
<P>
The following are trademarks of Comaq Computer Corporation: Alpha AXP, AXP, DEC, DIGITAL, DIGITAL <BR>
UNIX, OpenVMS, PDP– 11, VAX, VAX DOCUMENT, and the DIGITAL logo. <BR>
<P>
Cray is a registered trademark of Cray Research, Inc. IBM is a registered trademark of International Business <BR>
Machines Corporation. UNIX is a registered trademark in the United States and other countries licensed exclusively <BR>
through X/ Open Company Ltd. Windows NT is a trademark of Microsoft Corporation. <BR>
<P>
All other trademarks and registered trademarks are the property of their respective owners. 
2
<BR>
<A href=#page2>2</A>
<strong><A name=page3> Page 3</A></strong>
<A href=#page4>4</A>
<BR>
<P>
iii <BR>
<B>Table of Contents <BR>
<A href="#page17">1 Introduction <BR>
</A>
<A href="#page17">1. 1 The Alpha Approach to RISC Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1– 1 <BR>
</A>
<A href="#page19">1. 2 Data Format Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1– 3 <BR>
</A>
<A href="#page20">1. 3 Instruction Format Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1– 4 <BR>
</A>
<A href="#page20">1. 4 Instruction Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1– 4 <BR>
</A>
<A href="#page22">1. 5 Instruction Set Characteristics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1– 6 <BR>
</A>
<A href="#page22">1.6 Terminology and Conventions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1– 6 <BR>
</A>
<A href="#page23">1. 6. 1 Numbering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1– 7 <BR>
</A>
<A href="#page23">1. 6. 2 Security Holes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1– 7 <BR>
</A>
<A href="#page23">1.6.3 UNPREDICTABLE and UNDEFINED . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1– 7 <BR>
</A>
<A href="#page24">1.6.4 Ranges and Extents. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1– 8 <BR>
</A>
<A href="#page24">1. 6. 5 ALIGNED and UNALIGNED . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1– 8 <BR>
</A>
<A href="#page25">1. 6. 6 Must Be Zero (MBZ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1– 9 <BR>
</A>
<A href="#page25">1. 6. 7 Read As Zero (RAZ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1– 9 <BR>
</A>
<A href="#page25">1. 6. 8 Should Be Zero (SBZ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1– 9 <BR>
</A>
<A href="#page25">1.6.9 Ignore (IGN) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1– 9 <BR>
</A>
<A href="#page25">1.6.10 Implementation Dependent (IMP) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1– 9 <BR>
</A>
<A href="#page25">1. 6. 11 Illustration Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1– 9 <BR>
</A>
<A href="#page25">1.6.12 Macro Code Example Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1– 9 <BR>
</A>
<P>
<A href="#page27">2 Basic Architecture <BR>
</A>
<A href="#page27">2. 1 Addressing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 1 <BR>
</A>
<A href="#page27">2. 2 Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 1 <BR>
</A>
<A href="#page27">2. 2. 1 Byte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 1 <BR>
</A>
<A href="#page27">2. 2. 2 Word. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 1 <BR>
</A>
<A href="#page28">2. 2. 3 Longword . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 2 <BR>
</A>
<A href="#page28">2. 2. 4 Quadword. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 2 <BR>
</A>
<A href="#page29">2.2.5 VAX Floating-Point Formats. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 3 <BR>
</A>
<A href="#page29">2. 2. 5. 1 F_floating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 3 <BR>
</A>
<A href="#page30">2. 2. 5. 2 G_floating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 4 <BR>
</A>
<A href="#page31">2. 2. 5. 3 D_floating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 5 <BR>
</A>
<A href="#page32">2.2.6 IEEE Floating-Point Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 6 <BR>
</A>
<A href="#page33">2. 2. 6. 1 S_Floating. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 7 <BR>
</A>
<A href="#page34">2. 2. 6. 2 T_floating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 8 <BR>
</A>
<A href="#page35">2. 2. 6. 3 X_Floating. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 9 <BR>
</A>
<A href="#page37">2.2.7 Longword Integer Format in Floating-Point Unit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 11 <BR>
</A>
<A href="#page38">2. 2. 8 Quadword Integer Format in Floating-Point Unit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 12 <BR>
</A>
<A href="#page38">2.2.9 Data Types with No Hardware Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 12 
3
<BR>
<A href=#page3>3</A>
<strong><A name=page4> Page 4</A></strong>
<A href=#page5>5</A>
<BR>
<P>
</A>
iv <BR>
<A href="#page39">2.3 Big-Endian Addressing Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 13 <BR>
</A>
<A href="#page41">3 Instruction Formats <BR>
</A>
<A href="#page41">3.1 Alpha Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 1 <BR>
</A>
<A href="#page41">3. 1. 1 Program Counter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 1 <BR>
</A>
<A href="#page41">3.1.2 Integer Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 1 <BR>
</A>
<A href="#page42">3. 1. 3 Floating-Point Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 2 <BR>
</A>
<A href="#page42">3. 1. 4 Lock Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 2 <BR>
</A>
<A href="#page43">3. 1. 5 Processor Cycle Counter (PCC) Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 3 <BR>
</A>
<A href="#page43">3.1.6 Optional Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 3 <BR>
</A>
<A href="#page43">3. 1. 6. 1 Memory Prefetch Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 3 <BR>
</A>
<A href="#page43">3.1.6.2 VAX Compatibility Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 3 <BR>
</A>
<A href="#page43">3. 2 Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 3 <BR>
</A>
<A href="#page44">3. 2. 1 Operand Notation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 4 <BR>
</A>
<A href="#page45">3.2.2 Instruction Operand Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 5 <BR>
</A>
<A href="#page45">3. 2. 2. 1 Operand Name Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 5 <BR>
</A>
<A href="#page45">3. 2. 2. 2 Operand Access Type Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 5 <BR>
</A>
<A href="#page46">3. 2. 2. 3 Operand Data Type Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 6 <BR>
</A>
<A href="#page46">3. 2. 3 Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 6 <BR>
</A>
<A href="#page50">3. 2. 4 Notation Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 10 <BR>
</A>
<A href="#page50">3. 3 Instruction Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 10 <BR>
</A>
<A href="#page51">3. 3. 1 Memory Instruction Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 11 <BR>
</A>
<A href="#page51">3. 3. 1. 1 Memory Format Instructions with a Function Code . . . . . . . . . . . . . . . . . . . . . . . . 3– 11 <BR>
</A>
<A href="#page52">3. 3. 1. 2 Memory Format Jump Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 12 <BR>
</A>
<A href="#page52">3. 3. 2 Branch Instruction Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 12 <BR>
</A>
<A href="#page52">3. 3. 3 Operate Instruction Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 12 <BR>
</A>
<A href="#page53">3. 3. 4 Floating-Point Operate Instruction Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 13 <BR>
</A>
<A href="#page54">3. 3. 4. 1 Floating-Point Convert Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 14 <BR>
</A>
<A href="#page54">3. 3. 4. 2 Floating-Point/ Integer Register Moves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 14 <BR>
</A>
<A href="#page54">3.3.5 PALcode Instruction Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 14 <BR>
</A>
<P>
<A href="#page57">4 Instruction Descriptions <BR>
</A>
<A href="#page57">4. 1 Instruction Set Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 1 <BR>
</A>
<A href="#page58">4. 1. 1 Subsetting Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 2 <BR>
</A>
<A href="#page58">4. 1. 2 Floating-Point Subsets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 2 <BR>
</A>
<A href="#page59">4. 1. 3 Software Emulation Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 3 <BR>
</A>
<A href="#page59">4.1.4 Opcode Qualifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 3 <BR>
</A>
<A href="#page60">4.2 Memory Integer Load/ Store Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 4 <BR>
</A>
<A href="#page61">4. 2. 1 Load Address . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 5 <BR>
</A>
<A href="#page62">4.2.2 Load Memory Data into Integer Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 6 <BR>
</A>
<A href="#page64">4.2.3 Load Unaligned Memory Data into Integer Register . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 8 <BR>
</A>
<A href="#page65">4.2.4 Load Memory Data into Integer Register Locked . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 9 <BR>
</A>
<A href="#page68">4.2.5 Store Integer Register Data into Memory Conditional . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 12 <BR>
</A>
<A href="#page71">4.2.6 Store Integer Register Data into Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 15 <BR>
</A>
<A href="#page73">4.2.7 Store Unaligned Integer Register Data into Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 17 <BR>
</A>
<A href="#page74">4. 3 Control Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 18 <BR>
</A>
<A href="#page76">4.3.1 Conditional Branch. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 20 <BR>
</A>
<A href="#page77">4.3.2 Unconditional Branch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 21 <BR>
</A>
<A href="#page78">4. 3. 3 Jumps. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 22 <BR>
</A>
<A href="#page80">4.4 Integer Arithmetic Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 24 <BR>
</A>
<A href="#page81">4. 4. 1 Longword Add . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 25 <BR>
</A>
<A href="#page82">4.4.2 Scaled Longword Add . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 26 <BR>
</A>
<A href="#page83">4. 4. 3 Quadword Add . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 27 <BR>
</A>
<A href="#page38">4. 4. 4 Scaled Quadword Add . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 28 
4
<BR>
<A href=#page4>4</A>
<strong><A name=page5> Page 5</A></strong>
<A href=#page6>6</A>
<BR>
<P>
</A>
v <BR>
<A href="#page85">4.4.5 Integer Signed Compare . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 29 <BR>
</A>
<A href="#page86">4.4.6 Integer Unsigned Compare . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 30 <BR>
</A>
<A href="#page87">4.4.7 Count Leading Zero . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 31 <BR>
</A>
<A href="#page88">4.4.8 Count Population . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 32 <BR>
</A>
<A href="#page89">4. 4. 9 Count Trailing Zero . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 33 <BR>
</A>
<A href="#page90">4. 4. 10 Longword Multiply . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 34 <BR>
</A>
<A href="#page91">4. 4. 11 Quadword Multiply . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 35 <BR>
</A>
<A href="#page92">4.4.12 Unsigned Quadword Multiply High. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 36 <BR>
</A>
<A href="#page93">4. 4. 13 Longword Subtract . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 37 <BR>
</A>
<A href="#page94">4.4.14 Scaled Longword Subtract . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 38 <BR>
</A>
<A href="#page95">4. 4. 15 Quadword Subtract . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 39 <BR>
</A>
<A href="#page96">4. 4. 16 Scaled Quadword Subtract . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 40 <BR>
</A>
<A href="#page97">4. 5 Logical and Shift Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 41 <BR>
</A>
<A href="#page98">4. 5. 1 Logical Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 42 <BR>
</A>
<A href="#page99">4.5.2 Conditional Move Integer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 43 <BR>
</A>
<A href="#page101">4.5.3 Shift Logical . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 45 <BR>
</A>
<A href="#page102">4. 5. 4 Shift Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 46 <BR>
</A>
<A href="#page103">4. 6 Byte Manipulation Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 47 <BR>
</A>
<A href="#page105">4. 6. 1 Compare Byte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 49 <BR>
</A>
<A href="#page107">4. 6. 2 Extract Byte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 51 <BR>
</A>
<A href="#page111">4. 6. 3 Byte Insert . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 55 <BR>
</A>
<A href="#page113">4. 6. 4 Byte Mask . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 57 <BR>
</A>
<A href="#page116">4.6.5 Sign Extend . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 60 <BR>
</A>
<A href="#page117">4. 6. 6 Zero Bytes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 61 <BR>
</A>
<A href="#page118">4. 7 Floating-Point Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 62 <BR>
</A>
<A href="#page118">4. 7. 1 Single-Precision Operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 62 <BR>
</A>
<A href="#page118">4.7.2 Subsets and Faults . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 62 <BR>
</A>
<A href="#page119">4. 7. 3 Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 63 <BR>
</A>
<A href="#page121">4. 7. 4 Encodings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 65 <BR>
</A>
<A href="#page122">4. 7. 5 Rounding Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 66 <BR>
</A>
<A href="#page123">4.7.6 Computational Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 67 <BR>
</A>
<A href="#page123">4.7.6.1 VAX-Format Arithmetic with Precise Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 67 <BR>
</A>
<A href="#page124">4.7.6.2 High-Performance VAX-Format Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 68 <BR>
</A>
<A href="#page124">4.7.6.3 IEEE-Compliant Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 68 <BR>
</A>
<A href="#page124">4.7.6.4 IEEE-Compliant Arithmetic Without Inexact Exception. . . . . . . . . . . . . . . . . . . . . . 4– 68 <BR>
</A>
<A href="#page125">4.7.6.5 High-Performance IEEE-Format Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 69 <BR>
</A>
<A href="#page125">4.7.7 Trapping Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 69 <BR>
</A>
<A href="#page125">4.7.7.1 VAX Trapping Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 69 <BR>
</A>
<A href="#page127">4.7.7.2 IEEE Trapping Modes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 71 <BR>
</A>
<A href="#page129">4. 7. 7. 3 Arithmetic Trap Completion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 73 <BR>
</A>
<A href="#page129">4.7.7.3.1 Trap Shadow Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 73 <BR>
</A>
<A href="#page130">4.7.7.3.2 Trap Shadow Length Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 74 <BR>
</A>
<A href="#page132">4. 7. 7. 4 Invalid Operation (INV) Arithmetic Trap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 76 <BR>
</A>
<A href="#page133">4. 7. 7. 5 Division by Zero (DZE) Arithmetic Trap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 77 <BR>
</A>
<A href="#page133">4. 7. 7. 6 Overflow (OVF) Arithmetic Trap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 77 <BR>
</A>
<A href="#page134">4. 7. 7. 7 Underflow (UNF) Arithmetic Trap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 78 <BR>
</A>
<A href="#page134">4. 7. 7. 8 Inexact Result (INE) Arithmetic Trap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 78 <BR>
</A>
<A href="#page134">4.7.7.9 Integer Overflow (IOV) Arithmetic Trap. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 78 <BR>
</A>
<A href="#page134">4.7.7.10 IEEE Floating-Point Trap Disable Bits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 78 <BR>
</A>
<A href="#page135">4.7.7.11 IEEE Denormal Control Bits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 79 <BR>
</A>
<A href="#page135">4. 7. 8 Floating-Point Control Register (FPCR) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 79 <BR>
</A>
<A href="#page138">4. 7. 8. 1 Accessing the FPCR. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 82 <BR>
</A>
<A href="#page139">4. 7. 8. 2 Default Values of the FPCR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 83 <BR>
</A>
<A href="#page139">4. 7. 8. 3 Saving and Restoring the FPCR. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 83 <BR>
</A>
<A href="#page140">4. 7. 9 Floating-Point Instruction Function Field Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 84 <BR>
</A>
<A href="#page144">4.7.10 IEEE Standard . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 88 <BR>
</A>
<A href="#page144">4. 7. 10. 1 Conversion of NaN and Infinity Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 88 <BR>
</A>
<A href="#page84">4. 7. 10. 2 Copying NaN Values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 89 <BR>
4. 7. 10. 3 Generating NaN Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 89 
5
<BR>
<A href=#page5>5</A>
<strong><A name=page6> Page 6</A></strong>
<A href=#page7>7</A>
<BR>
<P>
</A>
vi <BR>
<A href="#page145">4.7.10.4 Propagating NaN Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 89 <BR>
</A>
<A href="#page146">4. 8 Memory Format Floating-Point Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 90 <BR>
</A>
<A href="#page147">4. 8. 1 Load F_floating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 91 <BR>
</A>
<A href="#page148">4. 8. 2 Load G_floating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 92 <BR>
</A>
<A href="#page149">4. 8. 3 Load S_floating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 93 <BR>
</A>
<A href="#page150">4. 8. 4 Load T_floating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 94 <BR>
</A>
<A href="#page151">4. 8. 5 Store F_floating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 95 <BR>
</A>
<A href="#page152">4. 8. 6 Store G_floating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 96 <BR>
</A>
<A href="#page153">4. 8. 7 Store S_floating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 97 <BR>
</A>
<A href="#page154">4. 8. 8 Store T_floating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 98 <BR>
</A>
<A href="#page155">4. 9 Branch Format Floating-Point Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 99 <BR>
</A>
<A href="#page156">4.9.1 Conditional Branch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 100 <BR>
</A>
<A href="#page158">4. 10 Floating-Point Operate Format Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 102 <BR>
</A>
<A href="#page161">4. 10. 1 Copy Sign . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 105 <BR>
</A>
<A href="#page162">4. 10. 2 Convert Integer to Integer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 106 <BR>
</A>
<A href="#page163">4.10.3 Floating-Point Conditional Move . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 107 <BR>
</A>
<A href="#page165">4. 10. 4 Move from/ to Floating-Point Control Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 109 <BR>
</A>
<A href="#page166">4.10.5 VAX Floating Add . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 110 <BR>
</A>
<A href="#page167">4.10.6 IEEE Floating Add . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 111 <BR>
</A>
<A href="#page168">4.10.7 VAX Floating Compare . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 112 <BR>
</A>
<A href="#page169">4.10.8 IEEE Floating Compare . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 113 <BR>
</A>
<A href="#page170">4.10.9 Convert VAX Floating to Integer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 114 <BR>
</A>
<A href="#page171">4.10.10 Convert Integer to VAX Floating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 115 <BR>
</A>
<A href="#page172">4.10.11 Convert VAX Floating to VAX Floating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 116 <BR>
</A>
<A href="#page173">4.10.12 Convert IEEE Floating to Integer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 117 <BR>
</A>
<A href="#page174">4.10.13 Convert Integer to IEEE Floating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 118 <BR>
</A>
<A href="#page175">4.10.14 Convert IEEE S_Floating to IEEE T_Floating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 119 <BR>
</A>
<A href="#page176">4.10.15 Convert IEEE T_Floating to IEEE S_Floating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 120 <BR>
</A>
<A href="#page177">4.10.16 VAX Floating Divide . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 121 <BR>
</A>
<A href="#page178">4.10.17 IEEE Floating Divide . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 122 <BR>
</A>
<A href="#page179">4.10.18 Floating-Point Register to Integer Register Move . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 123 <BR>
</A>
<A href="#page180">4.10.19 Integer Register to Floating-Point Register Move . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 124 <BR>
</A>
<A href="#page182">4.10.20 VAX Floating Multiply . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 126 <BR>
</A>
<A href="#page183">4.10.21 IEEE Floating Multiply . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 127 <BR>
</A>
<A href="#page184">4.10.22 VAX Floating Square Root . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 128 <BR>
</A>
<A href="#page185">4.10.23 IEEE Floating Square Root . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 129 <BR>
</A>
<A href="#page186">4.10.24 VAX Floating Subtract . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 130 <BR>
</A>
<A href="#page187">4.10.25 IEEE Floating Subtract . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 131 <BR>
</A>
<A href="#page188">4.11 Miscellaneous Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 132 <BR>
</A>
<A href="#page189">4. 11. 1 Architecture Mask . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 133 <BR>
</A>
<A href="#page191">4. 11. 2 Call Privileged Architecture Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 135 <BR>
</A>
<A href="#page192">4. 11. 3 Evict Data Cache Block . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 136 <BR>
</A>
<A href="#page194">4. 11. 4 Exception Barrier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 138 <BR>
</A>
<A href="#page195">4. 11. 5 Prefetch Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 139 <BR>
</A>
<A href="#page197">4. 11. 6 Implementation Version . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 141 <BR>
</A>
<A href="#page198">4. 11. 7 Memory Barrier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 142 <BR>
</A>
<A href="#page199">4. 11. 8 Read Processor Cycle Counter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 143 <BR>
</A>
<A href="#page200">4. 11. 9 Trap Barrier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 144 <BR>
</A>
<A href="#page201">4. 11. 10 Write Hint . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 145 <BR>
</A>
<A href="#page203">4. 11. 11 Write Memory Barrier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 147 <BR>
</A>
<A href="#page205">4.12 VAX Compatibility Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 149 <BR>
</A>
<A href="#page206">4.12.1 VAX Compatibility Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 150 <BR>
</A>
<A href="#page207">4.13 Multimedia (Graphics and Video) Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 151 <BR>
</A>
<A href="#page208">4.13.1 Byte and Word Minimum and Maximum . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 152 <BR>
</A>
<A href="#page210">4. 13. 2 Pixel Error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 154 <BR>
</A>
<A href="#page211">4. 13. 3 Pack Bytes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 155 <BR>
</A>
<A href="#page212">4. 13. 4 Unpack Bytes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 156 
6
<BR>
<A href=#page6>6</A>
<strong><A name=page7> Page 7</A></strong>
<A href=#page8>8</A>
<BR>
<P>
</A>
vii <BR>
<A href="#page213">5 System Architecture and Programming Implications <BR>
</A>
<A href="#page213">5. 1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 1 <BR>
</A>
<A href="#page213">5. 2 Physical Address Space Characteristics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 1 <BR>
</A>
<A href="#page213">5. 2. 1 Coherency of Memory Access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 1 <BR>
</A>
<A href="#page214">5.2.2 Granularity of Memory Access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 2 <BR>
</A>
<A href="#page215">5. 2. 3 Width of Memory Access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 3 <BR>
</A>
<A href="#page215">5.2.4 Memory-Like and Non-Memory-Like Behavior. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 3 <BR>
</A>
<A href="#page216">5.3 Translation Buffers and Virtual Caches. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 4 <BR>
</A>
<A href="#page216">5.4 Caches and Write Buffers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 4 <BR>
</A>
<A href="#page218">5. 5 Data Sharing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 6 <BR>
</A>
<A href="#page218">5.5.1 Atomic Change of a Single Datum. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 6 <BR>
</A>
<A href="#page218">5. 5. 2 Atomic Update of a Single Datum . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 6 <BR>
</A>
<A href="#page219">5. 5. 3 Atomic Update of Data Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 7 <BR>
</A>
<A href="#page221">5. 5. 4 Ordering Considerations for Shared Data Structures . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 9 <BR>
</A>
<A href="#page222">5. 6 Read/ Write Ordering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 10 <BR>
</A>
<A href="#page222">5.6.1 Alpha Shared Memory Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 10 <BR>
</A>
<A href="#page224">5.6.1.1 Architectural Definition of Processor Issue Sequence . . . . . . . . . . . . . . . . . . . . . . 5– 12 <BR>
</A>
<A href="#page224">5. 6. 1. 2 Definition of Before and After . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 12 <BR>
</A>
<A href="#page224">5. 6. 1. 3 Definition of Processor Issue Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 12 <BR>
</A>
<A href="#page226">5. 6. 1. 4 Definition of Location Access Constraints. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 14 <BR>
</A>
<A href="#page226">5. 6. 1. 5 Definition of Visibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 14 <BR>
</A>
<A href="#page226">5. 6. 1. 6 Definition of Storage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 14 <BR>
</A>
<A href="#page227">5.6.1.7 Definition of Dependence Constraint . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 15 <BR>
</A>
<A href="#page228">5.6.1.8 Definition of Load-Locked and Store-Conditional . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 16 <BR>
</A>
<A href="#page229">5. 6. 1. 9 Timeliness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 17 <BR>
</A>
<A href="#page229">5. 6. 2 Litmus Tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 17 <BR>
</A>
<A href="#page229">5.6.2.1 Litmus Test 1 (Impossible Sequence). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 17 <BR>
</A>
<A href="#page230">5.6.2.2 Litmus Test 2 (Impossible Sequence). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 18 <BR>
</A>
<A href="#page230">5.6.2.3 Litmus Test 3 (Impossible Sequence). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 18 <BR>
</A>
<A href="#page231">5.6.2.4 Litmus Test 4 (Sequence Okay) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 19 <BR>
</A>
<A href="#page231">5.6.2.5 Litmus Test 5 (Sequence Okay) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 19 <BR>
</A>
<A href="#page231">5.6.2.6 Litmus Test 6 (Sequence Okay) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 19 <BR>
</A>
<A href="#page232">5.6.2.7 Litmus Test 7 (Impossible Sequence). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 20 <BR>
</A>
<A href="#page232">5.6.2.8 Litmus Test 8 (Impossible Sequence). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 20 <BR>
</A>
<A href="#page233">5.6.2.9 Litmus Test 9 (Impossible Sequence). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 21 <BR>
</A>
<A href="#page233">5.6.2.10 Litmus Test 10 (Sequence Okay) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 21 <BR>
</A>
<A href="#page233">5.6.2.11 Litmus Test 11 (Impossible Sequence). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 21 <BR>
</A>
<A href="#page234">5. 6. 3 Implied Barriers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 22 <BR>
</A>
<A href="#page234">5. 6. 4 Implications for Software . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 22 <BR>
</A>
<A href="#page234">5. 6. 4. 1 Single Processor Data Stream . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 22 <BR>
</A>
<A href="#page234">5. 6. 4. 2 Single Processor Instruction Stream. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 22 <BR>
</A>
<A href="#page234">5.6.4.3 Multiprocessor Data Stream (Including Single Processor with DMA I/ O) . . . . . . . . 5– 22 <BR>
</A>
<A href="#page235">5.6.4.4 Multiprocessor Instruction Stream (Including Single Processor with DMA I/ O) . . . 5– 23 <BR>
</A>
<A href="#page236">5. 6. 4. 5 Multiprocessor Context Switch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 24 <BR>
</A>
<A href="#page238">5. 6. 4. 6 Multiprocessor Send/ Receive Interrupt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 26 <BR>
</A>
<A href="#page239">5.6.4.7 Implications for Memory Mapped I/ O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 27 <BR>
</A>
<A href="#page240">5. 6. 4. 8 Multiple Processors Writing to a Single I/ O Device. . . . . . . . . . . . . . . . . . . . . . . . . 5– 28 <BR>
</A>
<A href="#page241">5. 6. 5 Implications for Hardware . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 29 <BR>
</A>
<A href="#page242">5. 7 Arithmetic Traps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5– 30 <BR>
</A>
<P>
<A href="#page243">6 Common PALcode Architecture <BR>
</A>
<A href="#page243">6. 1 PALcode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6– 1 <BR>
</A>
<A href="#page212">6.2 PALcode Instructions and Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6– 1 <BR>
6.3 PALcode Environment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6– 2 <BR>
</A>
<A href="#page244">6. 4 Special Functions Required for PALcode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6– 2 
7
<BR>
<A href=#page7>7</A>
<strong><A name=page8> Page 8</A></strong>
<A href=#page9>9</A>
<BR>
<P>
</A>
viii <BR>
<A href="#page245">6.5 PALcode Effects on System Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6– 3 <BR>
</A>
<A href="#page245">6.6 PALcode Replacement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6– 3 <BR>
</A>
<A href="#page246">6. 7 Required PALcode Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6– 4 <BR>
</A>
<A href="#page248">6. 7. 1 Drain Aborts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6– 6 <BR>
</A>
<A href="#page249">6. 7. 2 Halt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6– 7 <BR>
</A>
<A href="#page250">6. 7. 3 Instruction Memory Barrier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6– 8 <BR>
</A>
<P>
<A href="#page251">7 Console Subsystem Overview <BR>
</A>
<A href="#page253">8 Input/ Output Overview <BR>
</A>
<A href="#page255">9 OpenVMS Alpha <BR>
</A>
<A href="#page255">9.1 Unprivileged OpenVMS Alpha PALcode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9– 1 <BR>
</A>
<A href="#page262">9.2 Privileged OpenVMS Alpha Palcode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9– 8 <BR>
</A>
<P>
<A href="#page265">10 Digital UNIX <BR>
</A>
<A href="#page265">10. 1 Unprivileged Digital UNIX PALcode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10– 1 <BR>
</A>
<A href="#page266">10. 2 Privileged Digital UNIX PALcode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10– 2 <BR>
</A>
<P>
<A href="#page269">11 Windows NT Alpha <BR>
</A>
<A href="#page269">11. 1 Unprivileged Windows NT Alpha PALcode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11– 1 <BR>
</A>
<A href="#page270">11. 2 Privileged Windows NT Alpha PALcode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11– 2 <BR>
</A>
<P>
<A href="#page275">A Software Considerations <BR>
</A>
<A href="#page275">A. 1 Hardware-Software Compact . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 1 <BR>
</A>
<A href="#page276">A. 2 Instruction-Stream Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 2 <BR>
</A>
<A href="#page276">A. 2. 1 Instruction Alignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 2 <BR>
</A>
<A href="#page276">A. 2.2 Branch Prediction and Minimizing Branch-Taken — Factor of 3 . . . . . . . . . . . . . . . . . . A– 2 <BR>
</A>
<A href="#page278">A. 2. 3 Improving I-Stream Density — Factor of 3. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 4 <BR>
</A>
<A href="#page278">A. 2.4 Instruction Scheduling — Factor of 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 4 <BR>
</A>
<A href="#page278">A. 3 Data-Stream Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 4 <BR>
</A>
<A href="#page278">A. 3. 1 Data Alignment — Factor of 10. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 4 <BR>
</A>
<A href="#page279">A. 3. 2 Shared Data in Multiple Processors — Factor of 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 5 <BR>
</A>
<A href="#page280">A. 3. 3 Avoiding Cache/ TB Conflicts — Factor of 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 6 <BR>
</A>
<A href="#page282">A. 3.4 Sequential Read/ Write — Factor of 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 8 <BR>
</A>
<A href="#page282">A. 3. 5 Prefetching — Factor of 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 8 <BR>
</A>
<A href="#page283">A. 4 Code Sequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 9 <BR>
</A>
<A href="#page283">A. 4.1 Aligned Byte/ Word (Within Register) Memory Accesses . . . . . . . . . . . . . . . . . . . . . . . . A– 9 <BR>
</A>
<A href="#page284">A. 4. 2 Division . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 10 <BR>
</A>
<A href="#page285">A. 4. 3 Byte Swap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 11 <BR>
</A>
<A href="#page285">A. 4. 4 Stylized Code Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 11 <BR>
</A>
<A href="#page285">A. 4. 4. 1 NOP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 11 <BR>
</A>
<A href="#page286">A. 4. 4. 2 Clear a Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 12 <BR>
</A>
<A href="#page286">A. 4.4.3 Load Literal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 12 <BR>
</A>
<A href="#page287">A. 4. 4. 4 Register-to-Register Move . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 13 <BR>
</A>
<A href="#page244">A. 4.4.5 Negate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 13 
8
<BR>
<A href=#page8>8</A>
<strong><A name=page9> Page 9</A></strong>
<A href=#page10>10</A>
<BR>
<P>
</A>
ix <BR>
<A href="#page287">A. 4. 4. 6 NOT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 13 <BR>
</A>
<A href="#page287">A. 4.4.7 Booleans . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 13 <BR>
</A>
<A href="#page288">A. 4.5 Exceptions and Trap Barriers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 14 <BR>
</A>
<A href="#page288">A. 4.6 Pseudo-Operations (Stylized Code Forms) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 14 <BR>
</A>
<A href="#page290">A. 5 Timing Considerations: Atomic Sequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 16 <BR>
</A>
<P>
<A href="#page291">B IEEE Floating-Point Conformance <BR>
</A>
<A href="#page291">B. 1 Alpha Choices for IEEE Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B– 1 <BR>
</A>
<A href="#page293">B. 2 Alpha Support for OS Completion Handlers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B– 3 <BR>
</A>
<A href="#page294">B. 2.1 IEEE Floating-Point Control (FP_C) Quadword . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B– 4 <BR>
</A>
<A href="#page296">B. 3 Mapping to IEEE Standard . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B– 6 <BR>
</A>
<P>
<A href="#page303">C Instruction Summary <BR>
</A>
<A href="#page303">C. 1 Common Architecture Instruction Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C– 1 <BR>
</A>
<A href="#page308">C. 2 IEEE Floating-Point Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C– 6 <BR>
</A>
<A href="#page309">C. 3 VAX Floating-Point Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C– 7 <BR>
</A>
<A href="#page310">C. 4 Independent Floating-Point Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C– 8 <BR>
</A>
<A href="#page310">C. 5 Opcode Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C– 8 <BR>
</A>
<A href="#page312">C. 6 Common Architecture Opcodes in Numerical Order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C– 10 <BR>
</A>
<A href="#page316">C. 7 OpenVMS Alpha PALcode Instruction Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C– 14 <BR>
</A>
<A href="#page318">C. 8 DIGITAL UNIX PALcode Instruction Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C– 16 <BR>
</A>
<A href="#page319">C. 9 Windows NT Alpha Instruction Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C– 17 <BR>
</A>
<A href="#page320">C. 10 PALcode Opcodes in Numerical Order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C– 18 <BR>
</A>
<A href="#page322">C. 11 Required PALcode Opcodes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C– 20 <BR>
</A>
<A href="#page322">C. 12 Opcodes Reserved to PALcode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C– 20 <BR>
</A>
<A href="#page323">C. 13 Opcodes Reserved to Compaq . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C– 21 <BR>
</A>
<A href="#page323">C. 14 Unused Function Code Behavior . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C– 21 <BR>
</A>
<A href="#page324">C. 15 ASCII Character Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C– 22 <BR>
</A>
<P>
<A href="#page325">D Registered System and Processor Identifiers <BR>
</A>
<A href="#page325">D. 1 Processor Type Assignments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D– 1 <BR>
</A>
<A href="#page326">D. 2 PALcode Variation Assignments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D– 2 <BR>
</A>
<A href="#page327">D. 3 Architecture Mask and Implementation Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D– 3 <BR>
</A>
<P>
<A href="#page329">E Waivers and Implementation-Dependent Functionality <BR>
</A>
<A href="#page329">E. 1 Waivers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . E– 1 <BR>
</A>
<A href="#page329">E. 1.1 DECchip 21064, DECchip 21066, and DECchip 21068 IEEE Divide Instruction Violation E– 1 <BR>
</A>
<A href="#page330">E. 1.2 DECchip 21064, DECchip 21066, and DECchip 21068 Write Buffer Violation . . . . . . . E– 2 <BR>
</A>
<A href="#page330">E. 1. 3 DECchip 21264 LDx_L/ STx_C with WH64 Violation . . . . . . . . . . . . . . . . . . . . . . . . . . . E– 2 <BR>
</A>
<A href="#page331">E. 2 Implementation-Specific Functionality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . E– 3 <BR>
</A>
<A href="#page331">E. 2.1 DECchip 21064/ 21066/ 21068 Performance Monitoring . . . . . . . . . . . . . . . . . . . . . . . . E– 3 <BR>
</A>
<A href="#page332">E. 2.1.1 DECchip 21064/ 21066/ 21068 Performance Monitor Interrupt Mechanism . . . . . . E– 4 <BR>
</A>
<A href="#page333">E. 2.1.2 Functions and Arguments for the DECchip 21064/ 21066/ 21068 . . . . . . . . . . . . . . E– 5 <BR>
</A>
<A href="#page287">E. 2.2 DECchip 21164/ 21164PC Performance Monitoring . . . . . . . . . . . . . . . . . . . . . . . . . . . E– 9 <BR>
E. 2.2.1 Performance Monitor Interrupt Mechanism. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . E– 9 
9
<BR>
<A href=#page9>9</A>
<strong><A name=page10> Page 10</A></strong>
<A href=#page11>11</A>
<BR>
<P>
</A>
x <BR>
<A href="#page338">E. 2.2.2 Windows NT Alpha Functions and Argument . . . . . . . . . . . . . . . . . . . . . . . . . . . . . E– 10 <BR>
</A>
<A href="#page340">E. 2.2.3 OpenVMS Alpha and DIGITAL UNIX Functions and Arguments . . . . . . . . . . . . . . E– 12 <BR>
</A>
<A href="#page351">E. 2.3 21264 Performance Monitoring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . E– 23 <BR>
</A>
<A href="#page351">E. 2.3.1 Performance Monitor Interrupt Mechanism. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . E– 23 <BR>
</A>
<A href="#page352">E. 2.3.2 Windows NT Alpha Functions and Argument . . . . . . . . . . . . . . . . . . . . . . . . . . . . . E– 24 <BR>
</A>
<A href="#page353">E. 2.3.3 OpenVMS Alpha and DIGITAL UNIX Functions and Arguments . . . . . . . . . . . . . . E– 25 <BR>
</A>
<P>
<A href="#page359">Index </B>
10
<BR>
<A href=#page10>10</A>
<strong><A name=page11> Page 11</A></strong>
<A href=#page12>12</A>
<BR>
<P>
</A>
xi <BR>
<B>Figures <BR>
<A href="#page20">1– 1 Instruction Format Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1– 4 <BR>
</A>
<A href="#page27">2– 1 Byte Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 1 <BR>
</A>
<A href="#page28">2– 2 Word Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 2 <BR>
</A>
<A href="#page28">2– 3 Longword Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 2 <BR>
</A>
<A href="#page28">2– 4 Quadword Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 2 <BR>
</A>
<A href="#page29">2– 5 F_floating Datum. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 3 <BR>
</A>
<A href="#page29">2– 6 F_floating Register Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 3 <BR>
</A>
<A href="#page30">2– 7 G_floating Datum . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 4 <BR>
</A>
<A href="#page31">2– 8 G_floating Register Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 5 <BR>
</A>
<A href="#page31">2– 9 D_floating Datum. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 5 <BR>
</A>
<A href="#page31">2– 10 D_floating Register Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 5 <BR>
</A>
<A href="#page33">2– 11 S_floating Datum. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 7 <BR>
</A>
<A href="#page33">2– 12 S_floating Register Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 7 <BR>
</A>
<A href="#page34">2– 13 T_floating Datum. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 8 <BR>
</A>
<A href="#page35">2– 14 T_floating Register Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 9 <BR>
</A>
<A href="#page36">2– 15 X_floating Datum. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 10 <BR>
</A>
<A href="#page36">2– 16 X_floating Register Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 10 <BR>
</A>
<A href="#page37">2– 17 X_floating Big-Endian Datum . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 11 <BR>
</A>
<A href="#page37">2– 18 X_floating Big-Endian Register Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 11 <BR>
</A>
<A href="#page37">2– 19 Longword Integer Datum. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 11 <BR>
</A>
<A href="#page37">2– 20 Longword Integer Floating-Register Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 11 <BR>
</A>
<A href="#page38">2– 21 Quadword Integer Datum . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 12 <BR>
</A>
<A href="#page38">2– 22 Quadword Integer Floating-Register Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 12 <BR>
</A>
<A href="#page39">2– 23 Little-Endian Byte Addressing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 13 <BR>
</A>
<A href="#page39">2– 24 Big-Endian Byte Addressing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2– 13 <BR>
</A>
<A href="#page51">3– 1 Memory Instruction Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 11 <BR>
</A>
<A href="#page51">3– 2 Memory Instruction with Function Code Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 11 <BR>
</A>
<A href="#page52">3– 3 Branch Instruction Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 12 <BR>
</A>
<A href="#page52">3– 4 Operate Instruction Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 12 <BR>
</A>
<A href="#page53">3– 5 Floating-Point Operate Instruction Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 13 <BR>
</A>
<A href="#page55">3– 6 PALcode Instruction Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3– 15 <BR>
</A>
<A href="#page136">4– 1 Floating-Point Control Register (FPCR) Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 80 <BR>
</A>
<A href="#page140">4– 2 Floating-Point Instruction Function Field . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 84 <BR>
</A>
<A href="#page253">8– 1 Alpha System Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8– 1 <BR>
</A>
<A href="#page277">A– 1 Branch-Format BSR and BR Opcodes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 3 <BR>
</A>
<A href="#page277">A– 2 Memory-Format JSR Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 3 <BR>
</A>
<A href="#page281">A– 3 Bad Allocation in Cache . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 7 <BR>
</A>
<A href="#page281">A– 4 Better Allocation in Cache . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 7 <BR>
</A>
<A href="#page281">A– 5 Best Allocation in Cache . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A– 7 <BR>
</A>
<A href="#page294">B– 1 IEEE Floating-Point Control (FP_C) Quadword . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B– 4 <BR>
</A>
<A href="#page297">B– 2 IEEE Trap Handling Behavior . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B– 7 
11
<BR>
<A href=#page11>11</A>
<strong><A name=page12> Page 12</A></strong>
<A href=#page13>13</A>
<BR>
<P>
</A>
xii <BR>
<B>Tabl es <BR>
<A href="#page30">2– 1 F_floating Load Exponent Mapping (MAP_F) ................................................................ 2– 4 <BR>
</A>
<A href="#page33">2– 2 S_floating Load Exponent Mapping (MAP_S) ................................................................ 2– 7 <BR>
</A>
<A href="#page44">3– 1 Operand Notation ........................................................................................................... 3– 4 <BR>
</A>
<A href="#page44">3– 2 Operand Value Notation ................................................................................................. 3– 4 <BR>
</A>
<A href="#page44">3– 3 Expression Operand Notation ........................................................................................ 3– 4 <BR>
</A>
<A href="#page45">3– 4 Operand Name Notation ................................................................................................ 3– 5 <BR>
</A>
<A href="#page45">3– 5 Operand Access Type Notation .................................................................................... 3– 5 <BR>
</A>
<A href="#page46">3– 6 Operand Data Type Notation ......................................................................................... 3– 6 <BR>
</A>
<A href="#page46">3– 7 Operators ....................................................................................................................... 3– 6 <BR>
</A>
<A href="#page59">4– 1 Opcode Qualifiers ........................................................................................................... 4– 3 <BR>
</A>
<A href="#page60">4– 2 Memory Integer Load/ Store Instructions ......................................................................... 4– 4 <BR>
</A>
<A href="#page74">4– 3 Control Instructions Summary ...................................................................................... 4– 18 <BR>
</A>
<A href="#page79">4– 4 Jump Instructions Branch Prediction ............................................................................ 4– 23 <BR>
</A>
<A href="#page80">4– 5 Integer Arithmetic Instructions Summary ...................................................................... 4– 24 <BR>
</A>
<A href="#page97">4– 6 Logical and Shift Instructions Summary ........................................................................ 4– 41 <BR>
</A>
<A href="#page103">4– 7 Byte-Within-Register Manipulation Instructions Summary ........................................... 4– 47 <BR>
</A>
<A href="#page127">4– 8 VAX Trapping Modes Summary ................................................................................... 4– 71 <BR>
</A>
<A href="#page128">4– 9 Summary of IEEE Trapping Modes .............................................................................. 4– 72 <BR>
</A>
<A href="#page131">4– 10 Trap Shadow Length Rules .......................................................................................... 4– 75 <BR>
</A>
<A href="#page136">4– 11 Floating-Point Control Register (FPCR) Bit Descriptions ............................................. 4– 80 <BR>
</A>
<A href="#page141">4– 12 IEEE Floating-Point Function Field Bit Summary ......................................................... 4– 85 <BR>
</A>
<A href="#page143">4– 13 VAX Floating-Point Function Field Bit Summary .......................................................... 4– 87 <BR>
</A>
<A href="#page146">4– 14 Memory Format Floating-Point Instructions Summary .................................................. 4– 90 <BR>
</A>
<A href="#page155">4– 15 Floating-Point Branch Instructions Summary ................................................................ 4– 99 <BR>
</A>
<A href="#page158">4– 16 Floating-Point Operate Instructions Summary ........................................................... 4– 102 <BR>
</A>
<A href="#page188">4– 17 Miscellaneous Instructions Summary.......................................................................... 4– 132 <BR>
</A>
<A href="#page205">4– 18 VAX Compatibility Instructions Summary.................................................................... 4– 149 <BR>
</A>
<A href="#page225">5– 1 Processor Issue Constraints ....................................................................................... 5– 13 <BR>
</A>
<A href="#page246">6– 1 PALcode Instructions that Require Recognition.............................................................. 6– 4 <BR>
</A>
<A href="#page247">6– 2 Required PALcode Instructions ....................................................................................... 6– 5 <BR>
</A>
<A href="#page255">9– 1 Unprivileged OpenVMS Alpha PALcode Instruction Summary ..................................... 9– 1 <BR>
</A>
<A href="#page262">9– 2 Privileged OpenVMS Alpha PALcode Instructions Summary ........................................ 9– 8 <BR>
</A>
<A href="#page265">10– 1 Unprivileged Digital UNIX PALcode Instruction Summary .......................................... 10– 1 <BR>
</A>
<A href="#page266">10– 2 Privileged Digital UNIX PALcode Instruction Summary ............................................... 10– 2 <BR>
</A>
<A href="#page269">11– 1 Unprivileged Windows NT Alpha PALcode Instruction Summary ................................ 11– 1 <BR>
</A>
<A href="#page270">11– 2 Privileged Windows NT Alpha PALcode Instruction Summary ..................................... 11– 2 <BR>
</A>
<A href="#page282">A– 1 Cache Block Prefetching ................................................................................................ A– 8 <BR>
</A>
<A href="#page288">A– 2 Decodable Pseudo-Operations (Stylized Code Forms) ............................................... A– 14 <BR>
</A>
<A href="#page295">B– 1 Floating-Point Control (FP_C) Quadword Bit Summary ................................................ B– 5 <BR>
</A>
<A href="#page298">B– 2 IEEE Floating-Point Trap Handling ............................................................................... B– 8 <BR>
</A>
<A href="#page302">B– 3 IEEE Standard Charts ................................................................................................. B– 12 <BR>
</A>
<A href="#page303">C– 1 Instruction Format and Opcode Notation ....................................................................... C– 1 <BR>
</A>
<A href="#page304">C– 2 Common Architecture Instructions ................................................................................ C– 2 <BR>
</A>
<A href="#page308">C– 3 IEEE Floating-Point Instruction Function Codes ........................................................... C– 6 <BR>
</A>
<A href="#page309">C– 4 VAX Floating-Point Instruction Function Codes ............................................................ C– 7 <BR>
</A>
<A href="#page310">C– 5 Independent Floating-Point Instruction Function Codes ............................................... C– 8 <BR>
</A>
<A href="#page311">C– 6 Opcode Summary ......................................................................................................... C– 9 <BR>
</A>
<A href="#page311">C– 7 Key to Opcode Summary ............................................................................................... C– 9 <BR>
</A>
<A href="#page312">C– 8 Common Architecture Opcodes in Numerical Order ................................................... C– 10 <BR>
</A>
<A href="#page316">C– 9 OpenVMS Alpha Unprivileged PALcode Instructions .................................................. C– 14 <BR>
</A>
<A href="#page317">C– 10 OpenVMS Alpha Privileged PALcode Instructions ...................................................... C– 15 <BR>
</A>
<A href="#page318">C– 11 DIGITAL UNIX Unprivileged PALcode Instructions ..................................................... C– 16 <BR>
</A>
<A href="#page318">C– 12 DIGITAL UNIX Privileged PALcode Instructions ......................................................... C– 16 <BR>
</A>
<A href="#page319">C– 13 Windows NT Alpha Unprivileged PALcode Instructions ............................................. C– 17 <BR>
</A>
<A href="#page319">C– 14 Windows NT Alpha Privileged PALcode instructions .................................................. C– 17 
12
<BR>
<A href=#page12>12</A>
<strong><A name=page13> Page 13</A></strong>
<A href=#page14>14</A>
<BR>
<P>
</A>
xiii <BR>
<A href="#page320">C– 15 PALcode Opcodes in Numerical Order ....................................................................... C– 18 <BR>
</A>
<A href="#page322">C– 16 Required PALcode Opcodes........................................................................................ C– 20 <BR>
</A>
<A href="#page322">C– 17 Opcodes Reserved for PALcode.................................................................................. C– 20 <BR>
</A>
<A href="#page323">C– 18 Opcodes Reserved for Compaq................................................................................... C– 21 <BR>
</A>
<A href="#page324">C– 19 ASCII Character Set ..................................................................................................... C– 22 <BR>
</A>
<A href="#page325">D– 1 Processor Type Assignments ........................................................................................ D– 1 <BR>
</A>
<A href="#page326">D– 2 PALcode Variation Assignments .................................................................................... D– 2 <BR>
</A>
<A href="#page327">D– 3 AMASK Bit Assignments ............................................................................................... D– 3 <BR>
</A>
<A href="#page327">D– 4 IMPLVER Value Assignments ....................................................................................... D– 3 <BR>
</A>
<A href="#page333">E– 1 DECchip 21064/ 21066/ 21068 Performance Monitoring Functions ............................ E– 5 <BR>
</A>
<A href="#page335">E– 2 DECchip 21064/ 21066/ 21068 MUX Control Fields in ICCSR Register ......................... E– 7 <BR>
</A>
<A href="#page339">E– 3 Bit Summary of PMCTR Register for Windows NT Alpha .......................................... E– 11 <BR>
</A>
<A href="#page340">E– 4 OpenVMS Alpha and DIGITAL UNIX Performance Monitoring Functions .................. E– 12 <BR>
</A>
<A href="#page343">E– 5 21164/ 21164PC Enable Counters for OpenVMS Alpha and DIGITAL UNIX............... E– 15 <BR>
</A>
<A href="#page343">E– 6 21164/ 21164PC Disable Counters for OpenVMS Alpha and DIGITAL UNIX ............. E– 15 <BR>
</A>
<A href="#page344">E– 7 21164 Select Desired Events for OpenVMS Alpha and DIGITAL UNIX ..................... E– 16 <BR>
</A>
<A href="#page344">E– 8 21164PC Select Desired Events for OpenVMS Alpha and DIGITAL UNIX ............. E– 16 <BR>
</A>
<A href="#page345">E– 9 21164/ 21164PC Select Special Options for OpenVMS Alpha and DIGITAL UNIX...... E– 17 <BR>
</A>
<A href="#page346">E– 10 21164/ 21164PC Select Desired Frequencies for OpenVMS Alpha and DIGITAL UNIX E– 18 <BR>
</A>
<A href="#page347">E– 11 21164/ 21164PC Read Counters for OpenVMS Alpha and DIGITAL UNIX ................. E– 19 <BR>
</A>
<A href="#page347">E– 12 21164/ 21164PC Write Counters for OpenVMS Alpha and DIGITAL UNIX ................. E– 19 <BR>
</A>
<A href="#page347">E– 13 21164/ 21164PC Counter 1 (PCSEL1) Event Selection .............................................. E– 19 <BR>
</A>
<A href="#page348">E– 14 21164/ 21164PC Counter 2 (PCSEL2) Event Selection .............................................. E– 20 <BR>
</A>
<A href="#page349">E– 15 21164 CBOX1 Event Selection ................................................................................... E– 21 <BR>
</A>
<A href="#page349">E– 16 21164 CBOX2 Event Selection ................................................................................... E– 21 <BR>
</A>
<A href="#page350">E– 17 21164PC PM0_MUX Event Selection ......................................................................... E– 22 <BR>
</A>
<A href="#page350">E– 18 21164PC PM1_MUX Event Selection ......................................................................... E– 22 <BR>
</A>
<A href="#page352">E– 19 Bit Summary of PCTR_CTL Register for Windows NT Alpha .................................... E– 24 <BR>
</A>
<A href="#page353">E– 20 OpenVMS Alpha and DIGITAL UNIX Performance Monitoring Functions ................... E– 25 <BR>
</A>
<A href="#page355">E– 21 21264 Enable Counters for OpenVMS Alpha and DIGITAL UNIX............................... E– 27 <BR>
</A>
<A href="#page355">E– 22 21264 Disable Counters for OpenVMS Alpha and DIGITAL UNIX ............................. E– 27 <BR>
</A>
<A href="#page356">E– 23 21264 Select Desired Events for OpenVMS Alpha and DIGITAL UNIX ..................... E– 28 <BR>
</A>
<A href="#page356">E– 24 21264 Read Counters for OpenVMS Alpha and DIGITAL UNIX ................................. E– 28 <BR>
</A>
<A href="#page356">E– 25 21264 Write Counters for OpenVMS Alpha and DIGITAL UNIX ................................. E– 28 <BR>
</A>
<A href="#page357">E– 26 21264 Enable and Write Counters for OpenVMS Alpha and DIGITAL UNIX............... E– 29 
13
<BR>
<A href=#page13>13</A>
<strong><A name=page14> Page 14</A></strong>
<A href=#page15>15</A>
<BR>
</A>
xiv 
14
<BR>
<A href=#page14>14</A>
<strong><A name=page15> Page 15</A></strong>
<A href=#page16>16</A>
<BR>
xv <BR>
<B>Preface <BR>
</B>Chapters 1 through 8 and appendixes A through E of this book are directly derived from the <I>Alpha Sys-tem <BR>
Reference Manual, Version 7 </I>and passed engineering change orders (ECOs) that have been <BR>
applied. It is an accurate representation of the described parts of the Alpha architecture. <BR>
<P>
References in this handbook to the <I>Alpha Architecture Reference Manual </I>are to the Third Edition of <BR>
that manual, EY-W938E-DP. 
15
<BR>
<A href=#page15>15</A>
<strong><A name=page16> Page 16</A></strong>
<A href=#page17>17</A>
<BR>

16
<BR>
<A href=#page16>16</A>
<strong><A name=page17> Page 17</A></strong>
<A href=#page18>18</A>
<BR>
Introduction <B>1– 1 <BR>
Chapter 1 <BR>
Introduction <BR>
</B><P>
Alpha is a 64-bit load/ store RISC architecture that is designed with particular emphasis on the <BR>
three elements that most affect performance: clock speed, multiple instruction issue, and multi-ple <BR>
processors. <BR>
<P>
The Alpha architects examined and analyzed current and theoretical RISC architecture design <BR>
elements and developed high-performance alternatives for the Alpha architecture. The archi-tects <BR>
adopted only those design elements that appeared valuable for a projected 25-year design <BR>
horizon. Thus, Alpha becomes the first 21st century computer architecture. <BR>
<P>
The Alpha architecture is designed to avoid bias toward any particular operating system or pro-gramming <BR>
language. Alpha supports the OpenVMS Alpha, DIGITAL UNIX, and Windows NT <BR>
Alpha operating systems and supports simple software migration for applications that run on <BR>
those operating systems. <BR>
<P>
This manual describes in detail how Alpha is designed to be the leadership 64-bit architecture <BR>
of the computer industry. <BR>
<P>
<B>1.1 The Alpha Approach to RISC Architecture <BR>
Alpha Is a True 64-Bit Architecture <BR>
</B>Alpha was designed as a 64-bit architecture. All registers are 64 bits in length and all opera-tions <BR>
are performed between 64-bit registers. It is not a 32-bit architecture that was later <BR>
expanded to 64 bits. <BR>
<P>
<B>Alpha Is Designed for Very High-Speed Implementations <BR>
</B>The instructions are very simple. All instructions are 32 bits in length. Memory operations are <BR>
either loads or stores. All data manipulation is done between registers. <BR>
<P>
The Alpha architecture facilitates pipelining multiple instances of the same operations because <BR>
there are no special registers and no condition codes. <BR>
<P>
The instructions interact with each other only by one instruction writing a register or memory <BR>
and another instruction reading from the same place. That makes it particularly easy to build <BR>
implementations that issue multiple instructions every CPU cycle. 
17
<BR>
<A href=#page17>17</A>
<strong><A name=page18> Page 18</A></strong>
<A href=#page19>19</A>
<BR>
<B>1– 2 </B>Alpha Architecture Handbook <BR>
Alpha makes it easy to maintain binary compatibility across multiple implementations and easy <BR>
to maintain full speed on multiple-issue implementations. For example, there are no implemen-tation-<BR>
specific pipeline timing hazards, no load-delay slots, and no branch-delay slots. <BR>
<P>
<B>The Alpha Approach to Byte Manipulation <BR>
</B>The Alpha architecture reads and writes bytes between registers and memory with the LDBU <BR>
and STB instructions. (Alpha also supports word read/ writes with the LDWU and STW <BR>
instructions.) <BR>
<P>
Byte shifting and masking is performed with normal 64-bit register-to-register instructions, <BR>
crafted to keep instruction sequences short. <BR>
<P>
<B>The Alpha Approach to Multiprocessor Shared Memory <BR>
</B>As viewed from a second processor (including an I/ O device), a sequence of reads and writes <BR>
issued by one processor may be arbitrarily reordered by an implementation. This allows imple-mentations <BR>
to use multibank caches, bypassed write buffers, write merging, pipelined writes <BR>
with retry on error, and so forth. If strict ordering between two accesses must be maintained, <BR>
explicit memory barrier instructions can be inserted in the program. <BR>
<P>
The basic multiprocessor interlocking primitive is a RISC-style load_ locked, modify, <BR>
store_ conditional sequence. If the sequence runs without interrupt, exception, or an interfering <BR>
write from another processor, then the conditional store succeeds. Otherwise, the store fails and <BR>
the program eventually must branch back and retry the sequence. This style of interlocking <BR>
scales well with very fast caches and makes Alpha an especially attractive architecture for <BR>
building multiple-processor systems. <BR>
<P>
<B>Alpha Instructions Include Hints for Achieving Higher Speed <BR>
</B>A number of Alpha instructions include hints for implementations, all aimed at achieving <BR>
higher speed. <BR>
<P>
<B>° </B>Calculated jump instructions have a target hint that can allow much faster subroutine calls and returns. <BR>
<P>
<B>° </B>There are prefetching hints for the memory system that can allow much higher cache hit rates. <BR>
<B>° </B>There are granularity hints for the virtual-address mapping that can allow much more effective use of translation lookaside buffers for large contiguous structures. <BR>
<P>
<B>PALcode – Alpha's Very Flexible Privileged Software Library <BR>
</B>A Privileged Architecture Library (PALcode) is a set of subroutines that are specific to a par-ticular <BR>
Alpha operating system implementation. These subroutines provide operating-system <BR>
primitives for context switching, interrupts, exceptions, and memory management. PALcode is <BR>
similar to the BIOS libraries that are provided in personal computers. <BR>
<P>
PALcode subroutines are invoked by implementation hardware or by software CALL_ PAL <BR>
instructions. 
18
<BR>
<A href=#page18>18</A>
<strong><A name=page19> Page 19</A></strong>
<A href=#page20>20</A>
<BR>
Introduction <B>1– 3 <BR>
</B>PALcode is written in standard machine code with some implementation-specific extensions to <BR>
provide access to low-level hardware. <BR>
<P>
PALcode lets Alpha implementations run the full OpenVMS Alpha, DIGITAL UNIX, and <BR>
Windows NT Alpha operating systems. PALcode can provide this functionality with little <BR>
overhead. For example, the OpenVMS Alpha PALcode instructions let Alpha run OpenVMS <BR>
with little more hardware than that found on a conventional RISC machine: the PAL mode bit <BR>
itself, plus four extra protection bits in each translation buffer entry. <BR>
<P>
Other versions of PALcode can be developed for real-time, teaching, and other applications. <BR>
PALcode makes Alpha an especially attractive architecture for multiple operating systems. <BR>
<P>
<B>Alpha and Programming Languages <BR>
</B>Alpha is an attractive architecture for compiling a large variety of programming languages. <BR>
Alpha has been carefully designed to avoid bias toward one or two programming languages. <BR>
For example: <BR>
<P>
<B>° </B>Alpha does not contain a subroutine call instruction that moves a register window by a fixed amount. Thus, Alpha is a good match for programming languages with many <BR>
<P>
parameters and programming languages with no parameters. <BR>
<B>° </B>Alpha does not contain a global integer overflow enable bit. Such a bit would need to be changed at every subroutine boundary when a FORTRAN program calls a C pro-gram. <BR>
<P>
<B>1.2 Data Format Overview <BR>
</B>Alpha is a load/ store RISC architecture with the following data characteristics: <BR>
<B>° </B>All operations are done between 64-bit registers. <BR>
<B>° </B>Memory is accessed via 64-bit virtual byte addresses, using the little-endian or, option-ally, the big-endian byte numbering convention. <BR>
<P>
<B>° </B>There are 32 integer registers and 32 floating-point registers. <BR>
<B>° </B>Longword (32-bit) and quadword (64-bit) integers are supported. <BR>
<B>° </B>Five floating-point data types are supported: <BR>
– VAX F_ floating (32-bit) <BR>
– VAX G_ floating (64-bit) <BR>
– IEEE single (32-bit) <BR>
– IEEE double (64-bit) <BR>
– IEEE extended (128-bit) 
19
<BR>
<A href=#page19>19</A>
<strong><A name=page20> Page 20</A></strong>
<A href=#page21>21</A>
<BR>
<P>
<B>1– 4 </B>Alpha Architecture Handbook <BR>
<B>1.3 Instruction Format Overview <BR>
</B>As shown in <A href="#page20">Figure 1– 1, </A>
Alpha instructions are all 32 bits in length. There are four major <BR>
instruction format classes that contain 0, 1, 2, or 3 register fields. All formats have a 6-bit <BR>
opcode. <BR>
<P>
<B>Figure 1– 1: Instruction Format Overview <BR>
</B><P>
<B>° PALcode instructions </B>specify, in the function code field, one of a few dozen complex operations to be performed. <BR>
<B>° Conditional branch instructions </B>test register Ra and specify a signed 21-bit PC-rela-tive longword target displacement. Subroutine calls put the return address in register <BR>
Ra. <BR>
<B>° Load and store instructions </B>move bytes, words, longwords, or quadwords between register Ra and memory, using Rb plus a signed 16-bit displacement as the memory <BR>
<P>
address. <BR>
<B>° Operate instructions </B>for floating-point and integer operations are both represented in <A href="#page20">Figure 1– 1 </A>
by the operate format illustration and are as follows: <BR>
<P>
– Word and byte sign-extension operators. <BR>
– Floating-point operations use Ra and Rb as source registers and write the result in <BR>
register Rc. There is an 11-bit extended opcode in the function field. <BR>
<P>
– Integer operations use Ra and Rb or an 8-bit literal as the source operand, and write <BR>
the result in register Rc. <BR>
<P>
– Integer operate instructions can use the Rb field and part of the function field to <BR>
specify an 8-bit literal. There is a 7-bit extended opcode in the function field. <BR>
<P>
<B>1. 4 Instruction Overview <BR>
PALcode Instructions <BR>
</B>As described in <A href="#page17">Section 1. 1, </A>
a Privileged Architecture Library (PALcode) is a set of subrou-tines <BR>
that is specific to a particular Alpha operating-system implementation. These subroutines <BR>
can be invoked by hardware or by software CALL_ PAL instructions, which use the function <BR>
field to vector to the specified subroutine. <BR>
<P>
0 31 26 25 21 20 16 15 5 4 <BR>
Number Opcode <BR>
<P>
Opcode <BR>
Opcode <BR>
Opcode <BR>
<P>
Disp <BR>
Disp <BR>
Function RC RB <BR>
RB <BR>
RA <BR>
RA <BR>
RA <BR>
PALcode Format <BR>
Branch Format <BR>
Memory Format <BR>
Operate Format 
20
<BR>
<A href=#page20>20</A>
<strong><A name=page21> Page 21</A></strong>
<A href=#page22>22</A>
<BR>
Introduction <B>1– 5 <BR>
Branch Instructions <BR>
</B>Conditional branch instructions can test a register for positive/ negative or for zero/ nonzero, <BR>
and they can test integer registers for even/ odd. Unconditional branch instructions can write a <BR>
return address into a register. <BR>
<P>
There is also a calculated jump instruction that branches to an arbitrary 64-bit address in a <BR>
register. <BR>
<P>
<B>Load/ Store Instructions <BR>
</B>Load and store instructions move 8-bit, 16-bit, 32-bit, or 64-bit aligned quantities from and to <BR>
memory. Memory addresses are flat 64-bit virtual addresses with no segmentation. <BR>
<P>
The VAX floating-point load/ store instructions swap words to give a consistent register format <BR>
for floating-point operations. <BR>
<P>
A 32-bit integer datum is placed in a register in a canonical form that makes 33 copies of the <BR>
high bit of the datum. A 32-bit floating-point datum is placed in a register in a canonical form <BR>
that extends the exponent by 3 bits and extends the fraction with 29 low-order zeros. The 32-bit <BR>
operates preserve these canonical forms. <BR>
<P>
Compilers, as directed by user declarations, can generate any mixture of 32-bit and 64-bit oper-ations. <BR>
The Alpha architecture has no 32/ 64 mode bit. <BR>
<P>
<B>Integer Operate Instructions <BR>
</B>The integer operate instructions manipulate full 64-bit values and include the usual assortment <BR>
of arithmetic, compare, logical, and shift instructions. <BR>
<P>
There are just three 32-bit integer operates: add, subtract, and multiply. They differ from their <BR>
64-bit counterparts only in overflow detection and in producing 32-bit canonical results. <BR>
<P>
There is no integer divide instruction. <BR>
The Alpha architecture also supports the following additional operations: <BR>
<B>° </B>Scaled add/ subtract instructions for quick subscript calculation <BR>
<B>° </B>128-bit multiply for division by a constant, and multiprecision arithmetic <BR>
<B>° </B>Conditional move instructions for avoiding branch instructions <BR>
<B>° </B>An extensive set of in-register byte and word manipulation instructions <BR>
<B>° </B>A set of multimedia instructions that support graphics and video <BR>
Integer overflow trap enable is encoded in the function field of each instruction, rather than <BR>
kept in a global state bit. Thus, for example, both ADDQ/ V and ADDQ opcodes exist for spec-ifying <BR>
64-bit ADD with and without overflow checking. That makes it easier to pipeline <BR>
implementations. 
21
<BR>
<A href=#page21>21</A>
<strong><A name=page22> Page 22</A></strong>
<A href=#page23>23</A>
<BR>
<B>1– 6 </B>Alpha Architecture Handbook <BR>
<B>Floating-Point Operate Instructions <BR>
</B>The floating-point operate instructions include four complete sets of VAX and IEEE arith-metic <BR>
instructions, plus instructions for performing conversions between floating-point and <BR>
integer quantities. <BR>
<P>
In addition to the operations found in conventional RISC architectures, Alpha includes condi-tional <BR>
move instructions for avoiding branches and merge sign/ exponent instructions for simple <BR>
field manipulation. <BR>
<P>
The arithmetic trap enables and rounding mode are encoded in the function field of each <BR>
instruction, rather than kept in global state bits. That makes it easier to pipeline <BR>
implementations. <BR>
<P>
<B>1. 5 Instruction Set Characteristics <BR>
</B>Alpha instruction set characteristics are as follows: <BR>
<B>° </B>All instructions are 32 bits long and have a regular format. <BR>
<B>° </B>There are 32 integer registers (R0 through R31), each 64 bits wide. R31 reads as zero, and writes to R31 are ignored. <BR>
<P>
<B>° </B>All integer data manipulation is between integer registers, with up to two variable regis-ter source operands (one may be an 8-bit literal) and one register destination operand. <BR>
<B>° </B>There are 32 floating-point registers (F0 through F31), each 64 bits wide. F31 reads as zero, and writes to F31 are ignored. <BR>
<B>° </B>All floating-point data manipulation is between floating-point registers, with up to two register source operands and one register destination operand. <BR>
<B>° </B>Instructions can move data in an integer register file to a floating-point register file, and data in a floating-point register file to an integer register file. The instructions do not <BR>
interpret bits in the register files and do not access memory. <BR>
<B>° </B>All memory reference instructions are of the load/ store type that moves data between registers and memory. <BR>
<P>
<B>° </B>There are no branch condition codes. Branch instructions test an integer or floating-point register value, which may be the result of a previous compare. <BR>
<B>° </B>Integer and logical instructions operate on quadwords. <BR>
<B>° </B>Floating-point instructions operate on G_ floating, F_ floating, and IEEE extended, dou-ble, and single operands. D_ floating "format compatibility," in which binary files of <BR>
<P>
D_ floating numbers may be processed, but without the last 3 bits of fraction precision, <BR>
is also provided. <BR>
<P>
<B>° </B>A minimal number of VAX compatibility instructions are included. <BR>
<P>
<B>1. 6 Terminology and Conventions <BR>
</B>The following sections describe the terminology and conventions used in this book. 
22
<BR>
<A href=#page22>22</A>
<strong><A name=page23> Page 23</A></strong>
<A href=#page24>24</A>
<BR>
Introduction <B>1– 7 <BR>
1.6. 1 Numbering <BR>
</B>All numbers are decimal unless otherwise indicated. Where there is ambiguity, numbers other <BR>
than decimal are indicated with the name of the base in subscript form, for example, 10 16. <BR>
<P>
<B>1.6. 2 Security Holes <BR>
</B>A security hole is an error of commission, omission, or oversight in a system that allows pro-tection <BR>
mechanisms to be bypassed. <BR>
<P>
Security holes exist when unprivileged software (software running outside of kernel mode) <BR>
can: <BR>
<P>
<B>° </B>Affect the operation of another process without authorization from the operating sys-tem; <BR>
<P>
<B>° </B>Amplify its privilege without authorization from the operating system; or <BR>
<B>° </B>Communicate with another process, either overtly or covertly, without authorization from the operating system. <BR>
<P>
The Alpha architecture has been designed to contain no architectural security holes. Hardware <BR>
(processors, buses, controllers, and so on) and software should likewise be designed to avoid <BR>
security holes. <BR>
<P>
<B>1.6. 3 UNPREDICTABLE and UNDEFINED <BR>
</B>The terms UNPREDICTABLE and UNDEFINED are used throughout this book. Their mean-ings <BR>
are quite different and must be carefully distinguished. <BR>
<P>
In particular, only privileged software (software running in kernel mode) can trigger UNDE-FINED <BR>
operations. Unprivileged software cannot trigger UNDEFINED operations. However, <BR>
either privileged or unprivileged software can trigger UNPREDICTABLE results or <BR>
occurrences. <BR>
<P>
UNPREDICTABLE results or occurrences do not disrupt the basic operation of the processor; <BR>
it continues to execute instructions in its normal manner. In contrast, UNDEFINED operation <BR>
can halt the processor or cause it to lose information. <BR>
<P>
The terms UNPREDICTABLE and UNDEFINED can be further described as follows: <BR>
<P>
<B>UNPREDICTABLE <BR>
° </B>Results or occurrences specified as UNPREDICTABLE may vary from moment to moment, implementation to implementation, and instruction to instruction within <BR>
<P>
implementations. Software can never depend on results specified as UNPREDICT-ABLE. <BR>
<P>
<B>° </B>An UNPREDICTABLE result may acquire an arbitrary value subject to a few con-straints. Such a result may be an arbitrary function of the input operands or of any state <BR>
information that is accessible to the process in its current access mode. UNPREDICT-ABLE <BR>
results may be unchanged from their previous values. 
23
<BR>
<A href=#page23>23</A>
<strong><A name=page24> Page 24</A></strong>
<A href=#page25>25</A>
<BR>
<B>1– 8 </B>Alpha Architecture Handbook <BR>
Operations that produce UNPREDICTABLE results may also produce exceptions. <BR>
<B>° </B>An occurrence specified as UNPREDICTABLE may happen or not based on an arbi-trary choice function. The choice function is subject to the same constraints as are <BR>
<P>
UNPREDICTABLE results and, in particular, must not constitute a security hole. <BR>
Specifically, UNPREDICTABLE results must not depend upon, or be a function of, <BR>
the contents of memory locations or registers that are inaccessible to the current <BR>
process in the current access mode. <BR>
<P>
Also, operations that may produce UNPREDICTABLE results must not: <BR>
– Write or modify the contents of memory locations or registers to which the current <BR>
process in the current access mode does not have access, or <BR>
<P>
– Halt or hang the system or any of its components. <BR>
For example, a security hole would exist if some UNPREDICTABLE result depended <BR>
on the value of a register in another process, on the contents of processor temporary <BR>
registers left behind by some previously running process, or on a sequence of actions <BR>
of different processes. <BR>
<P>
<B>UNDEFINED <BR>
° </B>Operations specified as UNDEFINED may vary from moment to moment, implementa-tion to implementation, and instruction to instruction within implementations. The <BR>
<P>
operation may vary in effect from nothing to stopping system operation. <BR>
<B>° </B>UNDEFINED operations may halt the processor or cause it to lose information. How-ever, UNDEFINED operations must not cause the processor to hang, that is, reach an <BR>
<P>
unhalted state from which there is no transition to a normal state in which the machine <BR>
executes instructions. <BR>
<P>
<B>1.6. 4 Ranges and Extents <BR>
</B>Ranges are specified by a pair of numbers separated by two periods and are inclusive. For <BR>
example, a range of integers 0.. 4 includes the integers 0, 1, 2, 3, and 4. <BR>
<P>
Extents are specified by a pair of numbers in angle brackets separated by a colon and are inclu-sive. <BR>
For example, bits &lt;7: 3&gt; specify an extent of bits including bits 7, 6, 5, 4, and 3. <BR>
<P>
<B>1.6. 5 ALIGNED and UNALIGNED <BR>
</B>In this document the terms ALIGNED and NATURALLY ALIGNED are used interchange-ably <BR>
to refer to data objects that are powers of two in size. An aligned datum of size 2** N is <BR>
stored in memory at a byte address that is a multiple of 2** N, that is, one that has N low-order <BR>
zeros. Thus, an aligned 64-byte stack frame has a memory address that is a multiple of 64. <BR>
<P>
If a datum of size 2** N is stored at a byte address that is not a multiple of 2** N, it is called <BR>
UNALIGNED. 
24
<BR>
<A href=#page24>24</A>
<strong><A name=page25> Page 25</A></strong>
<A href=#page26>26</A>
<BR>
<P>
Introduction <B>1– 9 <BR>
1.6. 6 Must Be Zero (MBZ) <BR>
</B>Fields specified as Must be Zero (MBZ) must never be filled by software with a non-zero <BR>
value. These fields may be used at some future time. If the processor encounters a non-zero <BR>
value in a field specified as MBZ, an Illegal Operand exception occurs. <BR>
<P>
<B>1.6. 7 Read As Zero (RAZ) <BR>
</B>Fields specified as Read as Zero (RAZ) return a zero when read. <BR>
<P>
<B>1.6. 8 Should Be Zero (SBZ) <BR>
</B>Fields specified as Should be Zero (SBZ) should be filled by software with a zero value. Non-zero <BR>
values in SBZ fields produce UNPREDICTABLE results and may produce extraneous <BR>
instruction-issue delays. <BR>
<P>
<B>1.6. 9 Ignore (IGN) <BR>
</B>Fields specified as Ignore (IGN) are ignored when written. <BR>
<P>
<B>1.6. 10 Implementation Dependent (IMP) <BR>
</B>Fields specified as Implementation Dependent (IMP) may be used for implementation-specific <BR>
purposes. Each implementation must document fully the behavior of all fields marked as IMP <BR>
by the Alpha specification. <BR>
<P>
<B>1.6. 11 Illustration Conventions <BR>
</B>Illustrations that depict registers or memory follow the convention that increasing addresses <BR>
run right to left and top to bottom. <BR>
<P>
<B>1.6. 12 Macro Code Example Conventions <BR>
</B>All instructions in macro code examples are either listed in <A href="#page57">Chapter 4 </A>
or are stylized code <BR>
forms found in <A href="#page288">Section A. 4. 6. 
25
<BR>
<A href=#page25>25</A>
<strong><A name=page26> Page 26</A></strong>
<A href=#page27>27</A>
<BR>

26
<BR>
<A href=#page26>26</A>
<strong><A name=page27> Page 27</A></strong>
<A href=#page28>28</A>
<BR>
<P>
</A>
Basic Architecture <B>2– 1 <BR>
Chapter 2 <BR>
Basic Architecture <BR>
</B><P>
<B>2.1 Addressing <BR>
</B>The basic addressable unit in the Alpha architecture is the 8-bit byte. Virtual addresses are 64 <BR>
bits long. An implementation may support a smaller virtual address space. The minimum vir-tual <BR>
address size is 43 bits. <BR>
<P>
Virtual addresses as seen by the program are translated into physical memory addresses by the <BR>
memory management mechanism. <BR>
<P>
Although the data types in <A href="#page27">Section 2.2 </A>
are described in terms of little-endian byte addressing, <BR>
implementations may also include big-endian addressing support, as described in <A href="#page39">Section 2. 3. <BR>
</A>
All current implementations have some big-endian support. <BR>
<P>
<B>2.2 Data Types <BR>
</B>Following are descriptions of the Alpha architecture data types. <BR>
<P>
<B>2. 2.1 Byte <BR>
</B>A byte is 8 contiguous bits starting on an addressable byte boundary. The bits are numbered <BR>
from right to left, 0 through 7, as shown <A href="#page27">in Figure 2– </A>
1. <BR>
<P>
<B>Figure 2– 1: Byte Format <BR>
</B><P>
A byte is specified by its address A. A byte is an 8-bit value. The byte is only supported in <BR>
Alpha by the load, store, sign-extend, extract, mask, insert, and zap instructions. <BR>
<P>
<B>2.2. 2 Word <BR>
</B>A word is 2 contiguous bytes starting on an arbitrary byte boundary. The bits are numbered <BR>
from right to left, 0 through 15, as shown <A href="#page28">in Figure 2– </A>
2. <BR>
<P>
7 0 <BR>
:A 
27
<BR>
<A href=#page27>27</A>
<strong><A name=page28> Page 28</A></strong>
<A href=#page29>29</A>
<BR>
<P>
<B>2– 2 </B>Alpha Architecture Handbook <BR>
<B>Figure 2– 2: Word Format <BR>
</B>A word is specified by its address, the address of the byte containing bit 0. <BR>
A word is a 16-bit value. The word is only supported in Alpha by the load, store, sign-extend, <BR>
extract, mask, and insert instructions. <BR>
<P>
<B>2.2. 3 Longword <BR>
</B>A longword is 4 contiguous bytes starting on an arbitrary byte boundary. The bits are num-bered <BR>
from right to left, 0 through 31, as shown <A href="#page28">in Figure 2– </A>
3. <BR>
<P>
<B>Figure 2– 3: Longword Format <BR>
</B><P>
A longword is specified by its address A, the address of the byte containing bit 0. A longword <BR>
is a 32-bit value. <BR>
<P>
When interpreted arithmetically, a longword is a two's-complement integer with bits of <BR>
increasing significance from 0 through 30. Bit 31 is the sign bit. The longword is only sup-ported <BR>
in Alpha by sign-extended load and store instructions and by longword arithmetic <BR>
instructions. <BR>
<P>
<B>Note: <BR>
</B>Alpha implementations will impose a significant performance penalty when accessing <BR>
longword operands that are not naturally aligned. (A naturally aligned longword has zero <BR>
as the low-order two bits of its address.) <BR>
<P>
<B>2.2. 4 Quadword <BR>
</B>A quadword is 8 contiguous bytes starting on an arbitrary byte boundary. The bits are num-bered <BR>
from right to left, 0 through 63, as shown <A href="#page28">in Figure 2– </A>
4. <BR>
<P>
<B>Figure 2– 4: Quadword Format <BR>
</B><P>
0 15 <BR>
:A <BR>
<P>
0 31 <BR>
:A <BR>
<P>
63 0 <BR>
:A 
28
<BR>
<A href=#page28>28</A>
<strong><A name=page29> Page 29</A></strong>
<A href=#page30>30</A>
<BR>
<P>
Basic Architecture <B>2– 3 <BR>
</B>A quadword is specified by its address A, the address of the byte containing bit 0. A quadword <BR>
is a 64-bit value. When interpreted arithmetically, a quadword is either a two's-complement <BR>
integer with bits of increasing significance from 0 through 62 and bit 63 as the sign bit, or an <BR>
unsigned integer with bits of increasing significance from 0 through 63. <BR>
<P>
<B>Note: <BR>
</B>Alpha implementations will impose a significant performance penalty when accessing <BR>
quadword operands that are not naturally aligned. (A naturally aligned quadword has zero <BR>
as the low-order three bits of its address.) <BR>
<P>
<B>2.2. 5 VAX Floating-Point Formats <BR>
</B>VAX floating-point numbers are stored in one set of formats in memory and in a second set of <BR>
formats in registers. The floating-point load and store instructions convert between these for-mats <BR>
purely by rearranging bits; no rounding or range-checking is done by the load and store <BR>
instructions. <BR>
<P>
<B>2.2.5.1 F_ floating <BR>
</B>An F_ floating datum is 4 contiguous bytes in memory starting on an arbitrary byte boundary. <BR>
The bits are labeled from right to left, 0 through 31, as shown <A href="#page29">in Figure 2– </A>
5 . <BR>
<P>
<B>Figure 2– 5: F_ floating Datum <BR>
</B><P>
An F_ floating operand occupies 64 bits in a floating register, left-justified in the 64-bit regis-ter, <BR>
as shown in <A href="#page29">Figure 2– 6. <BR>
</A>
<P>
<B>Figure 2– 6: F_ floating Register Format <BR>
</B><P>
The F_ floating load instruction reorders bits on the way in from memory, expands the expo-nent <BR>
from 8 to 11 bits, and sets the low-order fraction bits to zero. This produces in the register <BR>
an equivalent G_ floating number suitable for either F_ floating or G_ floating operations. The <BR>
mapping from 8-bit memory-format exponents to 11-bit register-format exponents is shown in <BR>
<A href="#page30">Table 2– 1. </A>
This mapping preserves both normal values and exceptional values. <BR>
<P>
S Frac. Hi Fraction Lo :A Exp. <BR>
6 0 7 15 16 14 31 <BR>
<P>
0 63 62 <BR>
S <BR>
52 51 29 28 <BR>
Exp. Fraction 0 :Fx 
29
<BR>
<A href=#page29>29</A>
<strong><A name=page30> Page 30</A></strong>
<A href=#page31>31</A>
<BR>
<P>
<B>2– 4 </B>Alpha Architecture Handbook <BR>
The F_ floating store instruction reorders register bits on the way to memory and does no <BR>
checking of the low-order fraction bits. Register bits &lt;61: 59&gt; and &lt;28: 0&gt; are ignored by the <BR>
store instruction. <BR>
<P>
An F_ floating datum is specified by its address A, the address of the byte containing bit 0. The <BR>
memory form of an F_ floating datum is sign magnitude with bit 15 the sign bit, bits &lt;14: 7&gt; an <BR>
excess-128 binary exponent, and bits &lt;6: 0&gt; and &lt;31: 16&gt; a normalized 24-bit fraction with the <BR>
redundant most significant fraction bit not represented. Within the fraction, bits of increasing <BR>
significance are from 16 through 31 and 0 through 6. The 8-bit exponent field encodes the val-ues <BR>
0 through 255. An exponent value of 0, together with a sign bit of 0, is taken to indicate <BR>
that the F_ floating datum has a value of 0. <BR>
<P>
If the result of a VAX floating-point format instruction has a value of zero, the instruction <BR>
always produces a datum with a sign bit of 0, an exponent of 0, and all fraction bits of 0. Expo-nent <BR>
values of 1.. 255 indicate true binary exponents of –127.. 127. An exponent value of 0, <BR>
together with a sign bit of 1, is taken as a reserved operand. Floating-point instructions pro-cessing <BR>
a reserved operand take an arithmetic exception. The value of an F_ floating datum is in <BR>
the approximate range 0.29* 10**– 38 through 1.7* 10** 38. The precision of an F_ floating <BR>
datum is approximately one part in 2** 23, typically 7 decimal digits. <A href="#page118">See Section 4.7. <BR>
</A>
<P>
<B>Note: <BR>
</B>Alpha implementations will impose a significant performance penalty when accessing <BR>
F_ floating operands that are not naturally aligned. (A naturally aligned F_ floating datum <BR>
has zero as the low-order two bits of its address.) <BR>
<P>
<B>2.2.5.2 G_ floating <BR>
</B>A G_ floating datum in memory is 8 contiguous bytes starting on an arbitrary byte boundary. <BR>
The bits are labeled from right to left, 0 through 63, as shown <A href="#page30">in Figure 2– </A>
7. <BR>
<P>
<B>Figure 2– 7: G_ floating Datum <BR>
</B><P>
<B>Table 2– 1: F_ floating Load Exponent Mapping (MAP_ F) <BR>
Memory &lt;14: 7&gt; Register &lt;62: 52&gt; <BR>
</B>1 1111111 1 000 1111111 <BR>
1 xxxxxxx 1 000 xxxxxxx (xxxxxxx not all 1's) <BR>
0 xxxxxxx 0 111 xxxxxxx (xxxxxxx not all 0's) <BR>
0 0000000 0 000 0000000 <BR>
<P>
S Exp. Frac. Hi Fraction Midh :A <BR>
:A+ 4 Fraction Midl Fraction Lo <BR>
<P>
4 3 0 15 16 14 31 
30
<BR>
<A href=#page30>30</A>
<strong><A name=page31> Page 31</A></strong>
<A href=#page32>32</A>
<BR>
<P>
Basic Architecture <B>2– 5 <BR>
</B>A G_ floating operand occupies 64 bits in a floating register, arranged as shown <A href="#page31">in Figure 2– </A>
8. <BR>
<B>Figure 2– 8: G_ floating Register Format <BR>
</B><P>
A G_ floating datum is specified by its address A, the address of the byte containing bit 0. The <BR>
form of a G_ floating datum is sign magnitude with bit 15 the sign bit, bits &lt;14: 4&gt; an excess-1024 <BR>
binary exponent, and bits &lt;3: 0&gt; and &lt;63: 16&gt; a normalized 53-bit fraction with the redun-dant <BR>
most significant fraction bit not represented. Within the fraction, bits of increasing <BR>
significance are from 48 through 63, 32 through 47, 16 through 31, and 0 through 3. The 11-bit <BR>
exponent field encodes the values 0 through 2047. An exponent value of 0, together with a sign <BR>
bit of 0, is taken to indicate that the G_ floating datum has a value of 0. <BR>
<P>
If the result of a floating-point instruction has a value of zero, the instruction always produces <BR>
a datum with a sign bit of 0, an exponent of 0, and all fraction bits of 0. Exponent values of <BR>
1.. 2047 indicate true binary exponents of –1023.. 1023. An exponent value of 0, together with a <BR>
sign bit of 1, is taken as a reserved operand. Floating-point instructions processing a reserved <BR>
operand take a user-visible arithmetic exception. The value of a G_ floating datum is in the <BR>
approximate range 0.56* 1 0**– 308 through 0.9* 10** 308. The precision of a G_ floating datum <BR>
is approximately one part in 2** 52, typically 15 decimal digits. <A href="#page118">See Section 4.7. <BR>
</A>
<P>
<B>Note: <BR>
</B>Alpha implementations will impose a significant performance penalty when accessing <BR>
G_ floating operands that are not naturally aligned. (A naturally aligned G_ floating datum <BR>
has zero as the low-order three bits of its address.) <BR>
<P>
<B>2.2.5.3 D_ floating <BR>
</B>A D_ floating datum in memory is 8 contiguous bytes starting on an arbitrary byte boundary. <BR>
The bits are labeled from right to left, 0 through 63, as shown <A href="#page31">in Figure 2– </A>
9. <BR>
<P>
<B>Figure 2– 9: D_ floating Datum <BR>
</B><P>
A D_ floating operand occupies 64 bits in a floating register, arranged as shown <A href="#page31">in Figure 2– </A>
10. <BR>
<B>Figure 2– 10: D_ floating Register Format <BR>
</B><P>
0 63 62 <BR>
S <BR>
32 31 <BR>
Exp. Fraction Hi Fraction Lo :Fx <BR>
52 51 <BR>
<P>
S Exp. Frac. Hi Fraction Midh :A <BR>
:A+ 4 Fraction Midl Fraction Lo <BR>
<P>
6 0 7 15 16 14 31 <BR>
<P>
0 63 62 <BR>
S <BR>
48 47 32 31 16 15 <BR>
Exp. Fraction Midh Fraction Midl Fraction Lo :Fx <BR>
55 54 <BR>
Frac. Hi 
31
<BR>
<A href=#page31>31</A>
<strong><A name=page32> Page 32</A></strong>
<A href=#page33>33</A>
<BR>
<B>2– 6 </B>Alpha Architecture Handbook <BR>
The reordering of bits required for a D_ floating load or store is identical to that required for a <BR>
G_ floating load or store. The G_ floating load and store instructions are therefore used for load-ing <BR>
or storing D_ floating data. <BR>
<P>
A D_ floating datum is specified by its address A, the address of the byte containing bit 0. The <BR>
memory form of a D_ floating datum is identical to an F_ floating datum except for 32 addi-tional <BR>
low significance fraction bits. Within the fraction, bits of increasing significance are <BR>
from 48 through 63, 32 through 47, 16 through 31, and 0 through 6. The exponent conventions <BR>
and approximate range of values is the same for D_ floating as F_ floating. The precision of a <BR>
D_ floating datum is approximately one part in 2** 55, typically 16 decimal digits. <BR>
<P>
<B>Notes: <BR>
</B>D_ floating is not a fully supported data type; no D_ floating arithmetic operations are <BR>
provided in the architecture. For backward compatibility, exact D_ floating arithmetic may <BR>
be provided via software emulation. D_ floating "format compatibility" in which binary files <BR>
of D_ floating numbers may be processed, but without the last three bits of fraction <BR>
precision, can be obtained via conversions to G_ floating, G arithmetic operations, then <BR>
conversion back to D_ floating. <BR>
<P>
Alpha implementations will impose a significant performance penalty on access to <BR>
D_ floating operands that are not naturally aligned. (A naturally aligned D_ floating datum <BR>
has zero as the low-order three bits of its address.) <BR>
<P>
<B>2.2. 6 IEEE Floating-Point Formats <BR>
</B>The IEEE standard for binary floating-point arithmetic, ANSI/ IEEE 754-1985, defines four <BR>
floating-point formats in two groups, basic and extended, each having two widths, single and <BR>
double. The Alpha architecture supports the basic single and double formats, with the basic <BR>
double format serving as the extended single format. The values representable within a format <BR>
are specified by using three integer parameters: <BR>
<P>
<B>° </B>P – the number of fraction bits <BR>
<B>° </B>Emax – the maximum exponent <BR>
<B>° </B>Emin – the minimum exponent <BR>
Within each format, only the following entities are permitted: <BR>
<B>° </B>Numbers of the form (– 1)** S x 2** E x b( 0). b( 1) b( 2).. b( P– 1) where: <BR>
– S = 0 or 1 <BR>
– E = any integer between Emin and Emax, inclusive <BR>
– b( n) = 0 or 1 <BR>
<B>° </B>Two infinities – positive and negative <BR>
<B>° </B>At least one Signaling NaN <BR>
<B>° </B>At least one Quiet NaN <BR>
NaN is an acronym for Not-a-Number. A NaN is an IEEE floating-point bit pattern that repre-sents <BR>
something other than a number. NaNs come in two forms: Signaling NaNs and Quiet 
32
<BR>
<A href=#page32>32</A>
<strong><A name=page33> Page 33</A></strong>
<A href=#page34>34</A>
<BR>
<P>
Basic Architecture <B>2– 7 <BR>
</B>NaNs. Signaling NaNs are used to provide values for uninitialized variables and for arithmetic <BR>
enhancements. Quiet NaNs provide retrospective diagnostic information regarding previous <BR>
invalid or unavailable data and results. Signaling NaNs signal an invalid operation when they <BR>
are an operand to an arithmetic instruction, and may generate an arithmetic exception. Quiet <BR>
NaNs propagate through almost every operation without generating an arithmetic exception. <BR>
<P>
Arithmetic with the infinities is handled as if the operands were of arbitrarily large magnitude. <BR>
Negative infinity is less than every finite number; positive infinity is greater than every finite <BR>
number. <BR>
<P>
<B>2.2.6.1 S_ Floating <BR>
</B>An IEEE single-precision, or S_ floating, datum occupies 4 contiguous bytes in memory start-ing <BR>
on an arbitrary byte boundary. The bits are labeled from right to left, 0 through 31, as <BR>
shown in <A href="#page33">Figure 2– 11. <BR>
</A>
<P>
<B>Figure 2– 11: S_ floating Datum <BR>
</B><P>
An S_ floating operand occupies 64 bits in a floating register, left-justified in the 64-bit regis-ter, <BR>
as shown in <A href="#page33">Figure 2– 12. <BR>
</A>
<P>
<B>Figure 2– 12: S_ floating Register Format <BR>
</B><P>
The S_ floating load instruction reorders bits on the way in from memory, expanding the expo-nent <BR>
from 8 to 11 bits, and sets the low-order fraction bits to zero. This produces in the register <BR>
an equivalent T_ floating number, suitable for either S_ floating or T_ floating operations. The <BR>
mapping from 8-bit memory-format exponents to 11-bit register-format exponents is shown in <BR>
<A href="#page33">Table 2– 2. <BR>
</A>
<P>
<B>Table 2– 2: S_ floating Load Exponent Mapping (MAP_ S) <BR>
Memory &lt;30: 23&gt; Register &lt;62: 52&gt; <BR>
</B>1 1111111 1 111 1111111 <BR>
1 xxxxxxx 1 000 xxxxxxx (xxxxxxx not all 1's) <BR>
0 xxxxxxx 0 111 xxxxxxx (xxxxxxx not all 0's) <BR>
0 0000000 0 000 0000000 <BR>
<P>
S Exp. Fraction :A <BR>
0 30 31 22 23 <BR>
<P>
0 63 62 <BR>
S <BR>
52 51 29 28 <BR>
Exp. Fraction 0 :Fx 
33
<BR>
<A href=#page33>33</A>
<strong><A name=page34> Page 34</A></strong>
<A href=#page35>35</A>
<BR>
<P>
<B>2– 8 </B>Alpha Architecture Handbook <BR>
This mapping preserves both normal values and exceptional values. Note that the mapping for <BR>
all 1's differs from that of F_ floating load, since for S_ floating all 1's is an exceptional value <BR>
and for F_ floating all 1's is a normal value. <BR>
<P>
The S_ floating store instruction reorders register bits on the way to memory and does no <BR>
checking of the low-order fraction bits. Register bits &lt;61: 59&gt; and &lt;28: 0&gt; are ignored by the <BR>
store instruction. The S_ floating load instruction does no checking of the input. <BR>
<P>
The S_ floating store instruction does no checking of the data; the preceding operation should <BR>
have specified an S_ floating result. <BR>
<P>
An S_ floating datum is specified by its address A, the address of the byte containing bit 0. The <BR>
memory form of an S_ floating datum is sign magnitude with bit 31 the sign bit, bits &lt;30: 23&gt; <BR>
an excess-127 binary exponent, and bits &lt;22: 0&gt; a 23-bit fraction. <BR>
<P>
The value (V) of an S_ floating number is inferred from its constituent sign (S), exponent (E), <BR>
and fraction (F) fields as follows: <BR>
<P>
<B>° </B>If E= 255 and F&lt;&gt; 0, then V is NaN, regardless of S. <BR>
<B>° </B>If E= 255 and F= 0, then V = (– 1)** S x Infinity. <BR>
<B>° </B>If 0 &lt; E &lt; 255, then V = (– 1)** S x 2**( E– 127) x (1. F). <BR>
<B>° </B>If E= 0 and F&lt;&gt; 0, then V = (– 1)** S x 2**(– 126) x (0. F). <BR>
<B>° </B>If E= 0 and F= 0, then V = (– 1)** S x 0 (zero). <BR>
Floating-point operations on S_ floating numbers may take an arithmetic exception for a vari-ety <BR>
of reasons, including invalid operations, overflow, underflow, division by zero, and inexact <BR>
results. <BR>
<P>
<B>Note: <BR>
</B>Alpha implementations will impose a significant performance penalty when accessing <BR>
S_ floating operands that are not naturally aligned. (A naturally aligned S_ floating datum <BR>
has zero as the low-order two bits of its address.) <BR>
<P>
<B>2.2.6.2 T_ floating <BR>
</B>An IEEE double-precision, or T_ floating, datum occupies 8 contiguous bytes in memory start-ing <BR>
on an arbitrary byte boundary. The bits are labeled from right to left, 0 through 63, as <BR>
shown in <A href="#page34">Figure 2– 13. <BR>
</A>
<P>
<B>Figure 2– 13: T_ floating Datum <BR>
</B><P>
S <BR>
:A <BR>
:A+ 4 <BR>
Fraction Lo <BR>
Fraction Hi Exponent <BR>
<P>
0 31 30 19 20 
34
<BR>
<A href=#page34>34</A>
<strong><A name=page35> Page 35</A></strong>
<A href=#page36>36</A>
<BR>
<P>
Basic Architecture <B>2– 9 <BR>
</B>A T_ floating operand occupies 64 bits in a floating register, arranged as shown <A href="#page35">in Figure 2– </A>
14. <BR>
<B>Figure 2– 14: T_ floating Register Format <BR>
</B><P>
The T_ floating load instruction performs no bit reordering on input, nor does it perform check-ing <BR>
of the input data. <BR>
<P>
The T_ floating store instruction performs no bit reordering on output. This instruction does no <BR>
checking of the data; the preceding operation should have specified a T_ floating result. <BR>
<P>
A T_ floating datum is specified by its address A, the address of the byte containing bit 0. The <BR>
form of a T_ floating datum is sign magnitude with bit 63 the sign bit, bits &lt;62: 52&gt; an excess-1023 <BR>
binary exponent, and bits &lt;51: 0&gt; a 52-bit fraction. <BR>
<P>
The value (V) of a T_ floating number is inferred from its constituent sign (S), exponent (E), <BR>
and fraction (F) fields as follows: <BR>
<P>
<B>° </B>If E= 2047 and F&lt;&gt; 0, then V is NaN, regardless of S. <BR>
<B>° </B>If E= 2047 and F= 0, then V = (– 1)** S x Infinity. <BR>
<B>° </B>If 0 &lt; E &lt; 2047, then V = (– 1)** S x 2**( E– 1023) x (1. F). <BR>
<B>° </B>If E= 0 and F&lt;&gt; 0, then V = (– 1)** S x 2**(– 1022) x (0. F). <BR>
<B>° </B>If E= 0 and F= 0, then V = (– 1)** S x 0 (zero). <BR>
Floating-point operations on T_ floating numbers may take an arithmetic exception for a vari-ety <BR>
of reasons, including invalid operations, overflow, underflow, division by zero, and inexact <BR>
results. <BR>
<P>
<B>Note: <BR>
</B>Alpha implementations will impose a significant performance penalty when accessing <BR>
T_ floating operands that are not naturally aligned. (A naturally aligned T_ floating datum <BR>
has zero as the low-order three bits of its address.) <BR>
<P>
<B>2.2.6.3 X_ Floating <BR>
</B>Support for 128-bit IEEE extended-precision (X_ float) floating-point is initially provided <BR>
entirely through software. This section is included to preserve the intended consistency of <BR>
implementation with other IEEE floating-point data types, should the X_ float data type be sup-ported <BR>
in future hardware. <BR>
<P>
An IEEE extended-precision, or X_ floating, datum occupies 16 contiguous bytes in memory, <BR>
starting on an arbitrary byte boundary. The bits are labeled from right to left, 0 through 127, as <BR>
shown in <A href="#page36">Figure 2– 15. <BR>
</A>
<P>
0 63 62 <BR>
S <BR>
32 31 <BR>
Exp. Fraction Hi Fraction Lo :Fx <BR>
52 51 
35
<BR>
<A href=#page35>35</A>
<strong><A name=page36> Page 36</A></strong>
<A href=#page37>37</A>
<BR>
<P>
<B>2– 10 </B>Alpha Architecture Handbook <BR>
<B>Figure 2– 15: X_ floating Datum <BR>
</B>An X_ floating datum occupies two consecutive even/ odd floating-point registers (such as <BR>
F4/ F5), as shown in <A href="#page36">Figure 2– 16. <BR>
</A>
<P>
<B>Figure 2– 16: X_ floating Register Format <BR>
</B><P>
An X_ floating datum is specified by its address A, the address of the byte containing bit 0. The <BR>
form of an X_ floating datum is sign magnitude with bit 127 the sign bit, bits &lt;126: 112&gt; an <BR>
excess– 16383 binary exponent, and bits &lt;111: 0&gt; a 112-bit fraction. <BR>
<P>
The value (V) of an X_ floating number is inferred from its constituent sign (S), exponent (E), <BR>
and fraction (F) fields as follows: <BR>
<P>
<B>° </B>If E= 32767 and F&lt;&gt; 0, then V is a NaN, regardless of S. <BR>
<B>° </B>If E= 32767 and F= 0, then V = (– 1)** S x Infinity. <BR>
<B>° </B>If 0 &lt; E &lt; 32767, then V = (– 1)** S x 2**( E– 16383) x (1. F). <BR>
<B>° </B>If E= 0 and F&lt;&gt; 0, then V = (– 1)** S x 2**(– 16382) x (0. F). <BR>
<B>° </B>If E = 0 and F = 0, then V = (– 1)** S x 0 (zero). <BR>
<P>
<B>Note: <BR>
</B>Alpha implementations will impose a significant performance penalty when accessing <BR>
X_ floating operands that are not naturally aligned. (A naturally aligned X_ floating datum <BR>
has zero as the low-order four bits of its address.) <BR>
<P>
<B>X_ Floating Big-Endian Formats <BR>
<A href="#page39">Section 2. 3 </A>
describes Alpha support for big-endian data types. It is intended that software or <BR>
hardware implementation for a big-endian X_ float data type comply with that support and have <BR>
the following formats. <BR>
<P>
0 <BR>
S Exponent Fraction_ high <BR>
Fraction_ low <BR>
48 47 63 62 <BR>
:A <BR>
<P>
:A+ 8 <BR>
<P>
127 0 64 63 <BR>
S <BR>
126 112 111 <BR>
Exponent Fraction_ high Fraction_ low <BR>
<P>
Fn OR 1 Fn 
36
<BR>
<A href=#page36>36</A>
<strong><A name=page37> Page 37</A></strong>
<A href=#page38>38</A>
<BR>
<P>
Basic Architecture <B>2– 11 <BR>
Figure 2– 17: X_ floating Big-Endian Datum <BR>
Figure 2– 18: X_ floating Big-Endian Register Format <BR>
2.2. 7 Longword Integer Format in Floating-Point Unit <BR>
</B>A longword integer operand occupies 32 bits in memory, arranged as shown <A href="#page37">in Figure 2– </A>
19. <BR>
<P>
<B>Figure 2– 19: Longword Integer Datum <BR>
</B><P>
A longword integer operand occupies 64 bits in a floating register, arranged as shown in <A href="#page37">Fig-ure <BR>
</A>
<A href="#page37">2– 20. <BR>
</A>
<P>
<B>Figure 2– 20: Longword Integer Floating-Register Format <BR>
</B><P>
There is no explicit longword load or store instruction; the S_ floating load/ store instructions <BR>
are used to move longword data into or out of the floating registers. The register bits &lt;61: 59&gt; <BR>
are set by the S_ floating load exponent mapping. They are ignored by S_ floating store. They <BR>
are also ignored in operands of a longword integer operate instruction, and they are set to 000 <BR>
in the result of a longword operate instruction. <BR>
<P>
The register format bit &lt;62&gt; "I" in <A href="#page37">Figure 2– 20 </A>
is part of the Integer field in <A href="#page37">Figure 2– 19 </A>
and <BR>
represents the high-order bit of that field. <BR>
<P>
15 <BR>
S Exponent Fraction_ high <BR>
<P>
Fraction_ low <BR>
<P>
0 <BR>
A+ 8: <BR>
A: <BR>
Byte <BR>
<P>
Byte <BR>
<P>
0 15 <BR>
S Exponent Fraction_ high Fraction_ low <BR>
<P>
Fn OR 1 Fn <BR>
<P>
Byte Byte <BR>
<P>
S Integer :A <BR>
0 30 31 <BR>
<P>
0 63 62 <BR>
S <BR>
59 58 29 28 <BR>
xxx Integer 0 :Fx <BR>
61 <BR>
I 
37
<BR>
<A href=#page37>37</A>
<strong><A name=page38> Page 38</A></strong>
<A href=#page39>39</A>
<BR>
<P>
<B>2– 12 </B>Alpha Architecture Handbook <BR>
<B>Note: <BR>
</B>Alpha implementations will impose a significant performance penalty when accessing <BR>
longwords that are not naturally aligned. (A naturally aligned longword datum has zero as <BR>
the low-order two bits of its address.) <BR>
<P>
<B>2.2. 8 Quadword Integer Format in Floating-Point Unit <BR>
</B>A quadword integer operand occupies 64 bits in memory, arranged as shown <A href="#page38">in Figure 2– </A>
21. <BR>
<P>
<B>Figure 2– 21: Quadword Integer Datum <BR>
</B><P>
A quadword integer operand occupies 64 bits in a floating register, arranged as shown in <A href="#page38">Fig-ure <BR>
</A>
<A href="#page38">2– 22. <BR>
</A>
<P>
<B>Figure 2– 22: Quadword Integer Floating-Register Format <BR>
</B><P>
There is no explicit quadword load or store instruction; the T_ floating load/ store instructions <BR>
are used to move quadword data between memory and the floating registers. (The ITOFT and <BR>
FTOIT are used to move quadword data between integer and floating registers.) <BR>
<P>
The T_ floating load instruction performs no bit reordering on input. The T_ floating store <BR>
instruction performs no bit reordering on output. This instruction does no checking of the data; <BR>
when used to store quadwords, the preceding operation should have specified a quadword <BR>
result. <BR>
<P>
<B>Note: <BR>
</B>Alpha implementations will impose a significant performance penalty when accessing <BR>
quadwords that are not naturally aligned. (A naturally aligned quadword datum has zero as <BR>
the low-order three bits of its address.) <BR>
<P>
<B>2.2. 9 Data Types with No Hardware Support <BR>
° </B>The following VAX data types are not directly supported in Alpha hardware. Octaword <BR>
<B>° </B>H_ floating <BR>
<B>° </B>D_ floating (except load/ store and convert to/ from G_ floating) <BR>
<B>° </B>Variable-Length Bit Field <BR>
<B>° </B>Character String <BR>
<P>
S <BR>
:A <BR>
:A+ 4 <BR>
Integer Lo <BR>
Integer Hi <BR>
<P>
0 31 30 <BR>
<P>
0 63 62 <BR>
S <BR>
32 31 <BR>
Integer Hi Integer Lo :Fx 
38
<BR>
<A href=#page38>38</A>
<strong><A name=page39> Page 39</A></strong>
<A href=#page40>40</A>
<BR>
<P>
Basic Architecture <B>2– 13 <BR>
° </B>Trailing Numeric String <BR>
<B>° </B>Leading Separate Numeric String <BR>
<B>° </B>Packed Decimal String <BR>
<P>
<B>2. 3 Big-Endian Addressing Support <BR>
</B>Alpha implementations may include optional big-endian addressing support. <BR>
In a little-endian machine, the bytes within a quadword are numbered right to left: <BR>
<P>
<B>Figure 2– 23: Little-Endian Byte Addressing <BR>
</B><P>
In a big-endian machine, they are numbered left to right: <BR>
<B>Figure 2– 24: Big-Endian Byte Addressing <BR>
</B><P>
Bit numbering within bytes is not affected by the byte numbering convention (big-endian or lit-tle-<BR>
endian). <BR>
<P>
The format for the X_ floating big-endian data type is shown <A href="#page35">in Section 2.2.6. </A>
3. <BR>
The byte numbering convention does not matter when accessing complete aligned quadwords <BR>
in memory. However, the numbering convention does matter when accessing smaller or <BR>
unaligned quantities, or when manipulating data in registers, as follows: <BR>
<P>
<B>° </B>A quadword load or store of data at location 0 moves the same eight bytes under both numbering conventions. However, a longword load or store of data at location 4 must <BR>
<P>
move the leftmost half of a quadword under the little-endian convention, and the right-most <BR>
half under the big-endian convention. Thus, to support both conventions, the con-vention <BR>
being used must be known and it must affect longword load/ store operations. <BR>
<P>
<B>° </B>A byte extract of byte 5 from a quadword of data into the low byte of a register requires a right shift of 5 bytes under the little-endian convention, but a right shift of 2 bytes <BR>
<P>
under the big-endian convention. <BR>
<B>° </B>Manipulation of data in a register is almost the same for both conventions. In both, inte-ger and floating-point data have their sign bits in the leftmost byte and their least signif-icant <BR>
<P>
bit in the rightmost byte, so the same integer and floating-point instructions are <BR>
<P>
5 43 21 6 7 0 <BR>
2 34 56 1 0 7 
39
<BR>
<A href=#page39>39</A>
<strong><A name=page40> Page 40</A></strong>
<A href=#page41>41</A>
<BR>
<P>
<B>2– 14 </B>Alpha Architecture Handbook <BR>
used unchanged for both conventions. Big-endian character strings have their most sig-nificant <BR>
character on the left, while little-endian strings have their most significant char-acter <BR>
on the right. <BR>
<P>
<B>° </B>The compare byte (CMPBGE) instruction is neutral about direction, doing eight byte compares in parallel. However, following the CMPBGE instruction, the code is differ-ent <BR>
<P>
that examines the byte mask to determine which string is larger, depending on <BR>
whether the rightmost or leftmost unequal byte is used. Thus, compilers must be <BR>
instructed to generate somewhat different code sequences for the two conventions. <BR>
<P>
Implementations that include big-endian support must supply all of the following features: <BR>
<B>° </B>A means at boot time to choose the byte numbering convention. The implementation is not required to support dynamically changing the convention during program execu-tion. <BR>
<P>
The chosen convention applies to all code executed, both operating-system and <BR>
user. <BR>
<P>
<B>° </B>If the big-endian convention is chosen, the longword-length load/ store instructions (LDF, LDL, LDL_ L, LDS, STF, STL, STL_ C, STS) invert bit va&lt; 2&gt; (bit 2 of the vir-tual <BR>
<P>
address). This has the effect of accessing the half of a quadword other than the half <BR>
that would be accessed under the little-endian convention. <BR>
<P>
<B>° </B>If the big-endian convention is chosen, the word-length load instruction, LDWU, inverts bits va&lt; 1: 2&gt; (bits 1 and 2 of the virtual address). This has the effect of accessing <BR>
<P>
the half of the longword that would be accessed under the little-endian convention. <BR>
<B>° </B>If the big-endian convention is chosen, the byte-length load instruction, LDBU, inverts bits va&lt; 0: 2&gt; (bits 0 through 2 of the virtual address). This has the effect of accessing <BR>
<P>
the half of the word that would be accessed under the little-endian convention. <BR>
<B>° </B>If the big-endian convention is chosen, the byte manipulation instructions (EXTxx, INSxx, MSKxx) invert bits Rbv&lt; 2: 0&gt;. This has the effect of changing a shift of 5 bytes <BR>
<P>
into a shift of 2 bytes, for example. <BR>
The instruction stream is always considered to be little-endian, and is independent of the cho-sen <BR>
byte numbering convention. Compilers, linkers, and debuggers must be aware of this when <BR>
accessing an instruction stream using data-stream load/ store instructions. Thus, the rightmost <BR>
instruction in a quadword is always executed first and always has the instruction-stream <BR>
address 0 MOD 8. The same bytes accessed by a longword load/ store instruction have data-stream <BR>
address 0 MOD 8 under the little-endian convention, and 4 MOD 8 under the big-endian <BR>
convention. <BR>
<P>
Using either byte numbering convention, it is sometimes necessary to access data that origi-nated <BR>
on a machine that used the other convention. When this occurs, it is often necessary to <BR>
swap the bytes within a datum. <A href="#page285">See Section A. 4.3 </A>
for a suggested code sequence. 
40
<BR>
<A href=#page40>40</A>
<strong><A name=page41> Page 41</A></strong>
<A href=#page42>42</A>
<BR>
<P>
Instruction Formats <B>3– 1 <BR>
Chapter 3 <BR>
Instruction Formats <BR>
</B><P>
<B>3.1 Alpha Registers <BR>
</B>Each Alpha processor has a set of registers that hold the current processor state. If an Alpha <BR>
system contains multiple Alpha processors, there are multiple per-processor sets of these <BR>
registers. <BR>
<P>
<B>3.1. 1 Program Counter <BR>
</B>The Program Counter (PC) is a special register that addresses the instruction stream. As each <BR>
instruction is decoded, the PC is advanced to the next sequential instruction. This is referred to <BR>
as the <I>updated PC. </I>Any instruction that uses the value of the PC will use the updated PC. The <BR>
PC includes only bits &lt;63: 2&gt; with bits &lt;1: 0&gt; treated as RAZ/ IGN. This quantity is a long-word-<BR>
aligned byte address. The PC is an implied operand on conditional branch and subroutine <BR>
jump instructions. The PC is not accessible as an integer register. <BR>
<P>
<B>3.1. 2 Integer Registers <BR>
</B>There are 32 integer registers (R0 through R31), each 64 bits wide. <BR>
<P>
Register R31 is assigned special meaning by the Alpha architecture. When R31 is specified as <BR>
a register source operand, a zero-valued operand is supplied. <BR>
<P>
For all cases except the Unconditional Branch and Jump instructions, results of an instruction <BR>
that specifies R31 as a destination operand are discarded. Also, it is UNPREDICTABLE <BR>
whether the other destination operands (implicit and explicit) are changed by the instruction. It <BR>
is implementation dependent to what extent the instruction is actually executed once it has <BR>
been fetched. An exception is never signaled for a load that specifies R31 as a destination oper-ation. <BR>
For all other operations, it is UNPREDICTABLE whether exceptions are signaled during <BR>
the execution of such an instruction. Note, however, that exceptions associated with the <BR>
instruction fetch of such an instruction are always signaled. <BR>
<P>
<B>Implementation note: <BR>
</B>As described in <A href="#page282">Section A. 3.5, </A>
certain load instructions to an R31 destination are the <BR>
preferred method for performing a cache block prefetch. 
41
<BR>
<A href=#page41>41</A>
<strong><A name=page42> Page 42</A></strong>
<A href=#page43>43</A>
<BR>
<P>
<B>3– 2 </B>Alpha Architecture Handbook <BR>
There are some interesting cases involving R31 as a destination: <BR>
<B>° </B>STx_ C R31,disp( Rb) <BR>
Although this might seem like a good way to zero out a shared location and reset the <BR>
lock_ flag, this instruction causes the lock_ flag and virtual location {Rbv + <BR>
SEXT( disp)} to become UNPREDICTABLE. <BR>
<P>
<B>° </B>LDx_ L R31,disp( Rb) <BR>
This instruction produces no useful result since it causes both lock_ flag and <BR>
locked_ physical_ address to become UNPREDICTABLE. <BR>
<P>
Unconditional Branch (BR and BSR) and Jump (JMP, JSR, RET, and JSR_ COROUTINE) <BR>
instructions, when R31 is specified as the Ra operand, execute normally and update the PC <BR>
with the target virtual address. Of course, no PC value can be saved in R31. <BR>
<P>
<B>3.1. 3 Floating-Point Registers <BR>
</B>There are 32 floating-point registers (F0 through F31), each 64 bits wide. <BR>
<P>
When F31 is specified as a register source operand, a true zero-valued operand is supplied. See <BR>
<A href="#page119">Section 4. 7.3 </A>
for a definition of true zero. <BR>
<P>
Results of an instruction that specifies F31 as a destination operand are discarded and it is <BR>
UNPREDICTABLE whether the other destination operands (implicit and explicit) are changed <BR>
by the instruction. In this case, it is implementation-dependent to what extent the instruction is <BR>
actually executed once it has been fetched. An exception is never signaled for a load that speci-fies <BR>
F31 as a destination operation. For all other operations, it is UNPREDICTABLE whether <BR>
exceptions are signaled during the execution of such an instruction. Note, however, that excep-tions <BR>
associated with the instruction fetch of such an instruction are always signaled. <BR>
<P>
<B>Implementation note: <BR>
</B>As described in <A href="#page282">Section A. 3. 5, </A>
certain load instructions to an F31 destination are the <BR>
preferred method for signalling a cache block prefetch. <BR>
<P>
A floating-point instruction that operates on single-precision data reads all bits &lt;63: 0&gt; of the <BR>
source floating-point register. A floating-point instruction that produces a single-precision <BR>
result writes all bits &lt;63: 0&gt; of the destination floating-point register. <BR>
<P>
<B>3. 1.4 Lock Registers <BR>
</B>There are two per-processor registers associated with the LDx_ L and STx_ C instructions, the <BR>
lock_ flag and the locked_ physical_ address register. The use of these registers is described in <BR>
<A href="#page60">Section 4. 2. 
42
<BR>
<A href=#page42>42</A>
<strong><A name=page43> Page 43</A></strong>
<A href=#page44>44</A>
<BR>
<P>
</A>
Instruction Formats <B>3– 3 <BR>
3.1. 5 Processor Cycle Counter (PCC) Register <BR>
</B>The PCC register consists of two 32-bit fields. The low-order 32 bits (PCC&lt; 31: 0&gt;) are an <BR>
unsigned wrapping counter, PCC_ CNT. The high-order 32 bits (PCC&lt; 63: 32&gt;), PCC_ OFF, are <BR>
operating system dependent in their implementation. <BR>
<P>
PCC_ CNT is the base clock register for measuring time intervals and is suitable for timing <BR>
intervals on the order of nanoseconds. <BR>
<P>
PCC_ CNT increments once per N CPU cycles, where N is an implementation-specific integer <BR>
in the range 1.. 16. The cycle counter frequency is the number of times the processor cycle <BR>
counter gets incremented per second. The integer count wraps to 0 from a count of FFFF <BR>
FFFF 16 . The counter wraps no more frequently than 1. 5 times the implementation's interval <BR>
<P>
clock interrupt period (which is two thirds of the interval clock interrupt frequency), which <BR>
guarantees that an interrupt occurs before PCC _CNT overflows twice. <BR>
<P>
PCC_ OFF need not contain a value related to time and could contain all zeros in a simple <BR>
implementation. However, if PCC_ OFF is used to calculate a per-process or per-thread cycle <BR>
count, it must contain a value that, when added to PCC_ CNT, returns the total PCC register <BR>
count for that process or thread, modulo 2** 32. <BR>
<P>
<B>Implementation Note: <BR>
</B>OpenVMS Alpha and DIGITAL UNIX supply a per-process value in PCC_ OFF. <BR>
<P>
PCC is required on all implementations. It is required for every processor, and each processor <BR>
on a multiprocessor system has its own private, independent PCC. <BR>
<P>
The PCC is read by the RPCC instruction. <A href="#page199">See Section 4.11.8. <BR>
</A>
<P>
<B>3.1. 6 Optional Registers <BR>
</B>Some Alpha implementations may include optional memory prefetch or VAX compatibility <BR>
processor registers. <BR>
<P>
<B>3.1.6.1 Memory Prefetch Registers <BR>
</B>If the prefetch instructions FETCH and FETCH_ M are implemented, an implementation will <BR>
include two sets of state prefetch registers used by those instructions. The use of these regis-ters <BR>
is described in <A href="#page188">Section 4.11. </A>
These registers are not directly accessible by software and are <BR>
listed for completeness. <BR>
<P>
<B>3.1.6.2 VAX Compatibility Register <BR>
</B>The VAX compatibility instructions RC and RS include the intr_ flag register, as described in <BR>
<A href="#page205">Section 4. 12. <BR>
</A>
<P>
<B>3.2 Notation <BR>
</B>The notation used to describe the operation of each instruction is given as a sequence of con-trol <BR>
and assignment statements in an ALGOL-like syntax. 
43
<BR>
<A href=#page43>43</A>
<strong><A name=page44> Page 44</A></strong>
<A href=#page45>45</A>
<BR>
<P>
<B>3– 4 </B>Alpha Architecture Handbook <BR>
<B>3.2. 1 Operand Notation <BR>
</B>Tables <A href="#page44">3– 1, </A>
<A href="#page44">3– 2, </A>
and <A href="#page44">3– 3 </A>
list the notation for the operands, the operand values, and the other <BR>
expression operands. <BR>
<P>
<B>Table 3– 1: Operand Notation <BR>
Notation Meaning <BR>
</B>Ra An integer register operand in the Ra field of the instruction <BR>
Rb An integer register operand in the Rb field of the instruction <BR>
#b An integer literal operand in the Rb field of the instruction <BR>
Rc An integer register operand in the Rc field of the instruction <BR>
Fa A floating-point register operand in the Ra field of the instruction <BR>
Fb A floating-point register operand in the Rb field of the instruction <BR>
Fc A floating-point register operand in the Rc field of the instruction <BR>
<P>
<B>Table 3– 2: Operand Value Notation <BR>
Notation Meaning <BR>
</B>Rav The value of the Ra operand. This is the contents of register Ra. <BR>
Rbv The value of the Rb operand. This could be the contents of register Rb, or <BR>
a zero-extended 8-bit literal in the case of an Operate format instruction. <BR>
<P>
Fav The value of the floating point Fa operand. This is the contents of register <BR>
Fa. <BR>
<P>
Fbv The value of the floating point Fb operand. This is the contents of register <BR>
Fb. <BR>
<P>
<B>Table 3– 3: Expression Operand Notation <BR>
Notation Meaning <BR>
</B>IPR_ x Contents of Internal Processor Register x) <BR>
IPR_ SP[ mode] Contents of the per-mode stack pointer selected by mode <BR>
PC Updated PC value <BR>
Rn Contents of integer register n <BR>
Fn Contents of floating-point register n <BR>
X[ m] Element m of array X 
44
<BR>
<A href=#page44>44</A>
<strong><A name=page45> Page 45</A></strong>
<A href=#page46>46</A>
<BR>
Instruction Formats <B>3– 5 <BR>
3.2. 2 Instruction Operand Notation <BR>
</B>The notation used to describe instruction operands follows from the operand specifier notation <BR>
used in the <I>VAX Architecture Standard. </I>Instruction operands are described as follows: <BR>
<P>
<TT>&lt;name&gt;.&lt; access type&gt;&lt; data type&gt; <BR>
</TT><P>
<B>3.2.2.1 Operand Name Notation <BR>
</B>Specifies the instruction field (Ra, Rb, Rc, or disp) and register type of the operand (integer or <BR>
floating). It can be one of the following: <BR>
<P>
<B>3.2.2.2 Operand Access Type Notation <BR>
</B>A letter that denotes the operand access type: <BR>
<P>
<B>Table 3– 4: Operand Name Notation <BR>
Name Meaning <BR>
</B>disp The displacement field of the instruction <BR>
fnc The PALcode function field of the instruction <BR>
Ra An integer register operand in the Ra field of the instruction <BR>
Rb An integer register operand in the Rb field of the instruction <BR>
#b An integer literal operand in the Rb field of the instruction <BR>
Rc An integer register operand in the Rc field of the instruction <BR>
Fa A floating-point register operand in the Ra field of the instruction <BR>
Fb A floating-point register operand in the Rb field of the instruction <BR>
Fc A floating-point register operand in the Rc field of the instruction <BR>
<P>
<B>Table 3– 5: Operand Access Type Notation <BR>
Access Type Meaning <BR>
</B>a The operand is used in an address calculation to form an effective <BR>
address. The data type code that follows indicates the units of addressabil-ity <BR>
(or scale factor) applied to this operand when the instruction is <BR>
decoded. <BR>
<P>
For example: <BR>
". al" means scale by 4 (longwords) to get byte units (used in branch dis-placements); <BR>
". ab" means the operand is already in byte units (used in <BR>
load/ store instructions). <BR>
<P>
i The operand is an immediate literal in the instruction. 
45
<BR>
<A href=#page45>45</A>
<strong><A name=page46> Page 46</A></strong>
<A href=#page47>47</A>
<BR>
<P>
<B>3– 6 </B>Alpha Architecture Handbook <BR>
<B>3.2.2.3 Operand Data Type Notation <BR>
</B>A letter that denotes the data type of the operand: <BR>
<P>
<B>3.2. 3 Operators <BR>
<A href="#page46">Table 3– 7 </A>
describes the operators: <BR>
<P>
r The operand is read only. <BR>
m The operand is both read and written. <BR>
w The operand is write only. <BR>
<P>
<B>Table 3– 6: Operand Data Type Notation <BR>
Data Type Meaning <BR>
</B>b Byte <BR>
f F_ floating <BR>
g G_ floating <BR>
l Longword <BR>
q Quadword <BR>
s IEEE single floating (S_ floating) <BR>
t IEEE double floating (T_ floating) <BR>
w Word <BR>
x The data type is specified by the instruction <BR>
<P>
<B>Table 3– 7: Operators <BR>
Operator Meaning <BR>
</B>! Comment delimiter <BR>
+ Addition <BR>
-Subtraction <BR>
* Signed multiplication <BR>
*U Unsigned multiplication <BR>
** Exponentiation (left argument raised to right argument) <BR>
/ Division <BR>
¬ Replacement <BR>
<P>
<B>Table 3– 5: Operand Access Type Notation (Continued) <BR>
Access Type Meaning </B>
46
<BR>
<A href=#page46>46</A>
<strong><A name=page47> Page 47</A></strong>
<A href=#page48>48</A>
<BR>
Instruction Formats <B>3– 7 <BR>
</B>|| Bit concatenation <BR>
{} Indicates explicit operator precedence <BR>
(x) Contents of memory location whose address is x <BR>
x &lt;m: n&gt; Contents of bit field of x defined by bits n through m <BR>
x &lt;m&gt; M'th bit of x <BR>
ACCESS( x, y) Accessibility of the location whose address is x using the <BR>
access mode y. Returns a Boolean value TRUE if the <BR>
address is accessible, else FALSE. <BR>
<P>
AND Logical product <BR>
ARITH_ RIGHT_ SHIFT( x, y) Arithmetic right shift of first operand by the second oper-and. <BR>
Y is an unsigned shift value. Bit 63, the sign bit, is <BR>
copied into vacated bit positions and shifted out bits are <BR>
discarded. <BR>
<P>
BYTE_ ZAP( x, y) X is a quadword, y is an 8-bit vector in which each bit <BR>
corresponds to a byte of the result. The y bit to x byte cor-respondence <BR>
is y &lt;n&gt; « x &lt;8n+ 7: 8n&gt;. This correspon-dence <BR>
also exists between y and the result. <BR>
<P>
For each bit of y from n = 0 to 7, if y &lt;n&gt; is 0 then byte <BR>
&lt;n&gt; of x is copied to byte &lt;n&gt; of result, and if y &lt;n&gt; is 1 <BR>
then byte &lt;n&gt; of result is forced to all zeros. <BR>
<P>
<B>Table 3– 7: Operators (Continued) <BR>
Operator Meaning </B>
47
<BR>
<A href=#page47>47</A>
<strong><A name=page48> Page 48</A></strong>
<A href=#page49>49</A>
<BR>
<B>3– 8 </B>Alpha Architecture Handbook <BR>
CASE The CASE construct selects one of several actions based <BR>
on the value of its argument. The form of a case is: <BR>
<P>
<TT>CASE argument OF <BR>
argvalue1: action_ 1 <BR>
argvalue2: action_ 2 <BR>
... <BR>
argvaluen: action_ n <BR>
[otherwise: default_ action] <BR>
ENDCASE <BR>
</TT><P>
If the value of argument is argvalue1 then action_ 1 is exe-cuted; <BR>
if argument = argvalue2, then action_ 2 is executed, <BR>
and so forth. <BR>
<P>
Once a single action is executed, the code stream breaks <BR>
to the ENDCASE (there is an implicit break as in Pascal). <BR>
Each action may nonetheless be a sequence of <BR>
pseudocode operations, one operation per line. <BR>
<P>
Optionally, the last argvalue may be the atom 'otherwise'. <BR>
The associated default action will be taken if none of the <BR>
other argvalues match the argument. <BR>
<P>
DIV Integer division (truncates) <BR>
LEFT_ SHIFT( x, y) Logical left shift of first operand by the second operand. Y <BR>
is an unsigned shift value. Zeros are moved into the <BR>
vacated bit positions, and shifted out bits are discarded. <BR>
<P>
LOAD_ LOCKED The processor records the target physical address in a per-processor <BR>
locked_ physical_ address register and sets the <BR>
per-processor lock_ flag. <BR>
<P>
lg Log to the base 2. <BR>
MAP_ x F_ float or S_ float memory-to-register exponent mapping <BR>
function. <BR>
<P>
MAXS( x, y) Returns the larger of x and y, with x and y interpreted as <BR>
signed integers. <BR>
<P>
MAXU( x, y) Returns the larger of x and y, with x and y interpreted as <BR>
unsigned integers. <BR>
<P>
MINS( x, y) Returns the smaller of x and y, with x and y interpreted as <BR>
signed integers. <BR>
<P>
MINU( x, y) Returns the smaller of x and y, with x and y interpreted as <BR>
unsigned integers. <BR>
<P>
x MOD y x modulo y <BR>
<P>
<B>Table 3– 7: Operators (Continued) <BR>
Operator Meaning </B>
48
<BR>
<A href=#page48>48</A>
<strong><A name=page49> Page 49</A></strong>
<A href=#page50>50</A>
<BR>
Instruction Formats <B>3– 9 <BR>
</B>NOT Logical (ones) complement <BR>
OR Logical sum <BR>
PHYSICAL_ ADDRESS Translation of a virtual address <BR>
PRIORITY_ ENCODE Returns the bit position of most significant set bit, inter-preting <BR>
its argument as a positive integer (= int( lg( x))). For <BR>
example: <BR>
<TT>priority_ encode( 255 ) = 7 <BR>
</TT><P>
Relational Operators: <BR>
<P>
RIGHT_ SHIFT( x, y) Logical right shift of first operand by the second operand. <BR>
Y is an unsigned shift value. Zeros are moved into <BR>
vacated bit positions, and shifted out bits are discarded. <BR>
<P>
SEXT( x) X is sign-extended to the required size. <BR>
STORE_ CONDITIONAL If the lock_ flag is set, then do the indicated store and clear <BR>
the lock_ flag. <BR>
<P>
<B>Table 3– 7: Operators (Continued) <BR>
Operator Meaning <BR>
</B><P>
<B>Operator Meaning <BR>
</B>LT Less than signed <BR>
LTU Less than unsigned <BR>
LE Less or equal signed <BR>
LEU Less or equal unsigned <BR>
EQ Equal signed and unsigned <BR>
NE Not equal signed and unsigned <BR>
GE Greater or equal signed <BR>
GEU Greater or equal unsigned <BR>
GT Greater signed <BR>
GTU Greater unsigned <BR>
LBC Low bit clear <BR>
LBS Low bit signed 
49
<BR>
<A href=#page49>49</A>
<strong><A name=page50> Page 50</A></strong>
<A href=#page51>51</A>
<BR>
<B>3– 10 </B>Alpha Architecture Handbook <BR>
<B>3.2. 4 Notation Conventions <BR>
</B>The following conventions are used: <BR>
<P>
<B>° </B>Only operands that appear on the left side of a replacement operator are modified. <BR>
<B>° </B>No operator precedence is assumed other than that replacement (¬) has the lowest pre-cedence. Explicit precedence is indicated by the use of "{}". <BR>
<P>
<B>° </B>All arithmetic, logical, and relational operators are defined in the context of their oper-ands. For example, "+" applied to G_ floating operands means a G_ floating add, <BR>
whereas "+" applied to quadword operands is an integer add. Similarly, "LT" is a <BR>
G_ floating comparison when applied to G_ floating operands and an integer comparison <BR>
when applied to quadword operands. <BR>
<P>
<B>3.3 Instruction Formats <BR>
</B>There are five basic Alpha instruction formats: <BR>
<B>° </B>Memory <BR>
<B>° </B>Branch <BR>
<B>° </B>Operate <BR>
<B>° </B>Floating-point Operate <BR>
<B>° </B>PALcode <BR>
All instruction formats are 32 bits long with a 6-bit major opcode field in bits &lt;31: 26&gt; of the <BR>
instruction. <BR>
<P>
Any unused register field (Ra, Rb, Fa, Fb) of an instruction must be set to a value of 31. <BR>
<P>
<B>Software Note: <BR>
</B>There are several instructions, each formatted as a memory instruction, that do not use the <BR>
Ra and/ or Rb fields. These instructions are: Memory Barrier, Fetch, Fetch_ M, Read <BR>
Process Cycle Counter, Read and Clear, Read and Set, and Trap Barrier. <BR>
<P>
TEST( x, cond) The contents of register x are tested for branch condition <BR>
(cond) true. TEST returns a Boolean value TRUE if x <BR>
bears the specified relation to 0, else FALSE is returned. <BR>
Integer and floating test conditions are drawn from the <BR>
preceding list of relational operators. <BR>
<P>
XOR Logical difference <BR>
ZEXT( x) X is zero-extended to the required size. <BR>
<P>
<B>Table 3– 7: Operators (Continued) <BR>
Operator Meaning </B>
50
<BR>
<A href=#page50>50</A>
<strong><A name=page51> Page 51</A></strong>
<A href=#page52>52</A>
<BR>
<P>
Instruction Formats <B>3– 11 <BR>
3.3. 1 Memory Instruction Format <BR>
</B>The Memory format is used to transfer data between registers and memory, to load an effec-tive <BR>
address, and for subroutine jumps. It has the format shown <A href="#page51">in Figure 3– </A>
1. <BR>
<P>
<B>Figure 3– 1: Memory Instruction Format <BR>
</B><P>
A Memory format instruction contains a 6-bit opcode field, two 5-bit register address fields, Ra <BR>
and Rb, and a 16-bit signed displacement field. <BR>
<P>
The displacement field is a byte offset. It is sign-extended and added to the contents of register <BR>
Rb to form a virtual address. Overflow is ignored in this calculation. <BR>
<P>
The virtual address is used as a memory load/ store address or a result value, depending on the <BR>
specific instruction. The virtual address (va) is computed as follows for all memory format <BR>
instructions except the load address high (LDAH): <BR>
<P>
<TT>va </TT>¬ <TT>{Rbv + SEXT( Memory_ disp)} <BR>
</TT>For LDAH the virtual address (va) is computed as follows: <BR>
<TT>va </TT>¬ <TT>{Rbv + SEXT( Memory_ disp* 65536)} <BR>
</TT><B>3.3.1.1 Memory Format Instructions with a Function Code <BR>
</B>Memory format instructions with a function code replace the memory displacement field in the <BR>
memory instruction format with a function code that designates a set of miscellaneous instruc-tions. <BR>
The format is shown <A href="#page51">in Figure 3– </A>
2. <BR>
<P>
<B>Figure 3– 2: Memory Instruction with Function Code Format <BR>
</B><P>
The memory instruction with function code format contains a 6-bit opcode field and a 16-bit <BR>
function field. Unused function codes produce UNPREDICTABLE but not UNDEFINED <BR>
results; they are not security holes. <BR>
<P>
There are two fields, Ra and Rb. The usage of those fields depends on the instruction. See <A href="#page188">Sec-tion <BR>
</A>
<A href="#page188">4.11. <BR>
</A>
<P>
0 31 26 25 21 20 16 15 <BR>
Opcode Ra Rb Memory_ disp <BR>
<P>
0 31 26 25 21 20 16 15 <BR>
Opcode Ra Rb Function 
51
<BR>
<A href=#page51>51</A>
<strong><A name=page52> Page 52</A></strong>
<A href=#page53>53</A>
<BR>
<P>
<B>3– 12 </B>Alpha Architecture Handbook <BR>
<B>3.3.1.2 Memory Format Jump Instructions <BR>
</B>For computed branch instructions (CALL, RET, JMP, JSR_ COROUTINE) the displacement <BR>
field is used to provide branch-prediction hints as described <A href="#page74">in Section 4.3. <BR>
</A>
<P>
<B>3.3. 2 Branch Instruction Format <BR>
</B>The Branch format is used for conditional branch instructions and for PC-relative subroutine <BR>
jumps. It has the format shown <A href="#page52">in Figure 3– </A>
3. <BR>
<P>
<B>Figure 3– 3: Branch Instruction Format <BR>
</B><P>
A Branch format instruction contains a 6-bit opcode field, one 5-bit register address field (Ra), <BR>
and a 21-bit signed displacement field. <BR>
<P>
The displacement is treated as a longword offset. This means it is shifted left two bits (to <BR>
address a longword boundary), sign-extended to 64 bits, and added to the updated PC to form <BR>
the target virtual address. Overflow is ignored in this calculation. The target virtual address <BR>
(va) is computed as follows: <BR>
<P>
<TT>va </TT>¬ <TT>PC + {4* SEXT( Branch_ disp)} <BR>
</TT><P>
<B>3.3. 3 Operate Instruction Format <BR>
</B>The Operate format is used for instructions that perform integer register to integer register <BR>
operations. The Operate format allows the specification of one destination operand and two <BR>
source operands. One of the source operands can be a literal constant. The Operate format in <BR>
<A href="#page52">Figure 3– 4 </A>
shows the two cases when bit &lt;12&gt; of the instruction is 0 and 1. <BR>
<P>
<B>Figure 3– 4: Operate Instruction Format <BR>
</B><P>
0 31 26 25 21 20 <BR>
Opcode Ra Branch_ disp <BR>
<P>
0 31 26 25 <BR>
0 <BR>
13 12 11 21 20 16 15 5 4 <BR>
Opcode Ra Rb SBZ Function Rc <BR>
<P>
0 31 26 25 <BR>
1 <BR>
13 12 11 21 20 5 4 <BR>
Opcode Ra LIT Function Rc 
52
<BR>
<A href=#page52>52</A>
<strong><A name=page53> Page 53</A></strong>
<A href=#page54>54</A>
<BR>
<P>
Instruction Formats <B>3– 13 <BR>
</B>An Operate format instruction contains a 6-bit opcode field and a 7-bit function code field. <BR>
Unused function codes for opcodes defined as reserved in the Version 5 Alpha architecture <BR>
specification (May 1992) produce an illegal instruction trap. Those opcodes are 01, 02, 03, 04, <BR>
05, 06, 07, 0A, 0C, 0D, 0E, 14, 19, 1B, 1D, 1E, and 1F. For other opcodes, unused function <BR>
codes produce UNPREDICTABLE but not UNDEFINED results; they are not security holes. <BR>
<P>
There are three operand fields, Ra, Rb, and Rc. <BR>
The Ra field specifies a source operand. Symbolically, the integer Rav operand is formed as <BR>
follows: <BR>
<P>
<TT>IF inst&lt; 25: 21&gt; EQ 31 THEN <BR>
Rav </TT>¬ <TT>0 <BR>
ELSE <BR>
Rav </TT>¬ <TT>Ra <BR>
END <BR>
</TT><P>
The Rb field specifies a source operand. Integer operands can specify a literal or an integer <BR>
register using bit &lt;12&gt; of the instruction. <BR>
<P>
If bit &lt;12&gt; of the instruction is 0, the Rb field specifies a source register operand. <BR>
If bit &lt;12&gt; of the instruction is 1, an 8-bit zero-extended literal constant is formed by bits <BR>
&lt;20: 13&gt; of the instruction. The literal is interpreted as a positive integer between 0 and 255 <BR>
and is zero-extended to 64 bits. Symbolically, the integer Rbv operand is formed as follows: <BR>
<P>
<TT>IF inst &lt;12&gt; EQ 1 THEN <BR>
Rbv </TT>¬ <TT>ZEXT( inst&lt; 20: 13&gt;) <BR>
ELSE <BR>
IF inst &lt;20: 16&gt; EQ 31 THEN <BR>
Rbv </TT>¬ <TT>0 <BR>
ELSE <BR>
Rbv </TT>¬ <TT>Rb <BR>
END <BR>
END <BR>
</TT><P>
The Rc field specifies a destination operand. <BR>
<P>
<B>3.3. 4 Floating-Point Operate Instruction Format <BR>
</B>The Floating-point Operate format is used for instructions that perform floating-point register <BR>
to floating-point register operations. The Floating-point Operate format allows the specifica-tion <BR>
of one destination operand and two source operands. The Floating-point Operate format is <BR>
shown in <A href="#page53">Figure 3– 5. <BR>
</A>
<P>
<B>Figure 3– 5: Floating-Point Operate Instruction Format <BR>
</B>0 31 26 25 21 20 16 15 5 4 <BR>
<P>
Opcode Fa Fb Function Fc 
53
<BR>
<A href=#page53>53</A>
<strong><A name=page54> Page 54</A></strong>
<A href=#page55>55</A>
<BR>
<P>
<B>3– 14 </B>Alpha Architecture Handbook <BR>
A Floating-point Operate format instruction contains a 6-bit opcode field and an 11-bit func-tion <BR>
field. Unused function codes for those opcodes defined as reserved in the Version 5 Alpha <BR>
architecture specification (May 1992) produce an illegal instruction trap. Those opcodes are <BR>
01, 02, 03, 04, 05, 06, 07, 14, 19, 1B, 1D, 1E, and 1F. For other opcodes, unused function <BR>
codes produce UNPREDICTABLE but not UNDEFINED results; they are not security holes. <BR>
<P>
There are three operand fields, Fa, Fb, and Fc. Each operand field specifies either an integer or <BR>
floating-point operand as defined by the instruction. <BR>
<P>
The Fa field specifies a source operand. Symbolically, the Fav operand is formed as follows: <BR>
<TT>IF inst&lt; 25: 21&gt; EQ 31 THEN <BR>
Fav </TT>¬ <TT>0 <BR>
ELSE <BR>
Fav </TT>¬ <TT>Fa <BR>
END <BR>
</TT><P>
The Fb field specifies a source operand. Symbolically, the Fbv operand is formed as follows: <BR>
<TT>IF inst&lt; 20: 16&gt; EQ 31 THEN <BR>
Fbv </TT>¬ <TT>0 <BR>
ELSE <BR>
Fbv </TT>¬ <TT>Fb <BR>
END <BR>
</TT><P>
<B>Note: <BR>
</B>Neither Fa nor Fb can be a literal in Floating-point Operate instructions. <BR>
<P>
The Fc field specifies a destination operand. <BR>
<B>3.3.4.1 Floating-Point Convert Instructions <BR>
</B>Floating-point Convert instructions use a subset of the Floating-point Operate format and per-form <BR>
register-to-register conversion operations. The Fb operand specifies the source; the Fa <BR>
field must be F31. <BR>
<P>
<B>3.3.4.2 Floating-Point/ Integer Register Moves <BR>
</B>Instructions that move data between a floating-point register file and an integer register file are <BR>
a subset of of the Floating-point Operate format. The unused source field must be 31. <BR>
<P>
<B>3.3. 5 PALcode Instruction Format <BR>
</B>The Privileged Architecture Library (PALcode) format is used to specify extended processor <BR>
functions. It has the format shown <A href="#page55">in Figure 3– </A>
6. 
54
<BR>
<A href=#page54>54</A>
<strong><A name=page55> Page 55</A></strong>
<A href=#page56>56</A>
<BR>
Instruction Formats <B>3– 15 <BR>
Figure 3– 6: PALcode Instruction Format <BR>
</B>The 26-bit PALcode function field specifies the operation. The source and destination oper-ands <BR>
for PALcode instructions are supplied in fixed registers that are specified in the individual <BR>
instruction descriptions. <BR>
<P>
An opcode of zero and a PALcode function of zero specify the HALT instruction. <BR>
<P>
0 31 26 25 <BR>
Opcode PALcode Function 
55
<BR>
<A href=#page55>55</A>
<strong><A name=page56> Page 56</A></strong>
<A href=#page57>57</A>
<BR>

56
<BR>
<A href=#page56>56</A>
<strong><A name=page57> Page 57</A></strong>
<A href=#page58>58</A>
<BR>
<P>
Instruction Descriptions <B>4– 1 <BR>
Chapter 4 <BR>
Instruction Descriptions <BR>
</B><P>
<B>4. 1 Instruction Set Overview <BR>
</B>This chapter describes the instructions implemented by the Alpha architecture. The instruction <BR>
set is divided into the following sections: <BR>
<P>
Within each major section, closely related instructions are combined into groups and described <BR>
together. <BR>
<P>
The instruction group description is composed of the following: <BR>
<B>° </B>The group name <BR>
<B>° </B>The format of each instruction in the group, which includes the name, access type, and data type of each instruction operand <BR>
<P>
<B>° </B>The operation of the instruction <BR>
<B>° </B>Exceptions specific to the instruction <BR>
<B>° </B>The instruction mnemonic and name of each instruction in the group <BR>
<P>
<B>Instruction Type Section <BR>
</B>Integer load and store <A href="#page60">4. 2 <BR>
</A>
Integer control <A href="#page74">4.3 <BR>
</A>
Integer arithmetic <A href="#page80">4.4 <BR>
</A>
Logical and shift <A href="#page97">4. 5 <BR>
</A>
Byte manipulation <A href="#page103">4. 6 <BR>
</A>
Floating-point load and store <A href="#page118">4.7 <BR>
</A>
Floating-point control <A href="#page146">4.8 <BR>
</A>
Floating-point branch <A href="#page155">4.9 <BR>
</A>
Floating-point operate <A href="#page158">4.10 <BR>
</A>
Miscellaneous <A href="#page188">4. 11 <BR>
</A>
VAX compatibility <A href="#page205">4.12 <BR>
</A>
Multimedia (graphics and video) <A href="#page207">4.13 
57
<BR>
<A href=#page57>57</A>
<strong><A name=page58> Page 58</A></strong>
<A href=#page59>59</A>
<BR>
</A>
<B>4– 2 </B>Alpha Architecture Handbook <BR>
<B>° </B>Qualifiers specific to the instructions in the group <BR>
<B>° </B>A description of the instruction operation <BR>
<B>° </B>Optional programming examples and optional notes on the instruction <BR>
<P>
<B>4.1. 1 Subsetting Rules <BR>
</B>An instruction that is omitted in a subset implementation of the Alpha architecture is not per-formed <BR>
in either hardware or PALcode. System software may provide emulation routines for <BR>
subsetted instructions. <BR>
<P>
<B>4.1. 2 Floating-Point Subsets <BR>
</B>Floating-point support is optional on an Alpha processor. An implementation that supports <BR>
floating-point must implement the following: <BR>
<P>
<B>° </B>The 32 floating-point registers <BR>
<B>° </B>The Floating-point Control Register (FPCR) and the instructions to access it <BR>
<B>° </B>The floating-point branch instructions <BR>
<B>° </B>The floating-point copy sign (CPYSx) instructions <BR>
<B>° </B>The floating-point convert instructions <BR>
<B>° </B>The floating-point conditional move instruction (FCMOV) <BR>
<B>° </B>The S_ floating and T_ floating memory operations <BR>
<P>
<B>Software Note: <BR>
</B>A system that will not support floating-point operations is still required to provide the 32 <BR>
floating-point registers, the Floating-point Control Register (FPCR) and the instructions to <BR>
access it, and the T_ floating memory operations if the system intends to support the <BR>
OpenVMS Alpha operating system. This requirement facilitates the implementation of a <BR>
floating-point emulator and simplifies context-switching. <BR>
<P>
In addition, floating-point support requires at least one of the following subset groups: <BR>
1. VAX Floating-point Operate and Memory instructions (F_ and G_ floating). <BR>
2. IEEE Floating-point Operate instructions (S_ and T_ floating). Within this group, an implementation can choose to include or omit separately the ability to perform IEEE <BR>
<P>
rounding to plus infinity and minus infinity. <BR>
<P>
<B>Note: <BR>
</B>If one instruction in a group is provided, all other instructions in that group must be <BR>
provided. An implementation with full floating-point support includes both groups; a <BR>
subset floating-point implementation supports only one of these groups. The individual <BR>
instruction descriptions indicate whether an instruction can be subsetted. 
58
<BR>
<A href=#page58>58</A>
<strong><A name=page59> Page 59</A></strong>
<A href=#page60>60</A>
<BR>
<P>
Instruction Descriptions <B>4– 3 <BR>
4.1. 3 Software Emulation Rules <BR>
</B>General-purpose layered and application software that executes in User mode may assume that <BR>
certain loads (LDL, LDQ, LDF, LDG, LDS, and LDT) and certain stores (STL, STQ, STF, <BR>
STG, STL, and STT) of unaligned data are emulated by system software. General-purpose lay-ered <BR>
and application software that executes in User mode may assume that subsetted <BR>
instructions are emulated by system software. Frequent use of emulation may be significantly <BR>
slower than using alternative code sequences. <BR>
<P>
Emulation of loads and stores of unaligned data and subsetted instructions need not be pro-vided <BR>
in privileged access modes. System software that supports special-purpose dedicated <BR>
applications need not provide emulation in User mode if emulation is not needed for correct <BR>
execution of the special-purpose applications. <BR>
<P>
<B>4.1. 4 Opcode Qualifiers <BR>
</B>Some Operate format and Floating-point Operate format instructions have several variants. For <BR>
example, for the VAX formats, Add F_ floating (ADDF) is supported with and without float-ing <BR>
underflow enabled and with either chopped or VAX rounding. For IEEE formats, IEEE <BR>
unbiased rounding, chopped, round toward plus infinity, and round toward minus infinity can <BR>
be selected. <BR>
<P>
The different variants of such instructions are denoted by opcode qualifiers, which consist of a <BR>
slash (/) followed by a string of selected qualifiers. Each qualifier is denoted by a single char-acter <BR>
as shown in <A href="#page59">Table 4– 1. </A>
The opcodes for each qualifier are listed in <A href="#page303">Appendix </A>
C. <BR>
<P>
The default values are normal rounding, exception completion disabled, inexact result dis-abled, <BR>
floating underflow disabled, and integer overflow disabled. <BR>
<P>
<B>Table 4– 1: Opcode Qualifiers <BR>
Qualifier Meaning <BR>
</B>C Chopped rounding <BR>
D Rounding mode dynamic <BR>
M Round toward minus infinity <BR>
I Inexact result enable <BR>
S Exception completion enable <BR>
U Floating underflow enable <BR>
V Integer overflow enable 
59
<BR>
<A href=#page59>59</A>
<strong><A name=page60> Page 60</A></strong>
<A href=#page61>61</A>
<BR>
<P>
<B>4– 4 </B>Alpha Architecture Handbook <BR>
<B>4. 2 Memory Integer Load/ Store Instructions <BR>
</B>The instructions in this section move data between the integer registers and memory. <BR>
They use the Memory instruction format. The instructions are summarized <A href="#page60">in Table 4– </A>
2. <BR>
<B>Table 4– 2: Memory Integer Load/ Store Instructions <BR>
Mnemonic Operation <BR>
</B>LDA Load Address <BR>
LDAH Load Address High <BR>
<P>
LDBU Load Zero-Extended Byte from Memory to Register <BR>
LDL Load Sign-Extended Longword <BR>
LDL_ L Load Sign-Extended Longword Locked <BR>
LDQ Load Quadword <BR>
LDQ_ L Load Quadword Locked <BR>
LDQ_ U Load Quadword Unaligned <BR>
LDWU Load Zero-Extended Word from Memory to Register <BR>
<P>
STB Store Byte <BR>
STL Store Longword <BR>
STL_ C Store Longword Conditional <BR>
STQ Store Quadword <BR>
STQ_ C Store Quadword Conditional <BR>
STQ_ U Store Quadword Unaligned <BR>
STW Store Word 
60
<BR>
<A href=#page60>60</A>
<strong><A name=page61> Page 61</A></strong>
<A href=#page62>62</A>
<BR>
Instruction Descriptions <B>4– 5 <BR>
4. 2.1 Load Address <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Ra </TT>¬ <TT>Rbv + SEXT( disp) !LDA <BR>
Ra </TT>¬ <TT>Rbv + SEXT( disp* 65536) !LDAH <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>The virtual address is computed by adding register Rb to the sign-extended 16-bit displace-ment <BR>
for LDA, and 65536 times the sign-extended 16-bit displacement for LDAH. The 64-bit <BR>
result is written to register Ra. <BR>
<P>
LDAx Ra. wq, disp. ab( Rb. ab) !Memory format <BR>
None <BR>
LDA Load Address <BR>
LDAH Load Address High <BR>
<P>
None 
61
<BR>
<A href=#page61>61</A>
<strong><A name=page62> Page 62</A></strong>
<A href=#page63>63</A>
<BR>
<B>4– 6 </B>Alpha Architecture Handbook <BR>
<B>4.2. 2 Load Memory Data into Integer Register <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>va </TT>¬ <TT>{Rbv + SEXT( disp)} <BR>
</TT><P>
<TT>CASE <BR>
big_ endian_ data: va' </TT>¬ <TT>va XOR 000 2 !LDQ <BR>
</TT><P>
<TT>big_ endian_ data: va' </TT>¬ <TT>va XOR 100 2 !LDL <BR>
big_ endian_ data: va' </TT>¬ <TT>va XOR 110 2 !LDWU <BR>
big_ endian_ data: va' </TT>¬ <TT>va XOR 111 2 !LDBU <BR>
little_ endian_ data: va' </TT>¬ <TT>va <BR>
ENDCASE <BR>
</TT><P>
<TT>Ra </TT>¬ <TT>(va')&lt; 63: 0&gt; !LDQ <BR>
Ra </TT>¬ <TT>SEXT(( va')&lt; 31: 0&gt;) !LDL <BR>
Ra </TT>¬ <TT>ZEXT(( va')&lt; 15: 0&gt;) !LDWU <BR>
Ra </TT>¬ <TT>ZEXT(( va')&lt; 07: 0&gt;) !LDBU <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>The virtual address is computed by adding register Rb to the sign-extended 16-bit displace-ment. <BR>
For a big-endian access, the indicated bits are inverted, and any memory management <BR>
fault is reported for va (not va'). <BR>
<P>
LDx Ra. wq, disp. ab( Rb. ab) !Memory format <BR>
Access Violation <BR>
Alignment <BR>
Fault on Read <BR>
Translation Not Valid <BR>
<P>
LDBU Load Zero-Extended Byte from Memory to Register <BR>
LDL Load Sign-Extended Longword from Memory to Register <BR>
LDQ Load Quadword from Memory to Register <BR>
LDWU Load Zero-Extended Word from Memory to Register <BR>
<P>
None 
62
<BR>
<A href=#page62>62</A>
<strong><A name=page63> Page 63</A></strong>
<A href=#page64>64</A>
<BR>
Instruction Descriptions <B>4– 7 <BR>
</B>In the case of LDQ and LDL, the source operand is fetched from memory, sign-extended, and <BR>
written to register Ra. <BR>
<P>
In the case of LDWU and LDBU, the source operand is fetched from memory, zero-extended, <BR>
and written to register Ra. <BR>
<P>
In all cases, if the data is not naturally aligned, an alignment exception is generated. <BR>
<P>
<B>Notes: <BR>
° </B>The word or byte that the LDWU or LDBU instruction fetches from memory is placed in the low (rightmost) word or byte of Ra, with the remaining 6 or 7 bytes set to zero. <BR>
<P>
<B>° </B>Accesses have byte granularity. <BR>
<B>° </B>For big-endian access with LDWU or LDBU, the word/ byte remains in the rightmost part of Ra, but the va sent to memory has the indicated bits inverted. See Operation sec-tion, <BR>
<P>
above. <BR>
<B>° </B>No sparse address space mechanisms are allowed with the LDWU and LDBU instruc-tions. <BR>
<P>
<B>Implementation Notes: <BR>
° </B>The LDWU and LDBU instructions are supported in hardware on Alpha implementa-tions for which the AMASK instruction returns bit 0 set. LDWU and LDBU are sup-ported <BR>
<P>
with software emulation in Alpha implementations for which AMASK does not <BR>
return bit 0 set. Software emulation of LDWU and LDBU is significantly slower than <BR>
hardware support. <BR>
<P>
<B>° </B>Depending on an address space region's caching policy, implementations may read a (partial) cache block in order to do word/ byte stores. This may only be done in regions <BR>
<P>
that have memory-like behavior. <BR>
<B>° </B>Implementations are expected to provide sufficient low-order address bits and length-of-access information to devices on I/ O buses. But, strictly speaking, this is out-side <BR>
<P>
the scope of architecture. 
63
<BR>
<A href=#page63>63</A>
<strong><A name=page64> Page 64</A></strong>
<A href=#page65>65</A>
<BR>
<B>4– 8 </B>Alpha Architecture Handbook <BR>
<B>4.2. 3 Load Unaligned Memory Data into Integer Register <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>va </TT>¬ <TT>{{ Rbv + SEXT( disp)} AND NOT 7} <BR>
Ra </TT>¬ <TT>(va)&lt; 63: 0&gt; <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>The virtual address is computed by adding register Rb to the sign-extended 16-bit displace-ment, <BR>
then the low-order three bits are cleared. The source operand is fetched from memory <BR>
and written to register Ra. <BR>
<P>
LDQ_ U Ra. wq, disp. ab( Rb. ab) !Memory format <BR>
Access Violation <BR>
Fault on Read <BR>
Translation Not Valid <BR>
<P>
LDQ_ U Load Unaligned Quadword from Memory to Register <BR>
None 
64
<BR>
<A href=#page64>64</A>
<strong><A name=page65> Page 65</A></strong>
<A href=#page66>66</A>
<BR>
Instruction Descriptions <B>4– 9 <BR>
4.2. 4 Load Memory Data into Integer Register Locked <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>va </TT>¬ <TT>{Rbv + SEXT( disp)} <BR>
</TT><P>
<TT>CASE <BR>
big_ endian_ data: va' </TT>¬ <TT>va XOR 000 2 ! LDQ_ L <BR>
</TT><P>
<TT>big_ endian_ data: va' </TT>¬ <TT>va XOR 100 2 ! LDL_ L <BR>
little_ endian_ data: va' </TT>¬ <TT>va ! LDL_ L <BR>
ENDCASE <BR>
</TT><P>
<TT>lock_ flag </TT>¬ <TT>1 <BR>
locked_ physical_ address </TT>¬ <TT>PHYSICAL_ ADDRESS( va) <BR>
</TT><P>
<TT>Ra </TT>¬ <TT>SEXT(( va')&lt; 31: 0&gt;) ! LDL_ L <BR>
Ra </TT>¬ <TT>(va)&lt; 63: 0&gt; ! LDQ_ L <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>The virtual address is computed by adding register Rb to the sign-extended 16-bit displace-ment. <BR>
For a big-endian longword access, va&lt; 2&gt; (bit 2 of the virtual address) is inverted, and <BR>
any memory management fault is reported for va (not va'). The source operand is fetched <BR>
from memory, sign-extended for LDL_ L, and written to register Ra. <BR>
<P>
LDx_ L Ra. wq, disp. ab( Rb. ab) !Memory format <BR>
Access Violation <BR>
Alignment <BR>
Fault on Read <BR>
Translation Not Valid <BR>
<P>
LDL_ L Load Sign-Extended Longword from Memory to Register <BR>
Locked <BR>
<P>
LDQ_ L Load Quadword from Memory to Register Locked <BR>
<P>
None 
65
<BR>
<A href=#page65>65</A>
<strong><A name=page66> Page 66</A></strong>
<A href=#page67>67</A>
<BR>
<P>
<B>4– 10 </B>Alpha Architecture Handbook <BR>
When a LDx_ L instruction is executed without faulting, the processor records the target physi-cal <BR>
address in a per-processor locked_ physical_ address register and sets the per-processor <BR>
lock_ flag. <BR>
<P>
If the per-processor lock_ flag is (still) set when a STx_ C instruction is executed (accessing <BR>
within the same 16-byte naturally aligned block as the LDx_ L), the store occurs; otherwise, it <BR>
does not occur, as described for the STx_ C instructions. The behavior of an STx_ C instruction <BR>
is UNPREDICTABLE, as described in <A href="#page68">Section 4.2.5, </A>
when it does not access the same 16-byte <BR>
naturally aligned block as the LDx_ L. <BR>
<P>
Processor <I>A </I>causes the clearing of a set lock_ flag in processor <I>B </I>by doing any of the following <BR>
in <I>B's </I>locked range of physical addresses: a successful store, a successful store_ conditional, or <BR>
executing a WH64 instruction that modifies data on processor <I>B. </I>A processor's locked range is <BR>
the aligned block of 2** N bytes that includes the locked_ physical_ address. The 2** N value is <BR>
implementation dependent. It is at least 16 (minimum lock range is an aligned 16-byte block) <BR>
and is at most the page size for that implementation (maximum lock range is one physical <BR>
page). <BR>
<P>
A processor's lock_ flag is also cleared if that processor encounters a CALL_ PAL REI, <BR>
CALL_ PAL rti, or CALL_ PAL rfe instruction. It is UNPREDICTABLE whether or not a pro-cessor's <BR>
lock_ flag is cleared on any other CALL_ PAL instruction. It is UNPREDICTABLE <BR>
whether a processor's lock_ flag is cleared by that processor executing a normal load or store <BR>
instruction. It is UNPREDICTABLE whether a processor's lock_ flag is cleared by that proces-sor <BR>
executing a taken branch (including BR, BSR, and Jumps); conditional branches that fall <BR>
through do not clear the lock_ flag. It is UNPREDICTABLE whether a processor's lock_ flag is <BR>
cleared by that processor executing a WH64 or ECB instruction. <BR>
<P>
The sequence: <BR>
LDx_ L <BR>
Modify <BR>
STx_ C <BR>
BEQ xxx <BR>
<P>
when executed on a given processor, does an atomic read-modify-write of a datum in shared <BR>
memory if the branch falls through. If the branch is taken, the store did not modify memory <BR>
and the sequence may be repeated until it succeeds. <BR>
<P>
<B>Notes: <BR>
° </B>LDx_ L instructions do not check for write access; hence a matching STx_ C may take an access-violation or fault-on-write exception. <BR>
<P>
Executing a LDx_ L instruction on one processor does not affect any architecturally <BR>
visible state on another processor, and in particular cannot cause an STx_ C on another <BR>
processor to fail. <BR>
<P>
LDx_ L and STx_ C instructions need not be paired. In particular, an LDx_ L may be <BR>
followed by a conditional branch: on the fall-through path an STx_ C is executed, <BR>
whereas on the taken path no matching STx_ C is executed. 
66
<BR>
<A href=#page66>66</A>
<strong><A name=page67> Page 67</A></strong>
<A href=#page68>68</A>
<BR>
Instruction Descriptions <B>4– 11 <BR>
</B>If two LDx_ L instructions execute with no intervening STx_ C, the second one <BR>
overwrites the state of the first one. If two STx_ C instructions execute with no <BR>
intervening LDx_ L, the second one always fails because the first clears lock_ flag. <BR>
<P>
<B>° </B>Software will not emulate unaligned LDx_ L instructions. <BR>
<B>° </B>If the virtual and physical addresses for a LDx_ L and STx_ C sequence are not within the same naturally aligned 16-byte sections of virtual and physical memory, that <BR>
<P>
sequence may always fail, or may succeed despite another processor's store to the lock <BR>
range; hence, no useful program should do this. <BR>
<P>
<B>° </B>If any other memory access (ECB, LDx, LDQ_ U, STx, STQ_ U, WH64) is executed on the given processor between the LDx_ L and the STx_ C, the sequence above may <BR>
<P>
always fail on some implementations; hence, no useful program should do this. <BR>
<B>° </B>If a branch is taken between the LDx_ L and the STx_ C, the sequence above may always fail on some implementations; hence, no useful program should do this. <BR>
<P>
(CMOVxx may be used to avoid branching.) <BR>
<B>° </B>If a subsetted instruction (for example, floating-point) is executed between the LDx_ L and the STx_ C, the sequence above may always fail on some implementations because <BR>
<P>
of the Illegal Instruction Trap; hence, no useful program should do this. <BR>
<B>° </B>If an instruction with an unused function code is executed between the LDx_ L and the STx_ C, the sequence above may always fail on some implementations because an <BR>
<P>
instruction with an unused function code is UNPREDICTABLE. <BR>
<B>° </B>If a large number of instructions are executed between the LDx_ L and the STx_ C, the sequence above may always fail on some implementations because of a timer interrupt <BR>
<P>
always clearing the lock_ flag before the sequence completes; hence, no useful program <BR>
should do this. <BR>
<P>
<B>° </B>Hardware implementations are encouraged to lock no more than 128 bytes. Software implementations are encouraged to separate locked locations by at least 128 bytes from <BR>
<P>
other locations that could potentially be written by another processor while the first <BR>
location is locked. <BR>
<P>
<B>° </B>Execution of a WH64 instruction on processor <I>A </I>to a region within the lock range of processor <I>B, </I>where the execution of the WH64 changes the contents of memory, causes <BR>
<P>
the lock_ flag on processor <I>B </I>to be cleared. If the WH64 does not change the contents of <BR>
memory on processor <I>B, </I>it need not clear the lock_ flag. <BR>
<P>
<B>Implementation Notes: <BR>
</B>Implementations that impede the mobility of a cache block on LDx_ L, such as that which <BR>
may occur in a Read for Ownership cache coherency protocol, may release the cache block <BR>
and make the subsequent STx_ C fail if a branch-taken or memory instruction is executed <BR>
on that processor. <BR>
<P>
All implementations should guarantee that at least 40 non-subsetted operate instructions <BR>
can be executed between timer interrupts. 
67
<BR>
<A href=#page67>67</A>
<strong><A name=page68> Page 68</A></strong>
<A href=#page69>69</A>
<BR>
<B>4– 12 </B>Alpha Architecture Handbook <BR>
<B>4.2. 5 Store Integer Register Data into Memory Conditional <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>va </TT>¬ <TT>{Rbv + SEXT( disp)} <BR>
</TT><P>
<TT>CASE <BR>
big_ endian_ data: va' </TT>¬ <TT>va XOR 000 2 ! STQ_ C <BR>
</TT><P>
<TT>big_ endian_ data: va' </TT>¬ <TT>va XOR 100 2 ! STL_ C <BR>
little_ endian_ data: va' </TT>¬ <TT>va ! STL_ C <BR>
ENDCASE <BR>
</TT><P>
<TT>IF lock_ flag EQ 1 THEN <BR>
(va')&lt; 31: 0&gt; </TT>¬ <TT>Rav&lt; 31: 0&gt; ! STL_ C <BR>
(va') </TT>¬ <TT>Rav ! STQ_ C <BR>
Ra </TT>¬ <TT>lock_ flag <BR>
lock_ flag </TT>¬ <TT>0 <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>The virtual address is computed by adding register Rb to the sign-extended 16-bit displace-ment. <BR>
For a big-endian longword access, va&lt; 2&gt; (bit 2 of the virtual address) is inverted, and <BR>
any memory management fault is reported for va (not va'). <BR>
<P>
If the lock_ flag is set and the address meets the following constraints relative to the address <BR>
specified by the preceding LDx_ L instruction, the Ra operand is written to memory at this <BR>
address. If the address meets the following constraints but the lock_ flag is not set, a zero is <BR>
returned in Ra and no write to memory occurs. The constraints are: <BR>
<P>
STx_ C Ra. mx, disp. ab( Rb. ab) !Memory format <BR>
Access Violation <BR>
Fault on Write <BR>
Alignment <BR>
Translation Not Valid <BR>
<P>
STL_ C Store Longword from Register to Memory Conditional <BR>
STQ_ C Store Quadword from Register to Memory Conditional <BR>
<P>
None 
68
<BR>
<A href=#page68>68</A>
<strong><A name=page69> Page 69</A></strong>
<A href=#page70>70</A>
<BR>
<P>
Instruction Descriptions <B>4– 13 <BR>
° </B>The computed virtual address must specify a location within the naturally aligned 16-byte block in virtual memory accessed by the preceding LDx_ L instruction. <BR>
<B>° </B>The resultant physical address must specify a location within the naturally aligned 16-byte block in physical memory accessed by the preceding LDx_ L instruction. <BR>
If those addressing constraints are not met, it is UNPREDICTABLE whether the STx_ C <BR>
instruction succeeds or fails, regardless of the state of the lock_ flag, unless the lock_ flag is <BR>
cleared as described in the next paragraph. <BR>
<P>
Whether or not the addressing constraints are met, a zero is returned and no write to memory <BR>
occurs if the lock_ flag was cleared by execution on a processor of a CALL_ PAL REI, <BR>
CALL_ PAL rti, CALL_ PAL rfe, or STx_ C, after the most recent execution on that processor <BR>
of a LDx_ L instruction (in processor issue sequence). <BR>
<P>
In all cases, the lock_ flag is set to zero at the end of the operation. <BR>
<P>
<B>Notes: <BR>
° </B>Software will not emulate unaligned STx_ C instructions. <BR>
<B>° </B>Each implementation must do the test and store atomically, as illustrated in the follow-ing two examples. <A href="#page222">(See Section 5.6. 1 </A>
for complete information.) <BR>
<P>
– If two processors attempt STx_ C instructions to the same lock range and that lock <BR>
range was accessed by both processors' preceding LDx_ L instructions, exactly one <BR>
of the stores succeeds. <BR>
<P>
– A processor executes a LDx_ L/ STx_ C sequence and includes an MB between the <BR>
LDx_ L to a particular address and the <I>successful </I>STx_ C to a different address (one <BR>
that meets the constraints required for predictable behavior). That instruction <BR>
sequence establishes an access order under which a store operation by another pro-cessor <BR>
to that lock range occurs before the LDx_ L or after the STx_ C. <BR>
<P>
<B>° </B>If the virtual and physical addresses for a LDx_ L and STx_ C sequence are not within the same naturally aligned 16-byte sections of virtual and physical memory, that <BR>
<P>
sequence may always fail, or may succeed despite another processor's store to the lock <BR>
range; hence, no useful program should do this. <BR>
<P>
<B>° </B>The following sequence should not be used: <BR>
<TT>try_ again: LDQ_ L R1, x <BR>
&lt;modify R1&gt; <BR>
STQ_ C R1, x <BR>
BEQ R1, try_ again <BR>
</TT><P>
That sequence penalizes performance when the STQ_ C succeeds, because the <BR>
sequence contains a backward branch, which is predicted to be taken in the Alpha <BR>
architecture. In the case where the STQ_ C succeeds and the branch will actually fall <BR>
through, that sequence incurs unnecessary delay due to a mispredicted backward <BR>
branch. Instead, a forward branch should be used to handle the failure case, as shown <BR>
in <A href="#page218">Section 5.5.2. 
69
<BR>
<A href=#page69>69</A>
<strong><A name=page70> Page 70</A></strong>
<A href=#page71>71</A>
<BR>
</A>
<B>4– 14 </B>Alpha Architecture Handbook <BR>
<B>Software Note: <BR>
</B>If the address specified by a STx_ C instruction does not match the one given in the <BR>
preceding LDx_ L instruction, an MB is required to guarantee ordering between the two <BR>
instructions. <BR>
<P>
<B>Hardware/ Software Implementation Note: <BR>
</B>STQ_ C is used in the first Alpha implementations to access the MailBox Pointer Register <BR>
(MBPR). In this special case, the effect of the STQ_ C is well defined (that is, not <BR>
UNPREDICTABLE) even though the preceding LDx_ L did not specify the address of the <BR>
MBPR. The effect of STx_ C in this special case may vary from implementation to <BR>
implementation. <BR>
<P>
<B>Implementation Notes: <BR>
</B>A STx_ C must propagate to the point of coherency, where it is guaranteed to prevent any <BR>
other store from changing the state of the lock bit, before its outcome can be determined. <BR>
<P>
If an implementation could encounter a TB or cache miss on the data reference of the <BR>
STx_ C in the sequence above (as might occur in some shared I-and D-stream <BR>
direct-mapped TBs/ caches), it must be able to resolve the miss and complete the store <BR>
without always failing. 
70
<BR>
<A href=#page70>70</A>
<strong><A name=page71> Page 71</A></strong>
<A href=#page72>72</A>
<BR>
Instruction Descriptions <B>4– 15 <BR>
4.2. 6 Store Integer Register Data into Memory <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>va </TT>¬ <TT>{Rbv + SEXT( disp)} <BR>
</TT><P>
<TT>CASE <BR>
big_ endian_ data: va' </TT>¬ <TT>va XOR 000 2 !STQ <BR>
</TT><P>
<TT>big_ endian_ data: va' </TT>¬ <TT>va XOR 100 2 !STL <BR>
big_ endian_ data: va' </TT>¬ <TT>va XOR 110 2 !STW <BR>
big_ endian_ data: va' </TT>¬ <TT>va XOR 111 2 !STB <BR>
little_ endian_ data: va' </TT>¬ <TT>va <BR>
ENDCASE <BR>
</TT><P>
<TT>(va') </TT>¬ <TT>Rav !STQ <BR>
(va')&lt; 31: 00&gt; </TT>¬ <TT>Rav&lt; 31: 0&gt; !STL <BR>
(va')&lt; 15: 00&gt; </TT>¬ <TT>Rav&lt; 15: 0&gt; !STW <BR>
(va')&lt; 07: 00&gt; </TT>¬ <TT>Rav&lt; 07: 0&gt; !STB <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: </B>The virtual address is computed by adding register Rb to the sign-extended 16-bit displace-ment. <BR>
For a big-endian access, the indicated bits are inverted, and any memory management <BR>
fault is reported for va (not va'). <BR>
<P>
STx Ra. rx, disp. ab( Rb. ab) !Memory format <BR>
Access Violation <BR>
Alignment <BR>
Fault on Write <BR>
Translation Not Valid <BR>
<P>
STB Store Byte from Register to Memory <BR>
STL Store Longword from Register to Memory <BR>
STQ Store Quadword from Register to Memory <BR>
STW Store Word from Register to Memory <BR>
<P>
None 
71
<BR>
<A href=#page71>71</A>
<strong><A name=page72> Page 72</A></strong>
<A href=#page73>73</A>
<BR>
<B>4– 16 </B>Alpha Architecture Handbook <BR>
The Ra operand is written to memory at this address. If the data is not naturally aligned, an <BR>
alignment exception is generated. <BR>
<P>
<B>Notes: <BR>
° </B>The word or byte that the STB or STW instruction stores to memory comes from the low (rightmost) byte or word of Ra. <BR>
<P>
<B>° </B>Accesses have byte granularity. <BR>
<B>° </B>For big-endian access with STB or STW, the byte/ word remains in the rightmost part of Ra, but the va sent to memory has the indicated bits inverted. See Operation section, <BR>
<P>
above. <BR>
<B>° </B>No sparse address space mechanisms are allowed with the STB and STW instructions. <BR>
<P>
<B>Implementation Notes: <BR>
° </B>The STB and STW instructions are supported in hardware on Alpha implementations for which the AMASK instruction returns bit 0 set. STB and STW are supported with <BR>
<P>
software emulation in Alpha implementations for which AMASK does not return bit 0 <BR>
set. Software emulation of STB and STW is significantly slower than hardware support. <BR>
<P>
<B>° </B>Depending on an address space region's caching policy, implementations may read a (partial) cache block in order to do byte/ word stores. This may only be done in regions <BR>
<P>
that have memory-like behavior. <BR>
<B>° </B>Implementations are expected to provide sufficient low-order address bits and length-of-access information to devices on I/ O buses. But, strictly speaking, this is out-side <BR>
<P>
the scope of architecture. 
72
<BR>
<A href=#page72>72</A>
<strong><A name=page73> Page 73</A></strong>
<A href=#page74>74</A>
<BR>
Instruction Descriptions <B>4– 17 <BR>
4.2. 7 Store Unaligned Integer Register Data into Memory <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>va </TT>¬ <TT>{{ Rbv + SEXT( disp)} AND NOT 7} <BR>
(va)&lt; 63: 0&gt; </TT>¬ <TT>Rav&lt; 63: 0&gt; <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>The virtual address is computed by adding register Rb to the sign-extended 16-bit displace-ment, <BR>
then clearing the low order three bits. The Ra operand is written to memory at this <BR>
address. <BR>
<P>
STQ_ U Ra. rq, disp. ab( Rb. ab) !Memory format <BR>
Access Violation <BR>
Fault on Write <BR>
Translation Not Valid <BR>
<P>
STQ_ U Store Unaligned Quadword from Register to Memory <BR>
None 
73
<BR>
<A href=#page73>73</A>
<strong><A name=page74> Page 74</A></strong>
<A href=#page75>75</A>
<BR>
<P>
<B>4– 18 </B>Alpha Architecture Handbook <BR>
<B>4. 3 Control Instructions <BR>
</B>Alpha provides integer conditional branch, unconditional branch, branch to subroutine, and <BR>
jump instructions. The PC used in these instructions is the updated PC, as described in <A href="#page41">Section <BR>
</A>
<A href="#page41">3.1.1. <BR>
</A>
<P>
To allow implementations to achieve high performance, the Alpha architecture includes <BR>
explicit hints based on a branch-prediction model: <BR>
<P>
<B>° </B>For many implementations of computed branches (JSR/ RET/ JMP), there is a substan-tial performance gain in forming a good guess of the expected target I-cache address <BR>
<P>
before register Rb is accessed. <BR>
<B>° </B>For many implementations, the first-level (or only) I-cache is no bigger than a page (8 KB to 64 KB). <BR>
<P>
<B>° </B>Correctly predicting subroutine returns is important for good performance. Some implementations will therefore keep a small stack of predicted subroutine return <BR>
I-cache addresses. <BR>
The Alpha architecture provides three kinds of branch-prediction hints: likely target address, <BR>
return-address stack action, and conditional branch-taken. <BR>
<P>
For computed branches, the otherwise unused displacement field contains a function code <BR>
(JMP/ JSR/ RET/ JSR_ COROUTINE), and, for JSR and JMP, a field that statically specifies the <BR>
16 low bits of the most likely target address. The PC-relative calculation using these bits can <BR>
be exactly the PC-relative calculation used in unconditional branches. The low 16 bits are <BR>
enough to specify an I-cache block within the largest possible Alpha page and hence are <BR>
expected to be enough for branch-prediction logic to start an early I-cache access for the most <BR>
likely target. <BR>
<P>
For all branches, hint or opcode bits are used to distinguish simple branches, subroutine calls, <BR>
subroutine returns, and coroutine links. These distinctions allow branch-predict logic to main-tain <BR>
an accurate stack of predicted return addresses. <BR>
<P>
For conditional branches, the sign of the target displacement is used as a taken/ fall-through <BR>
hint. The instructions are summarized <A href="#page74">in Table 4– </A>
3. <BR>
<P>
<B>Table 4– 3: Control Instructions Summary <BR>
Mnemonic Operation <BR>
</B>BEQ Branch if Register Equal to Zero <BR>
BGE Branch if Register Greater Than or Equal to Zero <BR>
BGT Branch if Register Greater Than Zero <BR>
BLBC Branch if Register Low Bit Is Clear <BR>
BLBS Branch if Register Low Bit Is Set <BR>
BLE Branch if Register Less Than or Equal to Zero <BR>
BLT Branch if Register Less Than Zero 
74
<BR>
<A href=#page74>74</A>
<strong><A name=page75> Page 75</A></strong>
<A href=#page76>76</A>
<BR>
Instruction Descriptions <B>4– 19 <BR>
</B>BNE Branch if Register Not Equal to Zero <BR>
BR Unconditional Branch <BR>
BSR Branch to Subroutine <BR>
<P>
JMP Jump <BR>
JSR Jump to Subroutine <BR>
RET Return from Subroutine <BR>
JSR_ COROUTINE Jump to Subroutine Return <BR>
<P>
<B>Table 4– 3: Control Instructions Summary (Continued) <BR>
Mnemonic Operation </B>
75
<BR>
<A href=#page75>75</A>
<strong><A name=page76> Page 76</A></strong>
<A href=#page77>77</A>
<BR>
<B>4– 20 </B>Alpha Architecture Handbook <BR>
<B>4.3. 1 Conditional Branch <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>{update PC} <BR>
va </TT>¬ <TT>PC + {4* SEXT( disp)} <BR>
IF TEST( Rav, Condition_ based_ on_ Opcode) THEN <BR>
PC </TT>¬ <TT>va <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>Register Ra is tested. If the specified relationship is true, the PC is loaded with the target vir-tual <BR>
address; otherwise, execution continues with the next sequential instruction. <BR>
<P>
The displacement is treated as a signed longword offset. This means it is shifted left two bits <BR>
(to address a longword boundary), sign-extended to 64 bits, and added to the updated PC to <BR>
form the target virtual address. <BR>
<P>
The conditional branch instructions are PC-relative only. The 21-bit signed displacement gives <BR>
a forward/ backward branch distance of +/– 1M instructions. <BR>
<P>
The test is on the signed quadword integer interpretation of the register contents; all 64 bits are <BR>
tested. <BR>
<P>
Bxx Ra. rq, disp. al !Branch format <BR>
None <BR>
BEQ Branch if Register Equal to Zero <BR>
BGE Branch if Register Greater Than or Equal to Zero <BR>
BGT Branch if Register Greater Than Zero <BR>
BLBC Branch if Register Low Bit Is Clear <BR>
BLBS Branch if Register Low Bit Is Set <BR>
BLE Branch if Register Less Than or Equal to Zero <BR>
BLT Branch if Register Less Than Zero <BR>
BNE Branch if Register Not Equal to Zero <BR>
<P>
None 
76
<BR>
<A href=#page76>76</A>
<strong><A name=page77> Page 77</A></strong>
<A href=#page78>78</A>
<BR>
Instruction Descriptions <B>4– 21 <BR>
4.3. 2 Unconditional Branch <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>{update PC} <BR>
Ra </TT>¬ <TT>PC <BR>
PC </TT>¬ <TT>PC + {4* SEXT( disp)} <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>The PC of the following instruction (the updated PC) is written to register Ra and then the PC <BR>
is loaded with the target address. <BR>
<P>
The displacement is treated as a signed longword offset. This means it is shifted left two bits <BR>
(to address a longword boundary), sign-extended to 64 bits, and added to the updated PC to <BR>
form the target virtual address. <BR>
<P>
The unconditional branch instructions are PC-relative. The 21-bit signed displacement gives a <BR>
forward/ backward branch distance of +/– 1M instructions. <BR>
<P>
PC-relative addressability can be established by: <BR>
<TT>BR Rx, L1 <BR>
L1: <BR>
</TT><P>
<B>Notes: <BR>
° </B>BR and BSR do identical operations. They only differ in hints to possible branch-pre-diction logic. BSR is predicted as a subroutine call (pushes the return address on a <BR>
<P>
branch-prediction stack), whereas BR is predicted as a branch (no push). <BR>
<P>
BxR Ra. wq, disp. al !Branch format <BR>
None <BR>
BR Unconditional Branch <BR>
BSR Branch to Subroutine <BR>
<P>
None 
77
<BR>
<A href=#page77>77</A>
<strong><A name=page78> Page 78</A></strong>
<A href=#page79>79</A>
<BR>
<P>
<B>4– 22 </B>Alpha Architecture Handbook <BR>
<B>4.3. 3 Jumps <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>{update PC} <BR>
va </TT>¬ <TT>Rbv AND {NOT 3} <BR>
Ra </TT>¬ <TT>PC <BR>
PC </TT>¬ <TT>va <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>The PC of the instruction following the Jump instruction (the updated PC) is written to register <BR>
Ra and then the PC is loaded with the target virtual address. <BR>
<P>
The new PC is supplied from register Rb. The low two bits of Rb are ignored. Ra and Rb may <BR>
specify the same register; the target calculation using the old value is done before the new <BR>
value is assigned. <BR>
<P>
All Jump instructions do identical operations. They only differ in hints to possible branch-pre-diction <BR>
logic. The displacement field of the instruction is used to pass this information. The <BR>
four different "opcodes" set different bit patterns in disp&lt; 15: 14&gt;, and the hint operand sets <BR>
disp&lt; 13: 0&gt;. <BR>
<P>
These bits are intended to be used as shown <A href="#page79">in Table 4– </A>
4. <BR>
<P>
mnemonic Ra. wq,( Rb. ab), hint !Memory format <BR>
None <BR>
JMP Jump <BR>
JSR Jump to Subroutine <BR>
RET Return from Subroutine <BR>
JSR_ COROUTINE Jump to Subroutine Return <BR>
<P>
None 
78
<BR>
<A href=#page78>78</A>
<strong><A name=page79> Page 79</A></strong>
<A href=#page80>80</A>
<BR>
<P>
Instruction Descriptions <B>4– 23 <BR>
</B>The design in <A href="#page79">Table 4– 4 </A>
allows specification of the low 16 bits of a likely longword target <BR>
address (enough bits to start a useful I-cache access early), and also allows distinguishing call <BR>
from return (and from the other two less frequent operations). <BR>
<P>
Note that the above information is used only as a hint; correct setting of these bits can improve <BR>
performance but is not needed for correct operation. See <A href="#page276">Section A. 2.2 </A>
for more information on <BR>
branch prediction. <BR>
<P>
An unconditional long jump can be performed by: <BR>
<TT>JMP R31,( Rb), hint <BR>
</TT>Coroutine linkage can be performed by specifying the same register in both the Ra and Rb <BR>
operands. When disp&lt; 15: 14&gt; equals '10' (RET) or '11' (JSR_ COROUTINE) (that is, the tar-get <BR>
address prediction, if any, would come from a predictor implementation stack), then bits <BR>
&lt;13: 0&gt; are reserved for software and must be ignored by all implementations. All encodings <BR>
for bits &lt;13: 0&gt; are used by Compaq software or Reserved to Compaq, as follows: <BR>
<P>
<B>Table 4– 4: Jump Instructions Branch Prediction <BR>
disp&lt; 15: 14&gt; Meaning Predicted Target&lt; 15: 0&gt; Prediction Stack Action <BR>
</B>00 JMP PC + {4* disp&lt; 13: 0&gt;} – <BR>
01 JSR PC + {4* disp&lt; 13: 0&gt;} Push PC <BR>
10 RET Prediction stack Pop <BR>
11 JSR_ COROUTINE Prediction stack Pop, push PC <BR>
<P>
<B>Encoding Meaning <BR>
</B>0000 16 Indicates non-procedure return <BR>
0001 16 Indicates procedure return <BR>
All other encodings are reserved to Compaq. 
79
<BR>
<A href=#page79>79</A>
<strong><A name=page80> Page 80</A></strong>
<A href=#page81>81</A>
<BR>
<P>
<B>4– 24 </B>Alpha Architecture Handbook <BR>
<B>4.4 Integer Arithmetic Instructions <BR>
</B>The integer arithmetic instructions perform add, subtract, multiply, signed and unsigned com-pare, <BR>
and bit count operations. <BR>
<P>
<B>Count instruction (CIX) extension implementation note: <BR>
</B>The CIX extension to the architecture provides the CTLZ, CTPOP, and CTTZ instructions. <BR>
Alpha processors for which the AMASK instruction returns bit 2 set implement these <BR>
instructions. Those processors for which AMASK does not return bit 2 set can take an <BR>
Illegal Instruction trap, and software can emulate their function, if required. AMASK is <BR>
described in <A href="#page189">Sections 4.11. 1 </A>
<A href="#page327">and D. 3. <BR>
</A>
<P>
The integer instructions are summarized <A href="#page80">in Table 4– </A>
5 <BR>
<P>
There is no integer divide instruction. Division by a constant can be done by using UMULH; <BR>
division by a variable can be done by using a subroutine. <A href="#page284">See Section A. 4.2. <BR>
</A>
<P>
<B>Table 4– 5: Integer Arithmetic Instructions Summary <BR>
Mnemonic Operation <BR>
</B>ADD Add Quadword/ Longword <BR>
S4ADD Scaled Add by 4 <BR>
S8ADD Scaled Add by 8 <BR>
<P>
CMPEQ Compare Signed Quadword Equal <BR>
CMPLT Compare Signed Quadword Less Than <BR>
CMPLE Compare Signed Quadword Less Than or Equal <BR>
<P>
CTLZ Count leading zero <BR>
CTPOP Count population <BR>
CTTZ Count trailing zero <BR>
<P>
CMPULT Compare Unsigned Quadword Less Than <BR>
CMPULE Compare Unsigned Quadword Less Than or Equal <BR>
<P>
MUL Multiply Quadword/ Longword <BR>
UMULH Multiply Quadword Unsigned High <BR>
<P>
SUB Subtract Quadword/ Longword <BR>
S4SUB Scaled Subtract by 4 <BR>
S8SUB Scaled Subtract by 8 
80
<BR>
<A href=#page80>80</A>
<strong><A name=page81> Page 81</A></strong>
<A href=#page82>82</A>
<BR>
Instruction Descriptions <B>4– 25 <BR>
4.4. 1 Longword Add <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Rc </TT>¬ <TT>SEXT( (Rav + Rbv)&lt; 31: 0&gt;) <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>Register Ra is added to register Rb or a literal and the sign-extended 32-bit sum is written to <BR>
Rc. <BR>
<P>
The high order 32 bits of Ra and Rb are ignored. Rc is a proper sign extension of the truncated <BR>
32-bit sum. Overflow detection is based on the longword sum Rav&lt; 31: 0&gt; + Rbv&lt; 31: 0&gt;. <BR>
<P>
ADDL Ra. rl, Rb. rl, Rc. wq !Operate format <BR>
ADDL Ra. rl,# b. ib, Rc. wq !Operate format <BR>
<P>
Integer Overflow <BR>
ADDL Add Longword <BR>
Integer Overflow Enable (/ V) 
81
<BR>
<A href=#page81>81</A>
<strong><A name=page82> Page 82</A></strong>
<A href=#page83>83</A>
<BR>
<B>4– 26 </B>Alpha Architecture Handbook <BR>
<B>4.4. 2 Scaled Longword Add <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>CASE <BR>
S4ADDL: Rc </TT>¬ <TT>SEXT ((( LEFT_ SHIFT( Rav, 2)) + Rbv)&lt; 31: 0&gt;) <BR>
S8ADDL: Rc </TT>¬ <TT>SEXT ((( LEFT_ SHIFT( Rav, 3)) + Rbv)&lt; 31: 0&gt;) <BR>
ENDCASE <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>Register Ra is scaled by 4 (for S4ADDL) or 8 (for S8ADDL) and is added to register Rb or a <BR>
literal, and the sign-extended 32-bit sum is written to Rc. <BR>
<P>
The high 32 bits of Ra and Rb are ignored. Rc is a proper sign extension of the truncated 32-bit <BR>
sum. <BR>
<P>
SxADDL Ra. rl, Rb. rq, Rc. wq !Operate format <BR>
SxADDL Ra. rl,# b. ib, Rc. wq !Operate format <BR>
<P>
None <BR>
S4ADDL Scaled Add Longword by 4 <BR>
S8ADDL Scaled Add Longword by 8 <BR>
<P>
None 
82
<BR>
<A href=#page82>82</A>
<strong><A name=page83> Page 83</A></strong>
<A href=#page84>84</A>
<BR>
Instruction Descriptions <B>4– 27 <BR>
4.4. 3 Quadword Add <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Rc </TT>¬ <TT>Rav + Rbv <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>Register Ra is added to register Rb or a literal and the 64-bit sum is written to Rc. <BR>
<P>
On overflow, the least significant 64 bits of the true result are written to the destination <BR>
register. <BR>
<P>
The unsigned compare instructions can be used to generate carry. After adding two values, if <BR>
the sum is less unsigned than either one of the inputs, there was a carry out of the most signifi-cant <BR>
bit. <BR>
<P>
ADDQ Ra. rq, Rb. rq, Rc. wq !Operate format <BR>
ADDQ Ra. rq,# b. ib, Rc. wq !Operate format <BR>
<P>
Integer Overflow <BR>
ADDQ Add Quadword <BR>
Integer Overflow Enable (/ V) 
83
<BR>
<A href=#page83>83</A>
<strong><A name=page84> Page 84</A></strong>
<A href=#page85>85</A>
<BR>
<B>4– 28 </B>Alpha Architecture Handbook <BR>
<B>4.4. 4 Scaled Quadword Add <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>CASE <BR>
S4ADDQ: Rc </TT>¬ <TT>LEFT_ SHIFT( Rav, 2) + Rbv <BR>
S8ADDQ: Rc </TT>¬ <TT>LEFT_ SHIFT( Rav, 3) + Rbv <BR>
ENDCASE <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>Register Ra is scaled by 4 (for S4ADDQ) or 8 (for S8ADDQ) and is added to register Rb or a <BR>
literal, and the 64-bit sum is written to Rc. <BR>
<P>
On overflow, the least significant 64 bits of the true result are written to the destination <BR>
register. <BR>
<P>
SxADDQ Ra. rq, Rb. rq, Rc. wq !Operate format <BR>
SxADDQ Ra. rq,# b. ib, Rc. wq !Operate format <BR>
<P>
None <BR>
S4ADDQ Scaled Add Quadword by 4 <BR>
S8ADDQ Scaled Add Quadword by 8 <BR>
<P>
None 
84
<BR>
<A href=#page84>84</A>
<strong><A name=page85> Page 85</A></strong>
<A href=#page86>86</A>
<BR>
Instruction Descriptions <B>4– 29 <BR>
4.4. 5 Integer Signed Compare <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>IF Rav SIGNED_ RELATION Rbv THEN <BR>
Rc </TT>¬ <TT>1 <BR>
ELSE <BR>
Rc </TT>¬ <TT>0 <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>Register Ra is compared to Register Rb or a literal. If the specified relationship is true, the <BR>
value one is written to register Rc; otherwise, zero is written to Rc. <BR>
<P>
<B>Notes: <BR>
° </B>Compare Less Than A, B is the same as Compare Greater Than B, A; Compare Less Than or Equal A, B is the same as Compare Greater Than or Equal B, A. Therefore, only <BR>
<P>
the less-than operations are included. <BR>
<P>
CMPxx Ra. rq, Rb. rq, Rc. wq !Operate format <BR>
CMPxx Ra. rq,# b. ib, Rc. wq !Operate format <BR>
<P>
None <BR>
CMPEQ Compare Signed Quadword Equal <BR>
CMPLE Compare Signed Quadword Less Than or Equal <BR>
CMPLT Compare Signed Quadword Less Than <BR>
<P>
None 
85
<BR>
<A href=#page85>85</A>
<strong><A name=page86> Page 86</A></strong>
<A href=#page87>87</A>
<BR>
<B>4– 30 </B>Alpha Architecture Handbook <BR>
<B>4.4. 6 Integer Unsigned Compare <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>IF Rav UNSIGNED_ RELATION Rbv THEN <BR>
Rc </TT>¬ <TT>1 <BR>
ELSE <BR>
Rc </TT>¬ <TT>0 <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>Register Ra is compared to Register Rb or a literal. If the specified relationship is true, the <BR>
value one is written to register Rc; otherwise, zero is written to Rc. <BR>
<P>
CMPUxx Ra. rq, Rb. rq, Rc. wq !Operate format <BR>
CMPUxx Ra. rq,# b. ib, Rc. wq !Operate format <BR>
<P>
None <BR>
CMPULE Compare Unsigned Quadword Less Than or Equal <BR>
CMPULT Compare Unsigned Quadword Less Than <BR>
<P>
None 
86
<BR>
<A href=#page86>86</A>
<strong><A name=page87> Page 87</A></strong>
<A href=#page88>88</A>
<BR>
Instruction Descriptions <B>4– 31 <BR>
4.4. 7 Count Leading Zero <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>temp = 0 <BR>
FOR i FROM 63 DOWN TO 0 <BR>
IF { Rbv&lt; i&gt; EQ 1 } THEN BREAK <BR>
temp = temp + 1 <BR>
END <BR>
Rc&lt; 6: 0&gt; </TT>¬ <TT>temp&lt; 6: 0&gt; <BR>
Rc&lt; 63: 7&gt; </TT>¬ <TT>0 <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>The number of leading zeros in Rb, starting at the most significant bit position, is written to Rc. <BR>
Ra must be R31. <BR>
<P>
CTLZ Rb. rq, Rc. wq ! Operate format <BR>
None <BR>
CTLZ Count Leading Zero <BR>
None 
87
<BR>
<A href=#page87>87</A>
<strong><A name=page88> Page 88</A></strong>
<A href=#page89>89</A>
<BR>
<B>4– 32 </B>Alpha Architecture Handbook <BR>
<B>4.4. 8 Count Population <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>temp = 0 <BR>
FOR i FROM 0 TO 63 <BR>
IF { Rbv&lt; i&gt; EQ 1 } THEN temp = temp + 1 <BR>
END <BR>
Rc&lt; 6: 0&gt; </TT>¬ <TT>temp&lt; 6: 0&gt; <BR>
Rc&lt; 63: 7&gt; </TT>¬ <TT>0 <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>The number of ones in Rb is written to Rc. Ra must be R31. <BR>
<P>
CTPOP Rb. rq, Rc. wq ! Operate format <BR>
None <BR>
CTPOP Count Population <BR>
None 
88
<BR>
<A href=#page88>88</A>
<strong><A name=page89> Page 89</A></strong>
<A href=#page90>90</A>
<BR>
Instruction Descriptions <B>4– 33 <BR>
4.4. 9 Count Trailing Zero <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>temp = 0 <BR>
FOR i FROM 0 TO 63 <BR>
IF { Rbv&lt; i&gt; EQ 1 } THEN BREAK <BR>
temp = temp + 1 <BR>
END <BR>
Rc&lt; 6: 0&gt; </TT>¬ <TT>temp&lt; 6: 0&gt; <BR>
Rc&lt; 63: 7&gt; </TT>¬ <TT>0 <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>The number of trailing zeros in Rb, starting at the least significant bit position, is written to Rc. <BR>
Ra must be R31. <BR>
<P>
CTTZ Rb. rq, Rc. wq ! Operate format <BR>
None <BR>
CTTZ Count Trailing Zero <BR>
None 
89
<BR>
<A href=#page89>89</A>
<strong><A name=page90> Page 90</A></strong>
<A href=#page91>91</A>
<BR>
<B>4– 34 </B>Alpha Architecture Handbook <BR>
<B>4.4. 10 Longword Multiply <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Rc </TT>¬ <TT>SEXT (( Rav * Rbv)&lt; 31: 0&gt;) <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>Register Ra is multiplied by register Rb or a literal and the sign-extended 32-bit product is <BR>
written to Rc. <BR>
<P>
The high 32 bits of Ra and Rb are ignored. Rc is a proper sign extension of the truncated 32-bit <BR>
product. Overflow detection is based on the longword product Rav&lt; 31: 0&gt; * Rbv&lt; 31: 0&gt;. On <BR>
overflow, the proper sign extension of the least significant 32 bits of the true result is written to <BR>
the destination register. <BR>
<P>
The MULQ instruction can be used to return the full 64-bit product. <BR>
<P>
MULL Ra. rl, Rb. rl, Rc. wq !Operate format <BR>
MULL Ra. rl,# b. ib, Rc. wq !Operate format <BR>
<P>
Integer Overflow <BR>
MULL Multiply Longword <BR>
Integer Overflow Enable (/ V) 
90
<BR>
<A href=#page90>90</A>
<strong><A name=page91> Page 91</A></strong>
<A href=#page92>92</A>
<BR>
Instruction Descriptions <B>4– 35 <BR>
4.4. 11 Quadword Multiply <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Rc </TT>¬ <TT>Rav * Rbv <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>Register Ra is multiplied by register Rb or a literal and the 64-bit product is written to register <BR>
Rc. Overflow detection is based on considering the operands and the result as signed quanti-ties. <BR>
On overflow, the least significant 64 bits of the true result are written to the destination <BR>
register. <BR>
<P>
The UMULH instruction can be used to generate the upper 64 bits of the 128-bit result when <BR>
an overflow occurs. <BR>
<P>
MULQ Ra. rq, Rb. rq, Rc. wq !Operate format <BR>
MULQ Ra. Rq,# b. ib, Rc. wq !Operate format <BR>
<P>
Integer Overflow <BR>
MULQ Multiply Quadword <BR>
Integer Overflow Enable (/ V) 
91
<BR>
<A href=#page91>91</A>
<strong><A name=page92> Page 92</A></strong>
<A href=#page93>93</A>
<BR>
<B>4– 36 </B>Alpha Architecture Handbook <BR>
<B>4.4. 12 Unsigned Quadword Multiply High <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Rc </TT>¬ <TT>{Rav * U Rbv}&lt; 127: 64&gt; <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>Register Ra and Rb or a literal are multiplied as unsigned numbers to produce a 128-bit result. <BR>
The high-order 64-bits are written to register Rc. <BR>
<P>
The UMULH instruction can be used to generate the upper 64 bits of a 128-bit result as <BR>
follows: <BR>
<P>
Ra and Rb are unsigned: result of UMULH <BR>
Ra and Rb are signed: (result of UMULH) – Ra&lt; 63&gt;* Rb – Rb&lt; 63&gt;* Ra <BR>
<P>
The MULQ instruction gives the low 64 bits of the result in either case. <BR>
<P>
UMULH Ra. rq, Rb. rq, Rc. wq !Operate format <BR>
UMULH Ra. rq,# b. ib, Rc. wq !Operate format <BR>
<P>
None <BR>
UMULH Unsigned Multiply Quadword High <BR>
None 
92
<BR>
<A href=#page92>92</A>
<strong><A name=page93> Page 93</A></strong>
<A href=#page94>94</A>
<BR>
Instruction Descriptions <B>4– 37 <BR>
4.4. 13 Longword Subtract <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Rc </TT>¬ <TT>SEXT (( Rav -Rbv)&lt; 31: 0&gt;) <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>Register Rb or a literal is subtracted from register Ra and the sign-extended 32-bit difference is <BR>
written to Rc. <BR>
<P>
The high 32 bits of Ra and Rb are ignored. Rc is a proper sign extension of the truncated 32-bit <BR>
difference. Overflow detection is based on the longword difference Rav&lt; 31: 0&gt; – Rbv&lt; 31: 0&gt;. <BR>
<P>
SUBL Ra. rl, Rb. rl, Rc. wq !Operate format <BR>
SUBL Ra. rl,# b. ib, Rc. wq !Operate format <BR>
<P>
Integer Overflow <BR>
SUBL Subtract Longword <BR>
Integer Overflow Enable (/ V) 
93
<BR>
<A href=#page93>93</A>
<strong><A name=page94> Page 94</A></strong>
<A href=#page95>95</A>
<BR>
<B>4– 38 </B>Alpha Architecture Handbook <BR>
<B>4.4. 14 Scaled Longword Subtract <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>CASE <BR>
S4SUBL: Rc </TT>¬ <TT>SEXT ((( LEFT_ SHIFT( Rav, 2)) -Rbv)&lt; 31: 0&gt;) <BR>
S8SUBL: Rc </TT>¬ <TT>SEXT ((( LEFT_ SHIFT( Rav, 3)) -Rbv)&lt; 31: 0&gt;) <BR>
ENDCASE <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>Register Rb or a literal is subtracted from the scaled value of register Ra, which is scaled by 4 <BR>
(for S4SUBL) or 8 (for S8SUBL), and the sign-extended 32-bit difference is written to Rc. <BR>
<P>
The high 32 bits of Ra and Rb are ignored. Rc is a proper sign extension of the truncated 32-bit <BR>
difference. <BR>
<P>
SxSUBL Ra. rl, Rb. rl, Rc. wq !Operate format <BR>
SxSUBL Ra. rl,# b. ib, Rc. wq !Operate format <BR>
<P>
None <BR>
S4SUBL Scaled Subtract Longword by 4 <BR>
S8SUBL Scaled Subtract Longword by 8 <BR>
<P>
None 
94
<BR>
<A href=#page94>94</A>
<strong><A name=page95> Page 95</A></strong>
<A href=#page96>96</A>
<BR>
Instruction Descriptions <B>4– 39 <BR>
4.4. 15 Quadword Subtract <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Rc </TT>¬ <TT>Rav -Rbv <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>Register Rb or a literal is subtracted from register Ra and the 64-bit difference is written to reg-ister <BR>
Rc. On overflow, the least significant 64 bits of the true result are written to the <BR>
destination register. <BR>
<P>
The unsigned compare instructions can be used to generate borrow. If the minuend (Rav) is <BR>
less unsigned than the subtrahend (Rbv), a borrow will occur. <BR>
<P>
SUBQ Ra. rq, Rb. rq, Rc. wq !Operate format <BR>
SUBQ Ra. rq,# b. ib, Rc. wq !Operate format <BR>
<P>
Integer Overflow <BR>
SUBQ Subtract Quadword <BR>
Integer Overflow Enable (/ V) 
95
<BR>
<A href=#page95>95</A>
<strong><A name=page96> Page 96</A></strong>
<A href=#page97>97</A>
<BR>
<B>4– 40 </B>Alpha Architecture Handbook <BR>
<B>4.4. 16 Scaled Quadword Subtract <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>CASE <BR>
S4SUBQ: Rc </TT>¬ <TT>LEFT_ SHIFT( Rav, 2) -Rbv <BR>
S8SUBQ: Rc </TT>¬ <TT>LEFT_ SHIFT( Rav, 3) -Rbv <BR>
ENDCASE <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>Register Rb or a literal is subtracted from the scaled value of register Ra, which is scaled by 4 <BR>
(for S4SUBQ) or 8 (for S8SUBQ), and the 64-bit difference is written to Rc. <BR>
<P>
SxSUBQ Ra. rq, Rb. rq, Rc. wq !Operate format <BR>
SxSUBQ Ra. rq,# b. ib, Rc. wq !Operate format <BR>
<P>
None <BR>
S4SUBQ Scaled Subtract Quadword by 4 <BR>
S8SUBQ Scaled Subtract Quadword by 8 <BR>
<P>
None 
96
<BR>
<A href=#page96>96</A>
<strong><A name=page97> Page 97</A></strong>
<A href=#page98>98</A>
<BR>
<P>
Instruction Descriptions <B>4– 41 <BR>
4. 5 Logical and Shift Instructions <BR>
</B>The logical instructions perform quadword Boolean operations. The conditional move integer <BR>
instructions perform conditionals without a branch. The shift instructions perform left and right <BR>
logical shift and right arithmetic shift. These are summarized <A href="#page97">in Table 4– </A>
6. <BR>
<P>
<B>Software Note: <BR>
</B>There is no arithmetic left shift instruction. Where an arithmetic left shift would be used, a <BR>
logical shift will do. For multiplying by a small power of two in address computations, <BR>
logical left shift is acceptable. <BR>
<P>
Integer multiply should be used to perform an arithmetic left shift with overflow checking. <BR>
Bit field extracts can be done with two logical shifts. Sign extension can be done with a left <BR>
logical shift and a right arithmetic shift. <BR>
<P>
<B>Table 4– 6: Logical and Shift Instructions Summary <BR>
Mnemonic Operation <BR>
</B>AND Logical Product <BR>
BIC Logical Product with Complement <BR>
BIS Logical Sum (OR) <BR>
EQV Logical Equivalence (XORNOT) <BR>
ORNOT Logical Sum with Complement <BR>
XOR Logical Difference <BR>
<P>
CMOVxx Conditional Move Integer <BR>
SLL Shift Left Logical <BR>
SRA Shift Right Arithmetic <BR>
SRL Shift Right Logical 
97
<BR>
<A href=#page97>97</A>
<strong><A name=page98> Page 98</A></strong>
<A href=#page99>99</A>
<BR>
<B>4– 42 </B>Alpha Architecture Handbook <BR>
<B>4.5. 1 Logical Functions <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Rc </TT>¬ <TT>Rav AND Rbv !AND <BR>
Rc </TT>¬ <TT>Rav OR Rbv !BIS <BR>
Rc </TT>¬ <TT>Rav XOR Rbv !XOR <BR>
Rc </TT>¬ <TT>Rav AND {NOT Rbv} !BIC <BR>
Rc </TT>¬ <TT>Rav OR {NOT Rbv} !ORNOT <BR>
Rc </TT>¬ <TT>Rav XOR {NOT Rbv} !EQV <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>These instructions perform the designated Boolean function between register Ra and register <BR>
Rb or a literal. The result is written to register Rc. <BR>
<P>
The NOT function can be performed by doing an ORNOT with zero (Ra = R31). <BR>
<P>
mnemonic Ra. rq, Rb. rq, Rc. wq !Operate format <BR>
mnemonic Ra. rq,# b. ib, Rc. wq !Operate format <BR>
<P>
None <BR>
AND Logical Product <BR>
BIC Logical Product with Complement <BR>
BIS Logical Sum (OR) <BR>
EQV Logical Equivalence (XORNOT) <BR>
ORNOT Logical Sum with Complement <BR>
XOR Logical Difference <BR>
<P>
None 
98
<BR>
<A href=#page98>98</A>
<strong><A name=page99> Page 99</A></strong>
<A href=#page100>100</A>
<BR>
Instruction Descriptions <B>4– 43 <BR>
4.5. 2 Conditional Move Integer <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>IF TEST( Rav, Condition_ based_ on_ Opcode) THEN <BR>
</TT><P>
<TT>Rc </TT>¬ <TT>Rbv <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>Register Ra is tested. If the specified relationship is true, the value Rbv is written to register <BR>
Rc. <BR>
<P>
CMOVxx Ra. rq, Rb. rq, Rc. wq !Operate format <BR>
CMOVxx Ra. rq,# b. ib, Rc. wq !Operate format <BR>
<P>
None <BR>
CMOVEQ CMOVE if Register Equal to Zero <BR>
CMOVGE CMOVE if Register Greater Than or Equal to Zero <BR>
CMOVGT CMOVE if Register Greater Than Zero <BR>
CMOVLBC CMOVE if Register Low Bit Clear <BR>
CMOVLBS CMOVE if Register Low Bit Set <BR>
CMOVLE CMOVE if Register Less Than or Equal to Zero <BR>
CMOVLT CMOVE if Register Less Than Zero <BR>
CMOVNE CMOVE if Register Not Equal to Zero <BR>
<P>
None 
99
<BR>
<A href=#page99>99</A>
<strong><A name=page100> Page 100</A></strong>
<A href=#page101>101</A>
<BR>
<B>4– 44 </B>Alpha Architecture Handbook <BR>
<B>Notes: <BR>
</B>Except that it is likely in many implementations to be substantially faster, the instruction: <BR>
<P>
<TT>CMOVEQ Ra, Rb, Rc <BR>
</TT>is exactly equivalent to: <BR>
<TT>BNE Ra, label <BR>
OR Rb, Rb, Rc <BR>
label: ... <BR>
</TT><P>
For example, a branchless sequence for: <BR>
<TT>R1= MAX( R1, R2) <BR>
</TT>is: <BR>
<TT>CMPLT R1, R2, R3 ! R3= 1 if R1&lt; R2 <BR>
CMOVNE R3, R2, R1 ! Move R2 to R1 if R1&lt; R2 </TT>
100
<BR>
<A href=#page100>100</A>
<strong><A name=page101> Page 101</A></strong>
<A href=#page102>102</A>
<BR>
Instruction Descriptions <B>4– 45 <BR>
4.5. 3 Shift Logical <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Rc </TT>¬ <TT>LEFT_ SHIFT( Rav, Rbv&lt; 5: 0&gt;) !SLL <BR>
Rc </TT>¬ <TT>RIGHT_ SHIFT( Rav, Rbv&lt; 5: 0&gt;) !SRL <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>Register Ra is shifted logically left or right 0 to 63 bits by the count in register Rb or a literal. <BR>
The result is written to register Rc. Zero bits are propagated into the vacated bit positions. <BR>
<P>
SxL Ra. rq, Rb. rq, Rc. wq !Operate format <BR>
SxL Ra. rq,# b. ib, Rc. wq !Operate format <BR>
<P>
None <BR>
SLL Shift Left Logical <BR>
SRL Shift Right Logical <BR>
<P>
None 
101
<BR>
<A href=#page101>101</A>
<strong><A name=page102> Page 102</A></strong>
<A href=#page103>103</A>
<BR>
<B>4– 46 </B>Alpha Architecture Handbook <BR>
<B>4.5. 4 Shift Arithmetic <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Rc </TT>¬ <TT>ARITH_ RIGHT_ SHIFT( Rav, Rbv&lt; 5: 0&gt;) <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>Register Ra is right shifted arithmetically 0 to 63 bits by the count in register Rb or a literal. <BR>
The result is written to register Rc. The sign bit (Rav&lt; 63&gt;) is propagated into the vacated bit <BR>
positions. <BR>
<P>
SRA Ra. rq, Rb. rq, Rc. wq !Operate format <BR>
SRA Ra. rq,# b. ib, Rc. wq !Operate format <BR>
<P>
None <BR>
SRA Shift Right Arithmetic <BR>
None 
102
<BR>
<A href=#page102>102</A>
<strong><A name=page103> Page 103</A></strong>
<A href=#page104>104</A>
<BR>
<P>
Instruction Descriptions <B>4– 47 <BR>
4. 6 Byte Manipulation Instructions <BR>
</B>Alpha implementations that support the BWX extension provide the following instructions for <BR>
loading, sign-extending, and storing bytes and words between a register and memory: <BR>
<P>
The AMASK instruction reports whether a particular Alpha implementation supports the BWX <BR>
extension. AMASK is described in <A href="#page189">Sections 4.11. </A>
1 <A href="#page327">and D. </A>
3. <BR>
<P>
LDBU and STB are the recommended way to perform byte load and store operations on Alpha <BR>
implementations that support them; use them rather than the extract, insert, and mask byte <BR>
instructions described in this section. In particular, the implementation examples in this sec-tion <BR>
that illustrate byte operations are not appropriate for Alpha implementations that support <BR>
the BWX extension – instead use the recommendations <A href="#page283">in Section A. 4.1. <BR>
</A>
<P>
In addition to LDBU and STB, Alpha provides the instructions in <A href="#page103">Table 4– 7 </A>
for operating on <BR>
byte operands within registers. <BR>
<P>
<B>Instruction Meaning Described in Section <BR>
</B>LDBU/ LDWU Load byte/ word unaligned <A href="#page62">4. 2. 2 <BR>
</A>
SEXTB/ SEXTW Sign-extend byte/ word <A href="#page116">4. 6. 5 <BR>
</A>
STB/ STW Store byte/ word <A href="#page71">4. 2. 6 <BR>
</A>
<P>
<B>Table 4– 7: Byte-Within-Register Manipulation Instructions Summary <BR>
Mnemonic Operation <BR>
</B>CMPBGE Compare Byte <BR>
<P>
EXTBL Extract Byte Low <BR>
EXTWL Extract Word Low <BR>
EXTLL Extract Longword Low <BR>
EXTQL Extract Quadword Low <BR>
EXTWH Extract Word High <BR>
EXTLH Extract Longword High <BR>
EXTQH Extract Quadword High <BR>
<P>
INSBL Insert Byte Low <BR>
INSWL Insert Word Low <BR>
INSLL Insert Longword Low <BR>
INSQL Insert Quadword Low 
103
<BR>
<A href=#page103>103</A>
<strong><A name=page104> Page 104</A></strong>
<A href=#page105>105</A>
<BR>
<B>4– 48 </B>Alpha Architecture Handbook <BR>
INSWH Insert Word High <BR>
INSLH Insert Longword High <BR>
INSQH Insert Quadword High <BR>
<P>
MSKBL Mask Byte Low <BR>
MSKWL Mask Word Low <BR>
MSKLL Mask Longword Low <BR>
MSKQL Mask Quadword Low <BR>
MSKWH Mask Word High <BR>
MSKLH Mask Longword High <BR>
MSKQH Mask Quadword High <BR>
<P>
SEXTB Sign extend byte <BR>
SEXTW Sign extend word <BR>
<P>
ZAP Zero Bytes <BR>
ZAPNOT Zero Bytes Not <BR>
<P>
<B>Table 4– 7: Byte-Within-Register Manipulation Instructions Summary <BR>
(Continued) <BR>
</B><P>
<B>Mnemonic Operation </B>
104
<BR>
<A href=#page104>104</A>
<strong><A name=page105> Page 105</A></strong>
<A href=#page106>106</A>
<BR>
Instruction Descriptions <B>4– 49 <BR>
4.6. 1 Compare Byte <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>FOR i FROM 0 TO 7 <BR>
temp&lt; 8: 0&gt; </TT>¬ <TT>0 || Rav&lt; i* 8+ 7: i* 8&gt;} + {0 || NOT Rbv&lt; i* 8+ 7: i* 8&gt;} + 1 <BR>
Rc&lt; i&gt; </TT>¬ <TT>temp&lt; 8&gt; <BR>
END <BR>
Rc&lt; 63: 8&gt; </TT>¬ <TT>0 <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>CMPBGE does eight parallel unsigned byte comparisons between corresponding bytes of Rav <BR>
and Rbv, storing the eight results in the low eight bits of Rc. The high 56 bits of Rc are set to <BR>
zero. Bit 0 of Rc corresponds to byte 0, bit 1 of Rc corresponds to byte 1, and so forth. A result <BR>
bit is set in Rc if the corresponding byte of Rav is greater than or equal to Rbv (unsigned). <BR>
<P>
<B>Notes: <BR>
</B>The result of CMPBGE can be used as an input to ZAP and ZAPNOT. <BR>
<P>
To scan for a byte of zeros in a character string: <BR>
<TT>&lt;initialize R1 to aligned QW address of string&gt; <BR>
LOOP: <BR>
LDQ R2, 0( R1) ; Pick up 8 bytes <BR>
LDA R1, 8( R1) ; Increment string pointer <BR>
CMPBGE R31, R2,R3 ; If NO bytes of zero, R3&lt; 7: 0&gt;= 0 <BR>
BEQ R3, LOOP ; Loop if no terminator byte found <BR>
... ; At this point, R3 can be used to <BR>
; determine which byte terminated <BR>
</TT><P>
CMPBGE Ra. rq, Rb. rq, Rc. wq !Operate format <BR>
CMPBGE Ra. rq,# b. ib, Rc. wq !Operate format <BR>
<P>
None <BR>
CMPBGE Compare Byte <BR>
None 
105
<BR>
<A href=#page105>105</A>
<strong><A name=page106> Page 106</A></strong>
<A href=#page107>107</A>
<BR>
<B>4– 50 </B>Alpha Architecture Handbook <BR>
To compare two character strings for greater/ equal/ less: <BR>
<TT>&lt;initialize R1 to aligned QW address of string1&gt; <BR>
&lt;initialize R2 to aligned QW address of string2&gt; <BR>
LOOP: <BR>
LDQ R3, 0( R1) ; Pick up 8 bytes of string1 <BR>
LDA R1, 8( R1) ; Increment string1 pointer <BR>
LDQ R4, 0( R2) ; Pick up 8 bytes of string2 <BR>
LDA R2, 8( R2) ; Increment string2 pointer <BR>
CMPBGE R31, R3, R6 ; Test for zeros in string1 <BR>
XOR R3, R4, R5 ; Test for all equal bytes <BR>
BNE R6, DONE ; Exit if a zero found <BR>
BEQ R5, LOOP ; Loop if all equal <BR>
DONE: CMPBGE R31, R5, R5 ; <BR>
... <BR>
; At this point, R5 can be used to determine the first not-equal <BR>
; byte position (if any), and R6 can be used to determine the <BR>
; position of the terminating zero in string1 (if any). <BR>
</TT><P>
To range-check a string of characters in R1 for '0'¼' 9': <BR>
<TT>LDQ R2, lit0s ; Pick up 8 bytes of the character <BR>
; BELOW '0' '//////// ' <BR>
LDQ R3, lit9s ; Pick up 8 bytes of the character <BR>
; ABOVE '9' ':::::::: ' <BR>
CMPBGE R2, R1, R4 ; Some R4&lt; i&gt;= 1 if character is LT '0' <BR>
CMPBGE R1, R3, R5 ; Some R5&lt; i&gt;= 1 if character is GT '9' <BR>
BNE R4, ERROR ; Branch if some char too low <BR>
BNE R5, ERROR ; Branch if some char too high </TT>
106
<BR>
<A href=#page106>106</A>
<strong><A name=page107> Page 107</A></strong>
<A href=#page108>108</A>
<BR>
Instruction Descriptions <B>4– 51 <BR>
4. 6.2 Extract Byte <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>CASE <BR>
big_ endian_ data: Rbv' </TT>¬ <TT>Rbv XOR 111 2 <BR>
</TT><P>
<TT>little_ endian_ data: Rbv' </TT>¬ <TT>Rbv <BR>
ENDCASE <BR>
</TT><P>
<TT>CASE <BR>
EXTBL: byte_ mask </TT>¬ <TT>0000 0001 2 <BR>
</TT><P>
<TT>EXTWx: byte_ mask </TT>¬ <TT>0000 0011 2 <BR>
EXTLx: byte_ mask </TT>¬ <TT>0000 1111 2 <BR>
EXTQx: byte_ mask </TT>¬ <TT>1111 1111 2 <BR>
ENDCASE <BR>
</TT><P>
<TT>CASE <BR>
EXTxL: <BR>
byte_ loc </TT>¬ <TT>Rbv'&lt; 2: 0&gt;* 8 <BR>
temp </TT>¬ <TT>RIGHT_ SHIFT( Rav, byte_ loc&lt; 5: 0&gt;) <BR>
Rc </TT>¬ <TT>BYTE_ ZAP( temp, NOT( byte_ mask) ) <BR>
EXTxH: <BR>
byte_ loc </TT>¬ <TT>64 -Rbv'&lt; 2: 0&gt;* 8 <BR>
temp </TT>¬ <TT>LEFT_ SHIFT( Rav, byte_ loc&lt; 5: 0&gt;) <BR>
Rc </TT>¬ <TT>BYTE_ ZAP( temp, NOT( byte_ mask) ) <BR>
ENDCASE <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
</B><P>
EXTxx Ra. rq, Rb. rq, Rc. wq !Operate format <BR>
EXTxx Ra. rq,# b. ib, Rc. wq !Operate format <BR>
<P>
None <BR>
EXTBL Extract Byte Low <BR>
EXTWL Extract Word Low <BR>
EXTLL Extract Longword Low <BR>
EXTQL Extract Quadword Low <BR>
EXTWH Extract Word High <BR>
EXTLH Extract Longword High <BR>
EXTQH Extract Quadword High <BR>
<P>
None 
107
<BR>
<A href=#page107>107</A>
<strong><A name=page108> Page 108</A></strong>
<A href=#page109>109</A>
<BR>
<B>4– 52 </B>Alpha Architecture Handbook <BR>
<B>Description: <BR>
</B>EXTxL shifts register Ra right by 0 to 7 bytes, inserts zeros into vacated bit positions, and then <BR>
extracts 1, 2, 4, or 8 bytes into register Rc. EXTxH shifts register Ra left by 0 to 7 bytes, <BR>
inserts zeros into vacated bit positions, and then extracts 2, 4, or 8 bytes into register Rc. The <BR>
number of bytes to shift is specified by Rbv'&lt; 2: 0&gt;. The number of bytes to extract is speci-fied <BR>
in the function code. Remaining bytes are filled with zeros. <BR>
<P>
<B>Notes: <BR>
</B>The comments in the examples below assume that the effective address (ea) of X( R11) is such <BR>
that (ea mod 8) = 5), the value of the aligned quadword containing X( R11) is CBAx xxxx, and <BR>
the value of the aligned quadword containing X+ 7( R11) is yyyH GFED, and the datum is <BR>
little-endian. <BR>
<P>
The examples below are the most general case unless otherwise noted; if more information is <BR>
known about the value or intended alignment of X, shorter sequences can be used. <BR>
<P>
The intended sequence for loading a quadword from unaligned address X( R11) is: <BR>
<TT>LDQ_ U R1, X( R11) ; Ignores va&lt; 2: 0&gt;, R1 = CBAx xxxx <BR>
LDQ_ U R2, X+ 7( R11) ; Ignores va&lt; 2: 0&gt;, R2 = yyyH GFED <BR>
LDA R3, X( R11) ; R3&lt; 2: 0&gt; = (X mod 8) = 5 <BR>
EXTQL R1, R3, R1 ; R1 = 0000 0CBA <BR>
EXTQH R2, R3, R2 ; R2 = HGFE D000 <BR>
OR R2, R1, R1 ; R1 = HGFE DCBA <BR>
</TT><P>
The intended sequence for loading and zero-extending a longword from unaligned address X <BR>
is: <BR>
<P>
<TT>LDQ_ U R1, X( R11) ; Ignores va&lt; 2: 0&gt;, R1 = CBAx xxxx <BR>
LDQ_ U R2, X+ 3( R11) ; Ignores va&lt; 2: 0&gt;, R2 = yyyy yyyD <BR>
LDA R3, X( R11) ; R3&lt; 2: 0&gt; = (X mod 8) = 5 <BR>
EXTLL R1, R3, R1 ; R1 = 0000 0CBA <BR>
EXTLH R2, R3, R2 ; R2 = 0000 D000 <BR>
OR R2, R1, R1 ; R1 = 0000 DCBA <BR>
</TT><P>
The intended sequence for loading and sign-extending a longword from unaligned address X <BR>
is: <BR>
<P>
<TT>LDQ_ U R1, X( R11) ; Ignores va&lt; 2: 0&gt;, R1 = CBAx xxxx <BR>
LDQ_ U R2, X+ 3( R11) ; Ignores va&lt; 2: 0&gt;, R2 = yyyy yyyD <BR>
LDA R3, X( R11) ; R3&lt; 2: 0&gt; = (X mod 8) = 5 <BR>
EXTLL R1, R3, R1 ; R1 = 0000 0CBA <BR>
EXTLH R2, R3, R2 ; R2 = 0000 D000 <BR>
OR R2, R1, R1 ; R1 = 0000 DCBA <BR>
ADDL R31, R1, R1 ; R1 = ssss DCBA </TT>
108
<BR>
<A href=#page108>108</A>
<strong><A name=page109> Page 109</A></strong>
<A href=#page110>110</A>
<BR>
Instruction Descriptions <B>4– 53 <BR>
</B>For software that is not designed to use the BWX extension, the intended sequence for loading <BR>
and zero-extending a word from unaligned address X is: <BR>
<P>
<TT>LDQ_ U R1, X( R11) ; Ignores va&lt; 2: 0&gt;, R1 = yBAx xxxx <BR>
LDQ_ U R2, X+ 1( R11) ; Ignores va&lt; 2: 0&gt;, R2 = yBAx xxxx <BR>
LDA R3, X( R11) ; R3&lt; 2: 0&gt; = (X mod 8) = 5 <BR>
EXTWL R1, R3, R1 ; R1 = 0000 00BA <BR>
EXTWH R2, R3, R2 ; R2 = 0000 0000 <BR>
OR R2, R1, R1 ; R1 = 0000 00BA <BR>
</TT><P>
For software that is not designed to use the BWX extension, the intended sequence for loading <BR>
and sign-extending a word from unaligned address X is: <BR>
<P>
<TT>LDQ_ U R1, X( R11) ; Ignores va&lt; 2: 0&gt;, R1 = yBAx xxxx <BR>
LDQ_ U R2, X+ 1( R11) ; Ignores va&lt; 2: 0&gt;, R2 = yBAx xxxx <BR>
LDA R3, X+ 1+ 1( R11) ; R3&lt; 2: 0&gt; = 5+ 1+ 1 = 7 <BR>
EXTQL R1, R3, R1 ; R1 = 0000 000y <BR>
EXTQH R2, R3, R2 ; R2 = BAxx xxx0 <BR>
OR R2, R1, R1 ; R1 = BAxx xxxy <BR>
SRA R1, #48, R1 ; R1 = ssss ssBA <BR>
</TT><P>
For software that is not designed to use the BWX extension, the intended sequence for loading <BR>
and zero-extending a byte from address X is: <BR>
<P>
<TT>LDQ_ U R1, X( R11) ; Ignores va&lt; 2: 0&gt;, R1 = yyAx xxxx <BR>
LDA R3, X( R11) ; R3&lt; 2: 0&gt; = (X mod 8) = 5 <BR>
EXTBL R1, R3, R1 ; R1 = 0000 000A <BR>
</TT><P>
For software that is not designed to use the BWX extension, the intended sequence for loading <BR>
and sign-extending a byte from address X is: <BR>
<P>
<TT>LDQ_ U R1, X( R11) ; Ignores va&lt; 2: 0&gt;, R1 = yyAx xxxx <BR>
LDA R3, X+ 1( R11) ; R3&lt; 2: 0&gt; = (X + 1) mod 8, i. e., <BR>
; convert byte position within <BR>
; quadword to one-origin based <BR>
EXTQH R1, R3, R1 ; Places the desired byte into byte 7 <BR>
; of R1. final by left shifting <BR>
; R1. initial by ( 8 -R3&lt; 2: 0&gt; ) byte <BR>
; positions <BR>
SRA R1, #56, R1 ; Arithmetic Shift of byte 7 down <BR>
; into byte 0, <BR>
</TT><P>
<B>Optimized examples: <BR>
</B>Assume that a word fetch is needed from 10( R3), where R3 is intended to contain a long-word-<BR>
aligned address. The optimized sequences below take advantage of the known constant <BR>
offset, and the longword alignment (hence a single aligned longword contains the entire word). <BR>
The sequences generate a Data Alignment Fault if R3 does not contain a longword-aligned <BR>
address. 
109
<BR>
<A href=#page109>109</A>
<strong><A name=page110> Page 110</A></strong>
<A href=#page111>111</A>
<BR>
<B>4– 54 </B>Alpha Architecture Handbook <BR>
For software that is not designed to use the BWX extension, the intended sequence for loading <BR>
and zero-extending an aligned word from 10( R3) is: <BR>
<P>
<TT>LDL R1, 8( R3) ; R1 = ssss BAxx <BR>
; Faults if R3 is not longword aligned <BR>
EXTWL R1, #2, R1 ; R1 = 0000 00BA <BR>
</TT><P>
For software that is not designed to use the BWX extension, the intended sequence for loading <BR>
and sign-extending an aligned word from 10( R3) is: <BR>
<P>
<TT>LDL R1, 8( R3) ; R1 = ssss BAxx <BR>
; Faults if R3 is not longword aligned <BR>
SRA R1, #16, R1 ; R1 = ssss ssBA <BR>
</TT><P>
<B>Big-endian examples: <BR>
</B>For software that is not designed to use the BWX extension, the intended sequence for loading <BR>
and zero-extending a byte from address X is: <BR>
<P>
<TT>LDQ_ U R1, X( R11) ; Ignores va&lt; 2: 0&gt;, R1 = xxxx xAyy <BR>
LDA R3, X( R11) ; R3&lt; 2: 0&gt; = 5, shift will be 2 bytes <BR>
EXTBL R1, R3, R1 ; R1 = 0000 000A <BR>
</TT><P>
The intended sequence for loading a quadword from unaligned address X( R11) is: <BR>
<TT>LDQ_ U R1, X( R11) ; Ignores va&lt; 2: 0&gt;, R1 = xxxxxABC <BR>
LDQ_ U R2, X+ 7( R11) ; Ignores va&lt; 2: 0&gt;, R2 = DEFGHyyy <BR>
LDA R3, X+ 7( R11) ; R3&lt; 2: 0&gt; = 4, shift will be 3 bytes <BR>
EXTQH R1, R3, R1 ; R1 = ABC0 0000 <BR>
EXTQL R2, R3, R2 ; R2 = 000D EFGH <BR>
OR R1, R2, R1 ; R1 = ABCD EFGH <BR>
</TT><P>
Note that the address in the LDA instruction for big-endian quadwords is X+ 7, for longwords <BR>
is X+ 3, and for words is X+ 1; for little-endian, these are all just X. Also note that the EXTQH <BR>
and EXTQL instructions are reversed with respect to the little-endian sequence. 
110
<BR>
<A href=#page110>110</A>
<strong><A name=page111> Page 111</A></strong>
<A href=#page112>112</A>
<BR>
Instruction Descriptions <B>4– 55 <BR>
4.6. 3 Byte Insert <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>CASE <BR>
big_ endian_ data: Rbv' </TT>¬ <TT>Rbv XOR 111 2 <BR>
</TT><P>
<TT>little_ endian_ data: Rbv' </TT>¬ <TT>Rbv <BR>
ENDCASE <BR>
</TT><P>
<TT>CASE <BR>
INSBL: byte_ mask </TT>¬ <TT>0000 0000 0000 0001 2 <BR>
</TT><P>
<TT>INSWx: byte_ mask </TT>¬ <TT>0000 0000 0000 0011 2 <BR>
INSLx: byte_ mask </TT>¬ <TT>0000 0000 0000 1111 2 <BR>
INSQx: byte_ mask </TT>¬ <TT>0000 0000 1111 1111 2 <BR>
ENDCASE <BR>
byte_ mask </TT>¬ <TT>LEFT_ SHIFT( byte_ mask, Rbv'&lt; 2: 0&gt;) <BR>
</TT><P>
<TT>CASE <BR>
INSxL: <BR>
byte_ loc </TT>¬ <TT>Rbv'&lt; 2: 0&gt;* 8 <BR>
temp </TT>¬ <TT>LEFT_ SHIFT( Rav, byte_ loc&lt; 5: 0&gt;) <BR>
Rc </TT>¬ <TT>BYTE_ ZAP( temp, NOT( byte_ mask&lt; 7: 0&gt;)) <BR>
INSxH: <BR>
byte_ loc </TT>¬ <TT>64 -Rbv'&lt; 2: 0&gt;* 8 <BR>
temp </TT>¬ <TT>RIGHT_ SHIFT( Rav, byte_ loc&lt; 5: 0&gt;) <BR>
Rc </TT>¬ <TT>BYTE_ ZAP( temp, NOT( byte_ mask&lt; 15: 8&gt;)) <BR>
ENDCASE <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
INSxx Ra. rq, Rb. rq, Rc. wq !Operate format <BR>
INSxx Ra. rq,# b. ib, Rc. wq !Operate format <BR>
<P>
None <BR>
INSBL Insert Byte Low <BR>
INSWL Insert Word Low <BR>
INSLL Insert Longword Low <BR>
INSQL Insert Quadword Low <BR>
INSWH Insert Word High <BR>
INSLH Insert Longword High <BR>
INSQH Insert Quadword High 
111
<BR>
<A href=#page111>111</A>
<strong><A name=page112> Page 112</A></strong>
<A href=#page113>113</A>
<BR>
<B>4– 56 </B>Alpha Architecture Handbook <BR>
<B>Qualifiers: <BR>
Description: <BR>
</B>INSxL and INSxH shift bytes from register Ra and insert them into a field of zeros, storing the <BR>
result in register Rc. Register Rbv'&lt; 2: 0&gt; selects the shift amount, and the function code <BR>
selects the maximum field width: 1, 2, 4, or 8 bytes. The instructions can generate a byte, <BR>
word, longword, or quadword datum that is spread across two registers at an arbitrary byte <BR>
alignment. <BR>
<P>
None 
112
<BR>
<A href=#page112>112</A>
<strong><A name=page113> Page 113</A></strong>
<A href=#page114>114</A>
<BR>
Instruction Descriptions <B>4– 57 <BR>
4. 6.4 Byte Mask <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>CASE <BR>
big_ endian_ data: Rbv'¬ Rbv XOR 111 2 <BR>
</TT><P>
<TT>little_ endian_ data: Rbv'¬ Rbv <BR>
ENDCASE <BR>
</TT><P>
<TT>CASE <BR>
MSKBL: byte_ mask </TT>¬ <TT>0000 0000 0000 0001 2 <BR>
</TT><P>
<TT>MSKWx: byte_ mask </TT>¬ <TT>0000 0000 0000 0011 2 <BR>
MSKLx: byte_ mask </TT>¬ <TT>0000 0000 0000 1111 2 <BR>
MSKQx: byte_ mask </TT>¬ <TT>0000 0000 1111 1111 2 <BR>
ENDCASE <BR>
byte_ mask </TT>¬ <TT>LEFT_ SHIFT( byte_ mask, Rbv'&lt; 2: 0&gt;) <BR>
</TT><P>
<TT>CASE <BR>
MSKxL: <BR>
Rc </TT>¬ <TT>BYTE_ ZAP( Rav, byte_ mask&lt; 7: 0&gt;) <BR>
MSKxH: <BR>
Rc </TT>¬ <TT>BYTE_ ZAP( Rav, byte_ mask&lt; 15: 8&gt;) <BR>
ENDCASE <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
</B><P>
MSKxx Ra. rq, Rb. rq, Rc. wq !Operate format <BR>
MSKxx Ra. rq,# b. ib, Rc. wq !Operate format <BR>
<P>
None <BR>
MSKBL Mask Byte Low <BR>
MSKWL Mask Word Low <BR>
MSKLL Mask Longword Low <BR>
MSKQL Mask Quadword Low <BR>
MSKWH Mask Word High <BR>
MSKLH Mask Longword High <BR>
MSKQH Mask Quadword High <BR>
<P>
None 
113
<BR>
<A href=#page113>113</A>
<strong><A name=page114> Page 114</A></strong>
<A href=#page115>115</A>
<BR>
<P>
<B>4– 58 </B>Alpha Architecture Handbook <BR>
<B>Description: <BR>
</B>MSKxL and MSKxH set selected bytes of register Ra to zero, storing the result in register Rc. <BR>
Register Rbv'&lt; 2: 0&gt; selects the starting position of the field of zero bytes, and the function <BR>
code selects the maximum width: 1, 2, 4, or 8 bytes. The instructions generate a byte, word, <BR>
longword, or quadword field of zeros that can spread across two registers at an arbitrary byte <BR>
alignment. <BR>
<P>
<B>Notes: <BR>
</B>The comments in the examples below assume that the effective address (ea) of X( R11) is such <BR>
that (ea mod 8) = 5, the value of the aligned quadword containing X( R11) is CBAx xxxx, the <BR>
value of the aligned quadword containing X+ 7( R11) is yyyH GFED, the value to be stored <BR>
from R5 is HGFE DCBA, and the datum is little-endian. Slight modifications similar to those <BR>
in <A href="#page107">Section 4. 6.2 </A>
apply to big-endian data. <BR>
<P>
The examples below are the most general case; if more information is known about the value <BR>
or intended alignment of X, shorter sequences can be used. <BR>
<P>
The intended sequence for storing an unaligned quadword R5 at address X( R11) is: <BR>
<TT>LDA R6, X( R11) ; R6&lt; 2: 0&gt; = (X mod 8) = 5 <BR>
LDQ_ U R2, X+ 7( R11) ; Ignores va&lt; 2: 0&gt;, R2 = yyyH GFED <BR>
LDQ_ U R1, X( R11) ; Ignores va&lt; 2: 0&gt;, R1 = CBAx xxxx <BR>
INSQH R5, R6, R4 ; R4 = 000H GFED <BR>
INSQL R5, R6, R3 ; R3 = CBA0 0000 <BR>
MSKQH R2, R6, R2 ; R2 = yyy0 0000 <BR>
MSKQL R1, R6, R1 ; R1 = 000x xxxx <BR>
OR R2, R4, R2 ; R2 = yyyH GFED <BR>
OR R1, R3, R1 ; R1 = CBAx xxxx <BR>
STQ_ U R2, X+ 7( R11) ; Must store high then low for <BR>
STQ_ U R1, X( R11) ; degenerate case of aligned QW <BR>
</TT><P>
The intended sequence for storing an unaligned longword R5 at X is: <BR>
<TT>LDA R6, X( R11) ; R6&lt; 2: 0&gt; = (X mod 8) = 5 <BR>
LDQ_ U R2, X+ 3( R11) ; Ignores va&lt; 2: 0&gt;, R2 = yyyy yyyD <BR>
LDQ_ U R1, X( R11) ; Ignores va&lt; 2: 0&gt;, R1 = CBAx xxxx <BR>
INSLH R5, R6, R4 ; R4 = 0000 000D <BR>
INSLL R5, R6, R3 ; R3 = CBA0 0000 <BR>
MSKLH R2, R6, R2 ; R2 = yyyy yyy0 <BR>
MSKLL R1, R6, R1 ; R1 = 000x xxxx <BR>
OR R2, R4, R2 ; R2 = yyyy yyyD <BR>
OR R1, R3, R1 ; R1 = CBAx xxxx <BR>
STQ_ U R2, X+ 3( R11) ; Must store high then low for <BR>
STQ_ U R1, X( R11) ; degenerate case of aligned </TT>
114
<BR>
<A href=#page114>114</A>
<strong><A name=page115> Page 115</A></strong>
<A href=#page116>116</A>
<BR>
Instruction Descriptions <B>4– 59 <BR>
</B>For software that is not designed to use the BWX extension, the intended sequence for storing <BR>
an unaligned word R5 at X is: <BR>
<P>
<TT>LDA R6, X( R11) ; R6&lt; 2: 0&gt; = (X mod 8) = 5 <BR>
LDQ_ U R2, X+ 1( R11) ; Ignores va&lt; 2: 0&gt;, R2 = yBAx xxxx <BR>
LDQ_ U R1, X( R11) ; Ignores va&lt; 2: 0&gt;, R1 = yBAx xxxx <BR>
INSWH R5, R6, R4 ; R4 = 0000 0000 <BR>
INSWL R5, R6, R3 ; R3 = 0BA0 0000 <BR>
MSKWH R2, R6, R2 ; R2 = yBAx xxxx <BR>
MSKWL R1, R6, R1 ; R1 = y00x xxxx <BR>
OR R2, R4, R2 ; R2 = yBAx xxxx <BR>
OR R1, R3, R1 ; R1 = yBAx xxxx <BR>
STQ_ U R2, X+ 1( R11) ; Must store high then low for <BR>
STQ_ U R1, X( R11) ; degenerate case of aligned <BR>
</TT><P>
For software that is not designed to use the BWX extension, the intended sequence for storing <BR>
a byte R5 at X is: <BR>
<P>
<TT>LDA R6, X( R11) ; R6&lt; 2: 0&gt; = (X mod 8) = 5 <BR>
LDQ_ U R1, X( R11) ; Ignores va&lt; 2: 0&gt;, R1 = yyAx xxxx <BR>
INSBL R5, R6, R3 ; R3 = 00A0 0000 <BR>
MSKBL R1, R6, R1 ; R1 = yy0x xxxx <BR>
OR R1, R3, R1 ; R1 = yyAx xxxx <BR>
STQ_ U R1, X( R11) ; </TT>
115
<BR>
<A href=#page115>115</A>
<strong><A name=page116> Page 116</A></strong>
<A href=#page117>117</A>
<BR>
<B>4– 60 </B>Alpha Architecture Handbook <BR>
<B>4.6. 5 Sign Extend <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>CASE <BR>
SEXTB: Rc </TT>¬ <TT>SEXT( Rbv&lt; 07: 0&gt;) <BR>
SEXTW: Rc </TT>¬ <TT>SEXT( Rbv&lt; 15: 0&gt;) <BR>
ENDCASE <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>The byte or word in register Rb is sign-extended to 64 bits and written to register Rc. Ra must <BR>
be R31. <BR>
<P>
<B>Implementation Note: <BR>
</B>The SEXTB and SEXTW instructions are supported in hardware on Alpha <BR>
implementations for which the AMASK instruction returns bit 0 set. SEXTB and SEXTW <BR>
are supported with software emulation in Alpha implementations for which AMASK does <BR>
not return bit 0 set. Software emulation of SEXTB and SEXTW is significantly slower <BR>
than hardware support. <BR>
<P>
SEXTx Rb. rq, Rc. wq !Operate format <BR>
SEXTx #b. ib, Rc. wq !Operate format <BR>
<P>
None <BR>
SEXTB Sign Extend Byte <BR>
SEXTW Sign Extend Word <BR>
<P>
None 
116
<BR>
<A href=#page116>116</A>
<strong><A name=page117> Page 117</A></strong>
<A href=#page118>118</A>
<BR>
Instruction Descriptions <B>4– 61 <BR>
4.6. 6 Zero Bytes <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>CASE <BR>
ZAP: <BR>
Rc </TT>¬ <TT>BYTE_ ZAP( Rav, Rbv&lt; 7: 0&gt;) <BR>
</TT><P>
<TT>ZAPNOT: <BR>
Rc </TT>¬ <TT>BYTE_ ZAP( Rav, NOT Rbv&lt; 7: 0&gt;) <BR>
ENDCASE <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>ZAP and ZAPNOT set selected bytes of register Ra to zero and store the result in register Rc. <BR>
Register Rb&lt; 7: 0&gt; selects the bytes to be zeroed. Bit 0 of Rbv corresponds to byte 0, bit 1 of <BR>
Rbv corresponds to byte 1, and so on. A result byte is set to zero if the corresponding bit of <BR>
Rbv is a one for ZAP and a zero for ZAPNOT. <BR>
<P>
ZAPx Ra. rq, Rb. rq, Rc. wq !Operate format <BR>
ZAPx Ra. rq,# b. ib, Rc. wq !Operate format <BR>
<P>
None <BR>
ZAP Zero Bytes <BR>
ZAPNOT Zero Bytes Not <BR>
<P>
None 
117
<BR>
<A href=#page117>117</A>
<strong><A name=page118> Page 118</A></strong>
<A href=#page119>119</A>
<BR>
<B>4– 62 </B>Alpha Architecture Handbook <BR>
<B>4. 7 Floating-Point Instructions <BR>
</B>Alpha provides instructions for operating on floating-point operands in each of four data <BR>
formats: <BR>
<P>
<B>° </B>F_ floating (VAX single) <BR>
<B>° </B>G_ floating (VAX double, 11-bit exponent) <BR>
<B>° </B>S_ floating (IEEE single) <BR>
<B>° </B>T_ floating (IEEE double, 11-bit exponent) <BR>
Data conversion instructions are also provided to convert operands between floating-point and <BR>
quadword integer formats, between double and single floating, and between quadword and <BR>
longword integers. <BR>
<P>
<B>Note: <BR>
</B>D_ floating is a partially supported datatype; no D_ floating arithmetic operations are <BR>
provided in the architecture. For backward compatibility, exact D_ floating arithmetic may <BR>
be provided via software emulation. D_ floating "format compatibility," in which binary <BR>
files of D_ floating numbers may be processed but without the last 3 bits of fraction <BR>
precision, can be obtained via conversions to G_ floating, G arithmetic operations, then <BR>
conversion back to D_ floating. <BR>
<P>
The choice of data formats is encoded in each instruction. Each instruction also encodes the <BR>
choice of rounding mode and the choice of trapping mode. <BR>
<P>
All floating-point operate instructions (not including loads or stores) that yield an F_ floating or <BR>
G_ floating zero result must materialize a true zero. <BR>
<P>
<B>4.7. 1 Single-Precision Operations <BR>
</B>Single-precision values (F_ floating or S_ floating) are stored in the floating-point registers in <BR>
canonical form, as subsets of double-precision values, with 11-bit exponents restricted to the <BR>
corresponding single-precision range, and with the 29 low-order fraction bits restricted to be all <BR>
zero. <BR>
<P>
Single-precision operations applied to canonical single-precision values give single-precision <BR>
results. Single-precision operations applied to non-canonical operands give UNPREDICT-ABLE <BR>
results. <BR>
<P>
Longword integer values in floating-point registers are stored in bits &lt;63: 62,58: 29&gt;, with bits <BR>
&lt;61: 59&gt; ignored and zeros in bits &lt;28: 0&gt;. <BR>
<P>
<B>4.7. 2 Subsets and Faults <BR>
</B>All floating-point operations may take floating disabled faults. Any subsetted floating-point <BR>
instruction may take an Illegal Instruction Trap. These faults are not explicitly listed in the <BR>
description of each instruction. 
118
<BR>
<A href=#page118>118</A>
<strong><A name=page119> Page 119</A></strong>
<A href=#page120>120</A>
<BR>
Instruction Descriptions <B>4– 63 <BR>
</B>All floating-point loads and stores may take memory management faults (access control viola-tion, <BR>
translation not valid, fault on read/ write, data alignment). <BR>
<P>
The floating-point enable (FEN) internal processor register (IPR) allows system software to <BR>
restrict access to the floating-point registers. <BR>
<P>
If a floating-point instruction is implemented and FEN = 0, attempts to execute the instruction <BR>
cause a floating disabled fault. <BR>
<P>
If a floating-point instruction is not implemented, attempts to execute the instruction cause an <BR>
Illegal Instruction Trap. This rule holds regardless of the value of FEN. <BR>
<P>
An Alpha implementation may provide both VAX and IEEE floating-point operations, either, <BR>
or none. <BR>
<P>
Some floating-point instructions are common to the VAX and IEEE subsets, some are VAX <BR>
only, and some are IEEE only. These are designated in the descriptions that follow. If either <BR>
subset is implemented, all the common instructions must be implemented. <BR>
<P>
An implementation that includes IEEE floating-point may subset the ability to perform round-ing <BR>
to plus infinity and minus infinity. If not implemented, instructions requesting these <BR>
rounding modes take Illegal Instruction Trap. <BR>
<P>
An implementation that includes IEEE floating-point may implement any subset of the Trap <BR>
Disable flags (DNOD, DZED, INED, INVD, OVFD, and UNFD) and Denormal Control flags <BR>
(DNZ and UNDZ) in the FPCR: <BR>
<P>
<B>° </B>If a Trap Disable flag is not implemented, then the corresponding trap occurs as usual. <BR>
<B>° </B>If DNZ is not implemented, then any IEEE operation with a denormal input must take an Invalid Operation Trap. <BR>
<P>
<B>° </B>If UNDZ is not implemented, then any IEEE operation that includes a /S qualifier that underflows must take an Underflow Trap. <BR>
<B>° </B>If DZED is implemented, then IEEE division of 0/ 0 must be treated as an invalid opera-tion instead of a division by zero. <BR>
Any unimplemented bits in the FPCR are read as zero and ignored when set. <BR>
<B>4.7. 3 Definitions <BR>
</B>The following definitions apply to Alpha floating-point support. <BR>
<P>
<B>Alpha finite number <BR>
</B>A floating-point number with a definite, in-range value. Specifically, all numbers in the inclu-sive <BR>
ranges –MAX through –MIN, zero, and +MIN through +MAX, where MAX is the largest <BR>
non-infinite representable floating-point number and MIN is the smallest non-zero represent-able <BR>
normalized floating-point number. 
119
<BR>
<A href=#page119>119</A>
<strong><A name=page120> Page 120</A></strong>
<A href=#page121>121</A>
<BR>
<B>4– 64 </B>Alpha Architecture Handbook <BR>
For VAX floating-point, finites do not include reserved operands or dirty zeros (this differs <BR>
from the usual VAX interpretation of dirty zeros as finite). For IEEE floating-point, finites do <BR>
not include infinites, NaNs, or denormals, but do include minus zero. <BR>
<P>
<B>denormal <BR>
</B>An IEEE floating-point bit pattern that represents a number whose magnitude lies between <BR>
zero and the smallest finite number. <BR>
<P>
<B>dirty zero <BR>
</B>A VAX floating-point bit pattern that represents a zero value, but not in true-zero form. <BR>
<P>
<B>infinity <BR>
</B>An IEEE floating-point bit pattern that represents plus or minus infinity. <BR>
<P>
<B>LSB <BR>
</B>The least significant bit. For a positive finite representable number A, A + 1 LSB is the next <BR>
larger representative number, and A + ½ LSB is exactly halfway between A and the next larger <BR>
representable number. For a positive representable number A whose fraction field is not all <BR>
zeros, A – 1 LSB is the next smaller representable number, and A – ½ LSB is exactly halfway <BR>
between <I>A </I>and the next smaller representable number. <BR>
<P>
<B>non-finite number <BR>
</B>An IEEE infinity, NaN, denormal number, or a VAX dirty zero or reserved operand. <BR>
<P>
<B>Not-a-Number <BR>
</B>An IEEE floating-point bit pattern that represents something other than a number. This comes <BR>
in two forms: signaling NaNs (for Alpha, those with an initial fraction bit of 0) and quiet NaNs <BR>
(for Alpha , those with initial fraction bit of 1). <BR>
<P>
<B>representable result <BR>
</B>A real number that can be represented exactly as a VAX or IEEE floating-point number, with <BR>
finite precision and bounded exponent range. <BR>
<P>
<B>reserved operand <BR>
</B>A VAX floating-point bit pattern that represents an illegal value. <BR>
<P>
<B>trap shadow <BR>
</B>The set of instructions potentially executed after an instruction that signals an arithmetic trap <BR>
but before the trap is actually taken. <BR>
<P>
<B>true result <BR>
</B>The mathematically correct result of an operation, assuming that the input operand values are <BR>
exact. The true result is typically rounded to the nearest representable result. 
120
<BR>
<A href=#page120>120</A>
<strong><A name=page121> Page 121</A></strong>
<A href=#page122>122</A>
<BR>
Instruction Descriptions <B>4– 65 <BR>
true zero <BR>
</B>The value +0, represented as exactly 64 zeros in a floating-point register. <BR>
<P>
<B>4.7. 4 Encodings <BR>
</B>Floating-point numbers are represented with three fields: sign, exponent, and fraction. The sign <BR>
is 1 bit; the exponent is 8, 11, or 15 bits; and the fraction is 23, 52, 55, or 112 bits. Some <BR>
encodings represent special values: <BR>
<P>
The values of MIN and MAX for each of the five floating-point data formats are: <BR>
<B>Sign Exponent Fraction Vax Meaning VAX Finite IEEE Meaning IEEE Finite <BR>
</B>x All-1's Non-zero Finite Yes +/– NaN No <BR>
x All-1's 0 Finite Yes +/– Infinity No <BR>
0 0 Non-zero Dirty zero No +Denormal No <BR>
1 0 Non-zero Resv. operand No –Denormal No <BR>
0 0 0 True zero Yes +0 Yes <BR>
1 0 0 Resv. operand No –0 Yes <BR>
x Other x Finite Yes finite Yes <BR>
<P>
<B>Data <BR>
Format MIN MAX <BR>
</B><P>
F_ floating 2**– 127 * 0.5 2** 127 *( 1.0 – 2**– 24) <BR>
(0. 293873588e– 38) (1. 7014117e38) <BR>
<P>
G_ floating 2**– 1023 * 0.5 2** 1023 * (1. 0 – 2**– 53) <BR>
(0. 5562684646268004e– 308) (0. 89884656743115785407e308) <BR>
<P>
S_ floating 2**– 126 * 1.0 2** 127 * (2. 0 – 2**– 23) <BR>
(1. 17549435e– 38) (3. 40282347e38) <BR>
<P>
T_ floating 2**– 1022 * 1.0 2** 1023 * (2. 0 – 2**– 52) <BR>
(2. 2250738585072013e– 308) (1. 7976931348623158e308) <BR>
<P>
X_ floating 2**– 16382* 1.0 2** 16383*( 2. 0– 2**– 112) <BR>
(See below * ) <BR>
* (1. 18973149535723176508575932662800702e4932) <BR>
(See below * ) <BR>
<P>
* (3. 36210314311209350626267781732175260e– 4932) 
121
<BR>
<A href=#page121>121</A>
<strong><A name=page122> Page 122</A></strong>
<A href=#page123>123</A>
<BR>
<P>
<B>4– 66 </B>Alpha Architecture Handbook <BR>
<B>4.7. 5 Rounding Modes <BR>
</B>All rounding modes map a true result that is exactly representable to that representable value. <BR>
<P>
<B>VAX Rounding Modes <BR>
</B>For VAX floating-point operations, two rounding modes are provided and are specified in each <BR>
instruction: normal (biased) rounding and chopped rounding. <BR>
<P>
Normal VAX rounding maps the true result to the nearest of two representable results, with <BR>
true results exactly halfway between mapped to the larger in absolute value (sometimes called <BR>
biased rounding away from zero); maps true results ³ MAX + 1/ 2 LSB in magnitude to an <BR>
overflow; maps true results &lt; MIN – 1/ 4 LSB in magnitude to an underflow. <BR>
<P>
Chopped VAX rounding maps the true result to the smaller in magnitude of two surrounding <BR>
representable results; maps true results ³ MAX + 1 LSB in magnitude to an overflow; maps <BR>
true results &lt; MIN in magnitude to an underflow. <BR>
<P>
<B>IEEE Rounding Modes <BR>
</B>For IEEE floating-point operations, four rounding modes are provided: normal rounding (unbi-ased <BR>
round to nearest), rounding toward minus infinity, round toward zero, and rounding <BR>
toward plus infinity. The first three can be specified in the instruction. Rounding toward plus <BR>
infinity can be obtained by setting the Floating-point Control Register (FPCR) to select it and <BR>
then specifying dynamic rounding mode in the instruction (See <A href="#page135">Section 4.7.8). </A>
Alpha IEEE <BR>
arithmetic does rounding before detecting overflow/ underflow. <BR>
<P>
Normal IEEE rounding maps the true result to the nearest of two representable results, with <BR>
true results exactly halfway between mapped to the one whose fraction ends in 0 (sometimes <BR>
called unbiased rounding to even); maps true results ³ MAX + 1/ 2 LSB in magnitude to an <BR>
overflow; maps true results &lt; MIN – 1/ 2 LSB in magnitude to an underflow. <BR>
<P>
Plus infinity IEEE rounding maps the true result to the larger of two surrounding representable <BR>
results; maps true results &gt; MAX in magnitude to an overflow; maps positive true results <BR>
£ +MIN – 1 LSB to an underflow; and maps negative true results &gt; –MIN to an underflow. <BR>
<P>
Minus infinity IEEE rounding maps the true result to the smaller of two surrounding represent-able <BR>
results; maps true results &gt; MAX in magnitude to an overflow; maps positive true results <BR>
&lt; +MIN to an underflow; and maps negative true results ³ –MIN + 1 LSB to an underflow. <BR>
<P>
Chopped IEEE rounding maps the true result to the smaller in magnitude of two surrounding <BR>
representable results; maps true results ³ MAX + 1 LSB in magnitude to an overflow; and <BR>
maps non-zero true results &lt; MIN in magnitude to an underflow. <BR>
<P>
Dynamic rounding mode uses the IEEE rounding mode selected by the FPCR register and is <BR>
described in more detail <A href="#page135">in Section 4.7. </A>
8. 
122
<BR>
<A href=#page122>122</A>
<strong><A name=page123> Page 123</A></strong>
<A href=#page124>124</A>
<BR>
<P>
Instruction Descriptions <B>4– 67 <BR>
</B>The following tables summarize the floating-point rounding modes: <BR>
<B>4.7. 6 Computational Models <BR>
</B>The Alpha architecture provides a choice of floating-point computational models. <BR>
<P>
There are two computational models available on systems that implement the VAX float-ing-<BR>
point subset: <BR>
<P>
<B>° </B>VAX-format arithmetic with precise exceptions <BR>
<B>° </B>High-performance VAX-format arithmetic <BR>
There are three computational models available on systems that implement the IEEE float-ing-<BR>
point subset: <BR>
<P>
<B>° </B>IEEE compliant arithmetic <BR>
<B>° </B>IEEE compliant arithmetic without inexact exception <BR>
<B>° </B>High-performance IEEE-format arithmetic <BR>
<P>
<B>4.7.6.1 VAX-Format Arithmetic with Precise Exceptions <BR>
</B>This model provides floating-point arithmetic that is fully compatible with the floating-point <BR>
arithmetic provided by the VAX architecture. It provides support for VAX non-finites and <BR>
gives precise exceptions. <BR>
<P>
This model is implemented by using VAX floating-point instructions with the /S, /SU, and /SV <BR>
trap qualifiers. Each instruction can determine whether it also takes an exception on underflow <BR>
or integer overflow. The performance of this model depends on how often computations <BR>
involve non-finite operands. Performance also depends on how an Alpha system chooses to <BR>
trade off implementation complexity between hardware and operating system completion han-dlers <BR>
(see <A href="#page129">Section 4.7.7.3). <BR>
</A>
<P>
<B>VAX Rounding Mode Instruction Notation <BR>
</B>Normal rounding (No qualifier) <BR>
Chopped /C <BR>
<P>
<B>IEEE Rounding Mode Instruction Notation <BR>
</B>Normal rounding (No qualifier) <BR>
Dynamic rounding /D <BR>
Plus infinity /D and ensure that FPCR&lt; DYN&gt; = '11' <BR>
Minus infinity /M <BR>
Chopped /C 
123
<BR>
<A href=#page123>123</A>
<strong><A name=page124> Page 124</A></strong>
<A href=#page125>125</A>
<BR>
<P>
<B>4– 68 </B>Alpha Architecture Handbook <BR>
<B>4.7.6.2 High-Performance VAX-Format Arithmetic <BR>
</B>This model provides arithmetic operations on VAX finite numbers. An imprecise arithmetic <BR>
trap is generated by any operation that involves non-finite numbers, floating overflow, and <BR>
divide-by-zero exceptions. <BR>
<P>
This model is implemented by using VAX floating-point instructions with a trap qualifier other <BR>
than /S, /SU, or /SV. Each instruction can determine whether it also traps on underflow or inte-ger <BR>
overflow. This model does not require the overhead of an operating system completion <BR>
handler and can be the faster of the two VAX models. <BR>
<P>
<B>4.7.6.3 IEEE-Compliant Arithmetic <BR>
</B>This model provides floating-point arithmetic that fully complies with the IEEE Standard for <BR>
Binary Floating-Point Arithmetic. It provides all of the exception status flags that are in the <BR>
standard. It provides a default where all traps and faults are disabled and where IEEE <BR>
non-finite values are used in lieu of exceptions. <BR>
<P>
Alpha operating systems provide additional mechanisms that allow the user to specify dynami-cally <BR>
which exception conditions should trap and which should proceed without trapping. The <BR>
operating systems also include mechanisms that allow alternative handling of denormal val-ues. <BR>
See Appendix <A href="#page291">B </A>
and the appropriate operating system documentation for a description of <BR>
these mechanisms. <BR>
<P>
This model is implemented by using IEEE floating-point instructions with the /SUI <BR>
or /SVI trap qualifiers. The performance of this model depends on how often computations <BR>
involve inexact results and non-finite operands and results. Performance also depends on how <BR>
the Alpha system chooses to trade off implementation complexity between hardware and oper-ating <BR>
system completion handlers (see <A href="#page129">Section 4. 7. 7. 3). </A>
This model provides acceptable <BR>
performance on Alpha systems that implement the inexact disable (INED) bit in the FPCR. <BR>
Performance may be slow if the INED bit is not implemented. <BR>
<P>
<B>4.7.6.4 IEEE-Compliant Arithmetic Without Inexact Exception <BR>
</B>This model is similar to the model in <A href="#page124">Section 4.7.6.3, </A>
except this model does not signal inexact <BR>
results either by the inexact status flag or by trapping. Combining routines that are compiled <BR>
with this model and routines that are compiled with the model in <A href="#page124">Section 4. 7. 6. 3 </A>
can give an <BR>
application better control over testing when an inexact operation will affect computational <BR>
accuracy. <BR>
<P>
This model is implemented by using IEEE floating-point instructions with the /SU or /SV trap <BR>
qualifiers. The performance of this model depends on how often computations involve <BR>
non-finite operands and results. Performance also depends on how an Alpha system chooses to <BR>
trade off implementation complexity between hardware and operating system completion han-dlers <BR>
(see <A href="#page129">Section 4.7.7.3). 
124
<BR>
<A href=#page124>124</A>
<strong><A name=page125> Page 125</A></strong>
<A href=#page126>126</A>
<BR>
<P>
</A>
Instruction Descriptions <B>4– 69 <BR>
4.7.6.5 High-Performance IEEE-Format Arithmetic <BR>
</B>This model provides arithmetic operations on IEEE finite numbers and notifies applications of <BR>
all exceptional floating-point operations. An imprecise arithmetic trap is generated by any <BR>
operation that involves non-finite numbers, floating overflow, divide-by-zero, and invalid <BR>
operations. Underflow results are set to zero. Conversion to integer results that overflow are set <BR>
to the low-order bits of the integer value. <BR>
<P>
This model is implemented by using IEEE floating-point instructions with a trap qualifier other <BR>
than /SU, /SV, /SUI, or /SVI. Each instruction can determine whether it also traps on under-flow <BR>
or integer overflow. This model does not require the overhead of an operating system <BR>
completion handler and can be the fastest of the three IEEE models. <BR>
<P>
<B>4.7. 7 Trapping Modes <BR>
</B>There are six exceptions that can be generated by floating-point operate instructions, all sig-naled <BR>
by an arithmetic exception trap. These exceptions are: <BR>
<P>
<B>° </B>Invalid operation <BR>
<B>° </B>Division by zero <BR>
<B>° </B>Overflow <BR>
<B>° </B>Underflow <BR>
<B>° </B>Inexact result <BR>
<B>° </B>Integer overflow (conversion to integer only) <BR>
<P>
<B>4.7.7.1 VAX Trapping Modes <BR>
</B>This section describes the characteristics of the four VAX trapping modes, which are summa-rized <BR>
in <A href="#page127">Table 4– 8. <BR>
</A>
<P>
<B>When no trap mode is specified (the default): <BR>
° </B>Arithmetic is performed on VAX finite numbers. <B>° </B>Operations give imprecise traps whenever the following occur: <BR>
<P>
– an operand is a non-finite number <BR>
– a floating overflow <BR>
– a divide-by-zero <BR>
<B>° </B>Traps are imprecise and it is not always possible to determine which instruction trig-gered a trap or the operands of that instruction. <BR>
<P>
<B>° </B>An underflow produces a zero result without trapping. <B>° </B>A conversion to integer that overflows uses the low-order bits of the integer as the <BR>
result without trapping. <BR>
<B>° </B>The result of any operation that traps is UNPREDICTABLE. 
125
<BR>
<A href=#page125>125</A>
<strong><A name=page126> Page 126</A></strong>
<A href=#page127>127</A>
<BR>
<P>
<B>4– 70 </B>Alpha Architecture Handbook <BR>
<B>When /U or /V mode is specified: <BR>
° </B>Arithmetic is performed on VAX finite numbers. <B>° </B>Operations give imprecise traps whenever the following occur: <BR>
<P>
– an operand is a non-finite number <BR>
– an underflow <BR>
– an integer overflow <BR>
– a floating overflow <BR>
– a divide-by-zero <BR>
<B>° </B>Traps are imprecise and it is not always possible to determine which instruction trig-gered a trap or the operands of that instruction. <BR>
<P>
<B>° </B>An underflow trap produces a zero result. <B>° </B>A conversion to integer trapping with an integer overflow produces the low-order bits <BR>
of the integer value. <BR>
<B>° </B>The result of any other operation that traps is UNPREDICTABLE. <BR>
<P>
<B>When /S mode is specified: <BR>
° </B>Arithmetic is performed on all VAX values, both finite and non-finite. <B>° </B>A VAX dirty zero is treated as zero. <BR>
<P>
<B>° </B>Exceptions are signaled for: – a VAX reserved operand, which generates an invalid operation exception <BR>
– a floating overflow <BR>
– a divide-by-zero <BR>
<B>° </B>Exceptions are precise and an application can locate the instruction that caused the exception, along with its operand values. <A href="#page129">See Section 4.7.7. </A>
3. <BR>
<P>
<B>° </B>An operation that underflows produces a zero result without taking an exception. <B>° </B>A conversion to integer that overflows uses the low-order bits of the integer as the <BR>
result, without taking an exception. <BR>
<B>° </B>When an operation takes an exception, the result of the operation is UNPREDICT-ABLE. <BR>
<P>
<B>When /SU or /SV mode is specified: <BR>
° </B>Arithmetic is performed on all VAX values, both finite and non-finite. <B>° </B>A VAX dirty zero is treated as zero. <BR>
<P>
<B>° </B>Exceptions are signaled for: – a VAX reserved operand, which generates an invalid operation exception <BR>
– an underflow <BR>
– an integer overflow <BR>
– a floating overflow <BR>
– a divide-by-zero <BR>
<B>° </B>Exceptions are precise and an application can locate the instruction that caused the exception, along with its operand values. <A href="#page129">See Section 4.7.7. </A>
3. <BR>
<P>
<B>° </B>An underflow exception produces a zero. <B>° </B>A conversion to integer exception with integer overflow produces the low-order bits of <BR>
the integer value. <BR>
<B>° </B>The result of any other operation that takes an exception is UNPREDICTABLE. 
126
<BR>
<A href=#page126>126</A>
<strong><A name=page127> Page 127</A></strong>
<A href=#page128>128</A>
<BR>
<P>
Instruction Descriptions <B>4– 71 <BR>
</B>A summary of the VAX trapping modes, instruction notation, and their meaning follows in <BR>
<A href="#page127">Table 4– 8: <BR>
</A>
<P>
<B>4.7.7.2 IEEE Trapping Modes <BR>
</B>This section describes the characteristics of the four IEEE trapping modes, which are summa-rized <BR>
in <A href="#page128">Table 4– 9. <BR>
</A>
<P>
<B>When no trap mode is specified (the default): <BR>
° </B>Arithmetic is performed on IEEE finite numbers. <B>° </B>Operations give imprecise traps whenever the following occur: <BR>
<P>
– an operand is a non-finite number <BR>
– a floating overflow <BR>
– a divide-by-zero <BR>
– an invalid operation <BR>
<B>° </B>Traps are imprecise, and it is not always possible to determine which instruction trig-gered a trap or the operands of that instruction. <BR>
<P>
<B>° </B>An underflow produces a zero result without trapping. <B>° </B>A conversion to integer that overflows uses the low-order bits of the integer as the <BR>
result without trapping. <BR>
<B>° </B>When an operation traps, the result of the operation is UNPREDICTABLE. <BR>
<P>
<B>When /U or /V mode is specified : <BR>
° </B>Arithmetic is performed on IEEE finite numbers. <B>° </B>Operations give imprecise traps whenever the following occur: <BR>
<P>
– an operand is a non-finite number <BR>
– an underflow <BR>
– an integer overflow <BR>
– a floating overflow <BR>
– a divide-by-zero <BR>
– an invalid operation <BR>
<P>
<B>Table 4– 8: VAX Trapping Modes Summary <BR>
Trap Mode Notation Meaning <BR>
</B>Underflow disabled No qualifier <BR>
/S <BR>
Imprecise <BR>
Precise exception completion <BR>
<P>
Underflow enabled /U <BR>
/SU <BR>
Imprecise <BR>
Precise exception completion <BR>
<P>
Integer overflow disabled No qualifier <BR>
/S <BR>
Imprecise <BR>
Precise exception completion <BR>
<P>
Integer overflow enabled /V <BR>
/SV <BR>
Imprecise <BR>
Precise exception completion 
127
<BR>
<A href=#page127>127</A>
<strong><A name=page128> Page 128</A></strong>
<A href=#page129>129</A>
<BR>
<P>
<B>4– 72 </B>Alpha Architecture Handbook <BR>
<B>° </B>Traps are imprecise, and it is not always possible to determine which instruction trig-gered a trap or the operands of that instruction. <BR>
<B>° </B>An underflow trap produces a zero. <B>° </B>A conversion to integer trap with an integer overflow produces the low-order bits of the <BR>
integer. <BR>
<B>° </B>The result of any other operation that traps is UNPREDICTABLE. <BR>
<P>
<B>When /SU or /SV mode is specified: <BR>
° </B>Arithmetic is performed on all IEEE values, both finite and non-finite. <B>° </B>Alpha systems support all IEEE features except inexact exception (which requires /SUI <BR>
<P>
or /SVI): <BR>
– The IEEE standard specifies a default where exceptions do not fault or trap. In com-bination <BR>
with the FPCR, this mode allows disabling exceptions and producing <BR>
IEEE compliant nontrapping results. See <A href="#page134">Sections 4.7. 7.10 </A>
<A href="#page135">and 4.7.7.11. <BR>
</A>
– Each Alpha operating system provides a way to optionally signal IEEE floating-<BR>
point exceptions. This mode enables the IEEE status flags that keep a record of <BR>
each exception that is encountered. An Alpha operating system uses the IEEE float-ing-<BR>
point control (FP_ C) quadword, described <A href="#page294">in Section B. 2.1, </A>
to maintain the <BR>
IEEE status flags and to enable calls to IEEE user signal handlers. <BR>
<B>° </B>Exceptions signaled in this mode are precise and an application can locate the instruc-tion that caused the exception, along with its operand values. <A href="#page129">See Section 4.7.7.3. <BR>
</A>
<P>
<B>When /SUI or /SVI mode is specified: <BR>
° </B>Arithmetic is performed on all IEEE values, both finite and non-finite. <B>° </B>Inexact exceptions are supported, along with all the other IEEE features supported by <BR>
<P>
the /SU or /SV mode. <BR>
A summary of the IEEE trapping modes, instruction notation, and their meaning follows in <BR>
<A href="#page128">Table 4– 9: <BR>
</A>
<P>
<B>Table 4– 9: Summary of IEEE Trapping Modes <BR>
Trap Mode Notation Meaning <BR>
</B>Underflow disabled and <BR>
inexact disabled <BR>
No qualifier Imprecise <BR>
<P>
Underflow enabled and <BR>
inexact disabled <BR>
/U <BR>
/SU <BR>
Imprecise <BR>
Precise exception completion <BR>
<P>
Underflow enabled and <BR>
inexact enabled <BR>
/SUI Precise exception completion <BR>
<P>
Integer overflow disabled and <BR>
inexact disabled <BR>
No qualifier Imprecise 
128
<BR>
<A href=#page128>128</A>
<strong><A name=page129> Page 129</A></strong>
<A href=#page130>130</A>
<BR>
<P>
Instruction Descriptions <B>4– 73 <BR>
4.7.7.3 Arithmetic Trap Completion <BR>
</B>Because floating-point instructions may be pipelined, the trap PC can be an arbitrary number <BR>
of instructions past the one triggering the trap. Those instructions that are executed after the <BR>
trigger instruction of an arithmetic trap are collectively referred to as the <I>trap shadow </I>of the <BR>
trigger instruction. <BR>
<P>
Marking floating-point instructions for exception completion with any valid qualifier combina-tion <BR>
that includes the /S qualifier enables the completion of the triggering instruction. For any <BR>
instruction so marked, the output register for the triggering instruction cannot also be one of <BR>
the input registers, so that an input register cannot be overwritten and the input value is avail-able <BR>
after a trap occurs. <BR>
<P>
See <A href="#page293">Section B. 2 </A>
for more information. <BR>
The AMASK instruction reports how the arithmetic trap should be completed: <BR>
<B>° </B>If AMASK returns with bit 9 clear, floating-point traps are imprecise. Exception com-pletion requires that generated code must obey the trap shadow rules in <A href="#page129">Section <BR>
</A>
<P>
<A href="#page129">4.7.7.3.1, </A>
with a trap shadow length as described <A href="#page130">in Section 4. 7.7.3. </A>
2. <BR>
<B>° </B>If AMASK returns with bit 9 set, the hardware implements precise floating-point traps. If the instruction has any valid qualifier combination that includes /S, the trap PC points <BR>
<P>
to the instruction that immediately follows the instruction that triggered the trap. The <BR>
trap shadow contains zero instructions; exception completion does not require that the <BR>
generated code follow the conditions in <A href="#page129">Section 4. 7.7.3. 1 </A>
and the length rules in <A href="#page130">Section <BR>
</A>
<A href="#page130">4.7.7.3.2. <BR>
</A>
<P>
<B>4.7.7.3.1 Trap Shadow Rules <BR>
</B>For an operating system (OS) completion handler to complete non-finite operands and excep-tions, <BR>
the following conditions must hold. <BR>
<P>
Conditions 1 and 2, below, allow an OS completion handler to locate the trigger instruction by <BR>
doing a linear scan backwards from the trap PC while comparing destination registers in the <BR>
trap shadow with the registers that are specified in the register write mask parameter to the <BR>
arithmetic trap. <BR>
<P>
Integer overflow enabled and <BR>
inexact disabled <BR>
/V <BR>
/SV <BR>
Imprecise <BR>
Precise exception completion <BR>
<P>
Integer overflow enabled and <BR>
inexact enabled <BR>
/SVI Precise exception completion <BR>
<P>
<B>Table 4– 9: Summary of IEEE Trapping Modes (Continued) <BR>
Trap Mode Notation Meaning </B>
129
<BR>
<A href=#page129>129</A>
<strong><A name=page130> Page 130</A></strong>
<A href=#page131>131</A>
<BR>
<P>
<B>4– 74 </B>Alpha Architecture Handbook <BR>
Condition 3 allows an OS completion handler to emulate the trigger instruction with its origi-nal <BR>
input operand values. <BR>
<P>
Condition 4 allows the handler to re-execute instructions in the trap shadow with their original <BR>
operand values. <BR>
<P>
Condition 5 prevents any unusual side effects that would cause problems on repeated execu-tion <BR>
of the instructions in the trap shadow. <BR>
<P>
<B>Conditions: <BR>
</B><P>
1. The destination register of the trigger instruction may not be used as the destination reg-ister <BR>
of any instruction in the trap shadow. <BR>
<P>
2. The trap shadow may not include any branch or jump instructions. <BR>
3. An instruction in the trap shadow may not modify an input to the trigger instruction. <BR>
4. The value in a register or memory location that is used as input to some instruction in the trap shadow may not be modified by a subsequent instruction in the trap shadow <BR>
<P>
unless that value is produced by an earlier instruction in the trap shadow. <BR>
5. The trap shadow may not contain any instructions with side effects that interact with earlier instructions in the trap shadow or with other parts of the system. Examples of <BR>
<P>
operations with prohibited side effects are: <BR>
– Modifications of the stack pointer or frame pointer that can change the accessibility <BR>
of stack variables and the exception context that is used by earlier instructions in <BR>
the trap shadow. <BR>
<P>
– Modifications of volatile values and access to I/ O device registers. <BR>
– If order of exception reporting is important, taking an arithmetic trap by an integer <BR>
instruction or by a floating-point instruction that does not include a /S qualifier, <BR>
either of which can report exceptions out of order. <BR>
<P>
An instruction may be in the trap shadows of multiple instructions that include a /S qualifier. <BR>
That instruction must obey all conditions for all those trap shadows. For example, the destina-tion <BR>
register of an instruction in multiple trap shadows must be different than the destination <BR>
registers of each possible trigger instruction. <BR>
<P>
<B>4.7.7.3.2 Trap Shadow Length Rules <BR>
</B>The trap shadow length rules in <A href="#page131">Table 4– 10 </A>
apply only to those floating-point instructions with <BR>
any valid qualifier combination that includes a /S trap qualifier. Further, the instruction to <BR>
which the trap shadow extends is not part of the trap shadow and that instruction is not exe-cuted <BR>
prior to the arithmetic trap that is signaled by the trigger instruction. <BR>
<P>
<B>Implementation notes: <BR>
</B><P>
<B>° </B>On Alpha implementations for which the IMPLVER instruction returns the value 0, the trap shadow of an instruction may extend after the result is consumed by a float-ing-<BR>
<P>
point STx instruction. On all other implementations, the trap shadow ends when a <BR>
result is consumed. <BR>
<P>
<B>° </B>Because Alpha implementations need not execute instructions that have R31 or F31 as the destination operand, instructions with such an destination should not be thought to <BR>
<P>
end a trap shadow. 
130
<BR>
<A href=#page130>130</A>
<strong><A name=page131> Page 131</A></strong>
<A href=#page132>132</A>
<BR>
<P>
Instruction Descriptions <B>4– 75 <BR>
Table 4– 10: Trap Shadow Length Rules <BR>
Floating-Point <BR>
Instruction Group <BR>
Trap Shadow Extends Until Any of the Following <BR>
Occurs: <BR>
</B><P>
Floating-point operate <BR>
(except DIVx and SQRTx) <BR>
<P>
<B>° </B>Encountering a CALL_ PAL, EXCB, or TRAPB instruction. <BR>
<P>
<B>° </B>The result is consumed by any instruction except floating-point STx. <BR>
<B>° </B>The fourth instruction * after the result is consumed by a floating-point STx instruction. <BR>
Or, following the floating-point STx of the result, the <BR>
result of a LDx that loads the stored value is <BR>
consumed by any instruction. <BR>
<P>
<B>° </B>The result of a subsequent floating-point operate instruction is consumed by any instruction except <BR>
<P>
floating-point STx. <BR>
<B>° </B>The second <A href="#page132">instruction * </A>
after the result of a subse-quent floating-point operate </A>
instruction is consumed <BR>
<P>
by a floating-point STx instruction. <BR>
<B>° </B>The result of a subsequent floating-point DIVx or SQRTx instruction is consumed by any instruction. <BR>
<P>
Floating-point DIVx <BR>
<B>° </B>Encountering a CALL_ PAL, EXCB, or TRAPB instruction. <BR>
<P>
<B>° </B>The result is consumed by any instruction except floating-point STx. <BR>
<B>° </B>The fourth <A href="#page132">instruction * </A>
after the result is consumed by a floating-point STx instruction. <BR>
</A>
Or, following the floating-point STx of the result, the <BR>
result of a LDx that loads the stored value is <BR>
consumed by any instruction. <BR>
<P>
<B>° </B>The result of a subsequent floating-point DIVx is con-sumed by any instruction. 
131
<BR>
<A href=#page131>131</A>
<strong><A name=page132> Page 132</A></strong>
<A href=#page133>133</A>
<BR>
<P>
<B>4– 76 </B>Alpha Architecture Handbook <BR>
<B>4.7.7.4 Invalid Operation (INV) Arithmetic Trap <BR>
</B>An invalid operation arithmetic trap is signaled if an operand is a non-finite number or if an <BR>
operand is invalid for the operation to be performed. (Note that CMPTxy does not trap on plus <BR>
or minus infinity.) Invalid operations are: <BR>
<P>
<B>° </B>Any operation on a signaling NaN. <BR>
<B>° </B>Addition of unlike-signed infinities or subtraction of like-signed infinities, such as (+ infinity + –infinity) or (+ infinity – +infinity). <BR>
<P>
<B>° </B>Multiplication of 0*infinity. <BR>
<B>° </B>IEEE division of 0/ 0 or infinity/infinity. <BR>
<B>° </B>Conversion of an infinity or NaN to an integer. <BR>
<B>° </B>CMPTLE or CMPTLT when either operand is a NaN. <BR>
<B>° </B>SQRTx of a negative non-zero number. <BR>
The instruction cannot disable the trap and, if the trap occurs, an UNPREDICTABLE value is <BR>
stored in the result register. However, under some conditions, the FPCR can dynamically dis-able <BR>
the trap, as described in <A href="#page134">Section 4.7.7.10, </A>
producing a correct IEEE result, as described in <BR>
<A href="#page144">Section 4. 7.10. <BR>
</A>
<P>
IEEE-compliant system software must also supply an invalid operation indication to the user <BR>
for x REM 0 and for conversions to integer that take an integer overflow trap. <BR>
<P>
If an implementation does not support the DZED (division by zero disable) bit, it may respond <BR>
to the IEEE division of 0/ 0 by delivering a division by zero trap to the operating system, which <BR>
IEEE compliant software must change to an invalid operation trap for the user. <BR>
<P>
Floating-point SQRTx <BR>
<B>° </B>Encountering a CALL_ PAL, EXCB, or TRAPB instruction. <BR>
<P>
<B>° </B>The result is consumed by any instruction. <BR>
<B>° </B>The result of a subsequent SQRTx instruction is con-sumed by any instruction. <BR>
<P>
* The length of four instructions is a conservative estimate of how far the trap shadow may <BR>
extend past a consuming floating-point STx instruction. The length of two instructions is a <BR>
conservative estimate of how far the trap shadow may extend after a subsequent float-ing-<BR>
point operate instruction is consumed by a floating-point STx instruction. Compilers can <BR>
make a more precise estimate by consulting the <I>DECchip 21064 and DECchip 21064A <BR>
Alpha AXP Microprocessors Hardware Reference Manual, EC-QD2RA-TE. <BR>
</I><P>
<B>Table 4– 10: Trap Shadow Length Rules (Continued) <BR>
Floating-Point <BR>
Instruction Group <BR>
Trap Shadow Extends Until Any of the Following <BR>
Occurs: </B>
132
<BR>
<A href=#page132>132</A>
<strong><A name=page133> Page 133</A></strong>
<A href=#page134>134</A>
<BR>
<P>
Instruction Descriptions <B>4– 77 <BR>
</B>An implementation may choose not to take an INV trap for a valid IEEE operation that <BR>
involves denormal operands if: <BR>
<P>
<B>° </B>The instruction is modified by any valid qualifier combination that includes the /S (exception completion) qualifier. <BR>
<P>
<B>° </B>The implementation supports the DNZ (denormal operands to zero) bit and DNZ is set. <BR>
<B>° </B>The instruction produces the result and exceptions required by <A href="#page144">Section 4.7. 10, </A>
as modi-fied by the DNZ bit described <A href="#page135">in Section 4.7.7.11. <BR>
</A>
<P>
An implementation may choose not to take an INV trap for a valid IEEE operation that <BR>
involves denormal operands, and direct hardware implementation of denormal arithmetic is <BR>
permitted if: <BR>
<P>
<B>° </B>The instruction is modified by any valid qualifier combination that includes the /S (exception completion) qualifier. <BR>
<P>
<B>° </B>The implementation supports both the DNOD (denormal operand exception disable) bit and the DNZ (denormal operands to zero) bit and DNOD is set while DNZ is clear. <BR>
<B>° </B>The instruction produces the result and exceptions required by <A href="#page144">Section 4.7.10, </A>
possibly modified by the UDNZ bit described <A href="#page135">in Section 4.7. 7.11. <BR>
</A>
Regardless of the setting of the INVD (invalid operation disable) bit, the implementation may <BR>
choose not to trap on valid operations that involve quiet NaNs and infinities as operands for <BR>
IEEE instructions that are modified by any valid qualifier combination that includes the /S <BR>
(exception completion) qualifier. <BR>
<P>
<B>4.7.7.5 Division by Zero (DZE) Arithmetic Trap <BR>
</B>A division by zero arithmetic trap is taken if the numerator does not cause an invalid operation <BR>
trap and the denominator is zero. <BR>
<P>
The instruction cannot disable the trap and, if the trap occurs, an UNPREDICTABLE value is <BR>
stored in the result register. However, under some conditions, the FPCR can dynamically dis-able <BR>
the trap, as described in <A href="#page134">Section 4.7.7.10, </A>
producing a correct IEEE result, as described in <BR>
<A href="#page144">Section 4. 7.10. <BR>
</A>
<P>
If an implementation does not support the DZED (division by zero disable) bit, it may respond <BR>
to the IEEE division of 0/ 0 by delivering a division by zero trap to the operating system, which <BR>
IEEE compliant software must change to an invalid operation trap for the user. <BR>
<P>
<B>4.7.7.6 Overflow (OVF) Arithmetic Trap <BR>
</B>An overflow arithmetic trap is signaled if the rounded result exceeds in magnitude the largest <BR>
finite number of the destination format. <BR>
<P>
The instruction cannot disable the trap and, if the trap occurs, an UNPREDICTABLE value is <BR>
stored in the result register. However, under some conditions, the FPCR can dynamically dis-able <BR>
the trap, as described in <A href="#page134">Section 4.7.7.10, </A>
producing a correct IEEE result, as described in <BR>
<A href="#page144">Section 4. 7.10. 
133
<BR>
<A href=#page133>133</A>
<strong><A name=page134> Page 134</A></strong>
<A href=#page135>135</A>
<BR>
<P>
</A>
<B>4– 78 </B>Alpha Architecture Handbook <BR>
<B>4.7.7.7 Underflow (UNF) Arithmetic Trap <BR>
</B>An underflow occurs if the rounded result is smaller in magnitude than the smallest finite num-ber <BR>
of the destination format. <BR>
<P>
If an underflow occurs, a true zero (64 bits of zero) is always stored in the result register. In the <BR>
case of an IEEE operation that takes an underflow arithmetic trap, a true zero is stored even if <BR>
the result after rounding would have been –0 (underflow below the negative denormal range). <BR>
<P>
If an underflow occurs and underflow traps are enabled by the instruction, an underflow arith-metic <BR>
trap is signaled. However, under some conditions, the FPCR can dynamically disable the <BR>
trap, as described in <A href="#page134">Section 4.7.7.10, </A>
producing the result described in <A href="#page144">Section 4.7.10, </A>
as mod-ified <BR>
by the UNDZ bit described <A href="#page135">in Section 4.7.7.11. <BR>
</A>
<P>
<B>4.7.7.8 Inexact Result (INE) Arithmetic Trap <BR>
</B>An inexact result occurs if the infinitely precise result differs from the rounded result. <BR>
<P>
If an inexact result occurs, the normal rounded result is still stored in the result register. If an <BR>
inexact result occurs and inexact result traps are enabled by the instruction, an inexact result <BR>
arithmetic trap is signaled. However, under some conditions, the FPCR can dynamically dis-able <BR>
the trap; see <A href="#page134">Section 4.7.7. 10 </A>
for information. <BR>
<P>
<B>4.7.7.9 Integer Overflow (IOV) Arithmetic Trap <BR>
</B>In conversions from floating to quadword integer, an integer overflow occurs if the rounded <BR>
result is outside the range –2** 63.. 2** 63– 1. In conversions from quadword integer to long-word <BR>
integer, an integer overflow occurs if the result is outside the range –2** 31.. 2** 31– 1. <BR>
<P>
If an integer overflow occurs in CVTxQ or CVTQL, the true result truncated to the low-order <BR>
64 or 32 bits respectively is stored in the result register. <BR>
<P>
If an integer overflow occurs and integer overflow traps are enabled by the instruction, an inte-ger <BR>
overflow arithmetic trap is signaled. <BR>
<P>
<B>4.7.7.10 IEEE Floating-Point Trap Disable Bits <BR>
</B>In the case of IEEE exception completion modes, any of the traps described in Sections <A href="#page132">4.7.7.4 <BR>
</A>
through <A href="#page134">4. 7. 7. 9 </A>
may be disabled by setting the appropriate trap disable bit in the FPCR. The <BR>
trap disable bits only affect the IEEE trap modes when the instruction is modified by any valid <BR>
qualifier combination that includes the /S (exception completion) qualifier. The trap disable <BR>
bits (DNOD, DZED, INED, INVD, OVFD, and UNFD) do not affect any of the VAX trap <BR>
modes. <BR>
<P>
If a trap disable bit is set and the corresponding trap condition occurs, the hardware implemen-tation <BR>
sets the result of the operation to the nontrapping result value as specified in the IEEE <BR>
standard and <A href="#page144">Section 4.7.10 </A>
and modified by the denormal control bits. If the implementation <BR>
is unable to calculate the required result, it ignores the trap disable bit and signals a trap as <BR>
usual. <BR>
<P>
Note that a hardware implementation may choose to support any subset of the trap disable bits, <BR>
including the empty subset. 
134
<BR>
<A href=#page134>134</A>
<strong><A name=page135> Page 135</A></strong>
<A href=#page136>136</A>
<BR>
<P>
Instruction Descriptions <B>4– 79 <BR>
4.7.7.11 IEEE Denormal Control Bits <BR>
</B>In the case of IEEE exception completion modes, the handling of denormal operands and <BR>
results is controlled by the DNZ and UNDZ bits in the FPCR. These denormal control bits only <BR>
affect denormal handling by IEEE instructions that are modified by any valid qualifier combi-nation <BR>
that includes the /S (exception completion) qualifier. <BR>
<P>
The denormal control bits apply only to the IEEE operate instructions – ADD, SUB, MUL, <BR>
DIV, SQRT, CMPxx, and CVT with floating-point source operand. <BR>
<P>
If both the UNFD (underflow disable) bit and the UNDZ (underflow to zero) bit are set in the <BR>
FPCR, the implementation sets the result of an underflow operation to a true zero result. The <BR>
zeroing of a denormal result by UNDZ must also be treated as an inexact result. <BR>
<P>
If the DNZ (denormal operands to zero) bit is set in the FPCR, the implementation treats each <BR>
denormal operand as if it were a signed zero value. The source operands in the register are not <BR>
changed. If DNZ is set, IEEE operations with any valid qualifier combination that includes a /S <BR>
qualifier signal arithmetic traps as if any denormal operand were zero; that is, with DNZ set: <BR>
<P>
<B>° </B>An IEEE operation with a denormal operand never generates an overflow, underflow, or inexact result arithmetic trap. <BR>
<P>
<B>° </B>Dividing by a denormal operand is a division by zero or invalid operation as appropri-ate. <BR>
<B>° </B>Multiplying a denormal by infinity is an invalid operation. <BR>
<B>° </B>A SQRT of a negative denormal produces a –0 instead of an invalid operation. <BR>
<B>° </B>A denormal operand, treated as zero, does not take the denormal operand exception trap controlled by the DNOD bit in the FPCR. <BR>
<P>
Note that a hardware implementation may choose to support any subset of the denormal con-trol <BR>
bits, including the empty subset. <BR>
<P>
<B>4.7. 8 Floating-Point Control Register (FPCR) <BR>
</B>When an IEEE floating-point operate instruction specifies dynamic mode (/ D) in its function <BR>
field (function field bits &lt;12: 11&gt; = 11), the rounding mode to be used for the instruction is <BR>
derived from the FPCR register. The layout of the rounding mode bits and their assignments <BR>
matches exactly the format used in the 11-bit function field of the floating-point operate <BR>
instructions. The function field is described <A href="#page140">in Section 4.7.9. <BR>
</A>
<P>
In addition, the FPCR gives a summary of each exception type for the exception conditions <BR>
detected by all IEEE floating-point operates thus far, as well as an overall summary bit that <BR>
indicates whether any of these exception conditions has been detected. The individual excep-tion <BR>
bits match exactly in purpose and order the exception bits found in the exception summary <BR>
quadword that is pushed for arithmetic traps. However, for each instruction, these exception <BR>
bits are set independent of the trapping mode specified for the instruction. Therefore, even <BR>
though trapping may be disabled for a certain exceptional condition, the fact that the excep-tional <BR>
condition was encountered by an instruction is still recorded in the FPCR. <BR>
<P>
Floating-point operates that belong to the IEEE subset and CVTQL, which belongs to both 
135
<BR>
<A href=#page135>135</A>
<strong><A name=page136> Page 136</A></strong>
<A href=#page137>137</A>
<BR>
<P>
<B>4– 80 </B>Alpha Architecture Handbook <BR>
VAX and IEEE subsets, appropriately set the FPCR exception bits. It is UNPREDICTABLE <BR>
whether floating-point operates that belong only to the VAX floating-point subset set the <BR>
FPCR exception bits. <BR>
<P>
Alpha floating-point hardware only transitions these exception bits from zero to one. Once set <BR>
to one, these exception bits are only cleared when software writes zero into these bits by writ-ing <BR>
a new value into the FPCR. <BR>
<P>
<A href="#page118">Section 4. 7.2 </A>
allows certain of the FPCR bits to be subsetted. <BR>
The format of the FPCR is shown <A href="#page136">in Figure 4– </A>
1 and described <A href="#page136">in Table 4– 11. <BR>
</A>
<P>
<B>Figure 4– 1: Floating-Point Control Register (FPCR) Format <BR>
</B><P>
<B>Table 4– 11: Floating-Point Control Register (FPCR) Bit Descriptions <BR>
Bit Description (Meaning When Set) <BR>
</B>63 Summary Bit (SUM). Records bitwise OR of FPCR exception bits. Equal to <BR>
FPCR&lt; 57 |56 | 55 | 54 | 53 | 52&gt;. <BR>
<P>
62 Inexact Disable (INED) * . Suppress INE trap and place correct IEEE nontrapping <BR>
result in the destination register. <BR>
<P>
61 Underflow Disable <A href="#page137">(UNFD) * </A>
. Suppress UNF trap and place correct IEEE nontrap-ping <BR>
result in the destination register if the implementation is capable of produc-ing <BR>
correct IEEE nontrapping result. The correct result value is determined <BR>
according to the value of the UNDZ bit. <BR>
<P>
60 Underflow to Zero <A href="#page137">(UNDZ) * </A>
. When set together with UNFD, on underflow, the <BR>
hardware places a true zero (64 bits of zero) in the destination register rather than <BR>
the result specified by the IEEE standard. <BR>
<P>
59– 58 Dynamic Rounding Mode (DYN). Indicates the rounding mode to be used by an <BR>
IEEE floating-point operate instruction when the instruction's function field spec-ifies <BR>
dynamic mode (/ D). Assignments are: <BR>
<P>
63 62 60 0 <BR>
S U <BR>
<P>
M O V N E <BR>
U N <BR>
F <BR>
O V <BR>
F <BR>
D Z <BR>
E N V <BR>
<P>
58 59 57 56 55 54 53 52 51 <BR>
RAZ/ IGN N V <BR>
50 49 48 <BR>
<P>
D <BR>
D Z <BR>
E D <BR>
O V <BR>
F D DYN _RM <BR>
U N <BR>
D Z <BR>
U N <BR>
F <BR>
<P>
61 <BR>
<P>
D <BR>
N E <BR>
D <BR>
<P>
I I I I I <BR>
47 46 <BR>
D N <BR>
<P>
Z <BR>
N O <BR>
<P>
D <BR>
<P>
D <BR>
<P>
<B>DYN IEEE Rounding Mode Selected <BR>
</B>00 Chopped rounding mode <BR>
01 Minus infinity <BR>
10 Normal rounding <BR>
11 Plus infinity 
136
<BR>
<A href=#page136>136</A>
<strong><A name=page137> Page 137</A></strong>
<A href=#page138>138</A>
<BR>
<P>
Instruction Descriptions <B>4– 81 <BR>
</B>FPCR is read from and written to the floating-point registers by the MT_ FPCR and MF_ FPCR <BR>
instructions respectively, which are described <A href="#page138">in Section 4.7.8.1. <BR>
</A>
<P>
57 Integer Overflow (IOV). An integer arithmetic operation or a conversion from <BR>
floating to integer overflowed the destination precision. <BR>
<P>
56 Inexact Result (INE). A floating arithmetic or conversion operation gave a result <BR>
that differed from the mathematically exact result. <BR>
<P>
55 Underflow (UNF). A floating arithmetic or conversion operation underflowed the <BR>
destination exponent. <BR>
<P>
54 Overflow (OVF). A floating arithmetic or conversion operation overflowed the <BR>
destination exponent. <BR>
<P>
53 Division by Zero (DZE). An attempt was made to perform a floating divide oper-ation <BR>
with a divisor of zero. <BR>
<P>
52 Invalid Operation (INV). An attempt was made to perform a floating arithmetic, <BR>
conversion, or comparison operation, and one or more of the operand values were <BR>
illegal. <BR>
<P>
51 Overflow Disable <A href="#page137">(OVFD) * </A>
. Suppress OVF trap and place correct IEEE nontrap-ping <BR>
result in the destination register if the implementation is capable of produc-ing <BR>
correct IEEE nontrapping results. <BR>
<P>
50 Division by Zero Disable <A href="#page137">(DZED) * </A>
. Suppress DZE trap and place correct IEEE <BR>
nontrapping result in the destination register if the implementation is capable of <BR>
producing correct IEEE nontrapping results. <BR>
<P>
49 Invalid Operation Disable <A href="#page137">(INVD) * </A>
. Suppress INV trap and place correct IEEE <BR>
nontrapping result in the destination register if the implementation is capable of <BR>
producing correct IEEE nontrapping results. <BR>
<P>
48 Denormal Operands to Zero <A href="#page137">(DNZ) * </A>
. Treat all denormal operands as a signed zero <BR>
value with the same sign as the denormal. <BR>
<P>
47 Denormal Operand Exception Disable <A href="#page137">(DNOD) * </A>
. Suppress INV trap for valid <BR>
operations that involve denormal operand values and place the correct IEEE non-trapping <BR>
result in the destination register if the implementation is capable of pro-cessing <BR>
the denormal operand. If the result of the operation underflows, the <BR>
correct result is determined according to the value of the UNDZ bit. If DNZ is set, <BR>
DNOD has no effect because a denormal operand is treated as having a zero value <BR>
instead of a denormal value. <BR>
<P>
46– 0 Reserved. Read as Zero. Ignored when written. <BR>
* Bit only has meaning for IEEE instructions when any valid qualifier combination that <BR>
<P>
includes exception completion (/ S) is specified. <BR>
<P>
<B>Table 4– 11: Floating-Point Control Register (FPCR) Bit Descriptions (Continued) <BR>
Bit Description (Meaning When Set) </B>
137
<BR>
<A href=#page137>137</A>
<strong><A name=page138> Page 138</A></strong>
<A href=#page139>139</A>
<BR>
<P>
<B>4– 82 </B>Alpha Architecture Handbook <BR>
FPCR and the instructions to access it are required for an implementation that supports float-ing-<BR>
point (see <A href="#page135">Section 4.7. 8). </A>
On implementations that do not support floating-point, the <BR>
instructions that access FPCR (MF_ FPCR and MT_ FPCR) take an Illegal Instruction Trap. <BR>
<P>
<B>Software Note: <BR>
</B>Support for FPCR is required on a system that supports the OpenVMS Alpha operating <BR>
system even if that system does not support floating-point. <BR>
<P>
<B>4.7.8.1 Accessing the FPCR <BR>
</B>Because Alpha floating-point hardware can overlap the execution of a number of float-ing-<BR>
point instructions, accessing the FPCR must be synchronized with other floating-point <BR>
instructions. An EXCB instruction must be issued both prior to and after accessing the FPCR <BR>
to ensure that the FPCR access is synchronized with the execution of previous and subsequent <BR>
floating-point instructions; otherwise synchronization is not ensured. <BR>
<P>
Issuing an EXCB followed by an MT_ FPCR followed by another EXCB ensures that only <BR>
floating-point instructions issued after the second EXCB are affected by and affect the new <BR>
value of the FPCR. Issuing an EXCB followed by an MF_ FPCR followed by another EXCB <BR>
ensures that the value read from the FPCR only records the exception information for float-ing-<BR>
point instructions issued prior to the first EXCB. <BR>
<P>
Consider the following example: <BR>
<TT>ADDT/ D <BR>
EXCB ;1 <BR>
MT_ FPCR F1,F1, F1 <BR>
EXCB ;2 <BR>
SUBT/ D <BR>
</TT><P>
Without the first EXCB, it is possible in an implementation for the ADDT/ D to execute in par-allel <BR>
with the MT_ FPCR. Thus, it would be UNPREDICTABLE whether the ADDT/ D was <BR>
affected by the new rounding mode set by the MT_ FPCR and whether fields cleared by the <BR>
MT_ FPCR in the exception summary were subsequently set by the ADDT/ D. <BR>
<P>
Without the second EXCB, it is possible in an implementation for the MT_ FPCR to execute in <BR>
parallel with the SUBT/ D. Thus, it would be UNPREDICTABLE whether the SUBT/ D was <BR>
affected by the new rounding mode set by the MT_ FPCR and whether fields cleared by the <BR>
MT_ FPCR in the exception summary field of FPCR were previously set by the SUBT/ D. <BR>
<P>
Specifically, code should issue an EXCB before and after it accesses the FPCR if that code <BR>
needs to see valid values in FPCR bits &lt;63&gt; and &lt;57: 52&gt;. An EXCB should be issued before <BR>
attempting to write the FPCR if the code expects changes to bits &lt;59: 52&gt; not to have depen-dencies <BR>
with prior instructions. An EXCB should be issued after attempting to write the FPCR <BR>
if the code expects subsequent instructions to have dependencies with changes to bits &lt;59: 52&gt;. 
138
<BR>
<A href=#page138>138</A>
<strong><A name=page139> Page 139</A></strong>
<A href=#page140>140</A>
<BR>
<P>
Instruction Descriptions <B>4– 83 <BR>
4.7.8.2 Default Values of the FPCR <BR>
</B>Processor initialization leaves the value of FPCR UNPREDICTABLE. <BR>
<P>
<B>Software Note: <BR>
</B>Compaq software should initialize FPCR&lt; DYN&gt; = 10 during program activation. Using <BR>
this default, a program can be coded to use only dynamic rounding without the need to <BR>
explicitly set the rounding mode to normal rounding in its start-up code. <BR>
<P>
Program activation normally clears all other fields in the FPCR. However, this behavior <BR>
may depend on the operating system. <BR>
<P>
<B>4.7.8.3 Saving and Restoring the FPCR <BR>
</B>The FPCR must be saved and restored across context switches so that the FPCR value of one <BR>
process does not affect the rounding behavior and exception summary of another process. <BR>
<P>
The dynamic rounding mode put into effect by the programmer (or initialized by image activa-tion) <BR>
is valid for the entirety of the program and remains in effect until subsequently changed <BR>
by the programmer or until image run-down occurs. <BR>
<P>
<B>Software Notes: <BR>
</B>The following software notes apply to saving and restoring the FPCR: <BR>
<P>
1. The IEEE standard precludes saving and restoring the FPCR across subroutine calls. <BR>
2. The IEEE standard requires that an implementation provide status flags that are set whenever the corresponding conditions occur and are reset only at the user's request. <BR>
<P>
The exception bits in the FPCR do not satisfy that requirement, because they can be spuriously set by instructions in a trap shadow that should not have been executed had <BR>
the trap been taken synchronously. <BR>
The IEEE status flags can be provided by software (as software status bits) as follows: <BR>
<P>
Trap interface software (usually the operating system) keeps a set of software <BR>
status bits and a mask of the traps that the user wants to receive. Code is generated <BR>
with the /SUI qualifiers. For a particular exception, the software clears the <BR>
corresponding trap disable bit if either the corresponding software status bit is 0 or <BR>
if the user wants to receive such traps. If a trap occurs, the software locates the <BR>
offending instruction in the trap shadow, simulates it and sets any of the software <BR>
status bits that are appropriate. Then, the software either delivers the trap to the <BR>
user program or disables further delivery of such traps. The user program must <BR>
interface to this trap interface software to set or clear any of the software status bits <BR>
or to enable or disable floating-point traps. <A href="#page293">See Section B. </A>
2. <BR>
<P>
When such a scheme is being used, the trap disable bits and denormal control bits <BR>
should be modified only by the trap interface software. If the disable bits are <BR>
spuriously cleared, unnecessary traps may occur. If they are spuriously set, the <BR>
software may fail to set the correct values in the software status bits. Programs should <BR>
call routines in the trap interface software to set or clear bits in the FPCR. 
139
<BR>
<A href=#page139>139</A>
<strong><A name=page140> Page 140</A></strong>
<A href=#page141>141</A>
<BR>
<P>
<B>4– 84 </B>Alpha Architecture Handbook <BR>
Compaq software may choose to initialize the software status bits and the trap disable <BR>
bits to all 1's to avoid any initial trapping when an exception condition first occurs. Or, <BR>
software may choose to initialize those bits to all 0's in order to provide a summary of <BR>
the exception behavior when the program terminates. <BR>
<P>
In any event, the exception bits in the FPCR are still useful to programs. A program <BR>
can clear all of the exception bits in the FPCR, execute a single floating-point <BR>
instruction, and then examine the status bits to determine which hardware-defined <BR>
exceptions the instruction encountered. For this operation to work in the presence of <BR>
various implementation options, the single instruction should be followed by a TRAPB <BR>
or EXCB instruction, and exception completion by the system software should save <BR>
and restore the FPCR registers without other modifications. <BR>
<P>
3. Because of the way the LDS and STS instructions manipulate bits &lt;61: 59&gt; of float-ing-point registers, they should not be used to manipulate FPCR values. <BR>
<P>
<B>4.7. 9 Floating-Point Instruction Function Field Format <BR>
</B>The function code for IEEE and VAX floating-point instructions, bits &lt;15.. 5&gt;, contain the <BR>
function field. That field is shown in <A href="#page140">Figure 4– 2 </A>
and described for IEEE floating-point in <A href="#page141">Table <BR>
</A>
<A href="#page141">4– 12 </A>
and for VAX floating-point in <A href="#page143">Table 4– 13. </A>
Function codes for the independent float-ing-<BR>
point instructions, those with opcode 17 16 , do not correspond to the function fields below. <BR>
<P>
The function field contains subfields that specify the trapping and rounding modes that are <BR>
enabled for the instruction, the source datatype, and the instruction class. <BR>
<P>
<B>Figure 4– 2: Floating-Point Instruction Function Field <BR>
</B><P>
Opcode Fa Fb Fc <B>T R <BR>
P <BR>
</B><P>
<B>R N <BR>
D <BR>
S R <BR>
C <BR>
F N <BR>
C <BR>
</B><P>
31 25 20 <B>15 12 10 8 </B>4 0 <B>5 9 11 13 </B>16 21 26 
140
<BR>
<A href=#page140>140</A>
<strong><A name=page141> Page 141</A></strong>
<A href=#page142>142</A>
<BR>
Instruction Descriptions <B>4– 85 <BR>
Table 4– 12: IEEE Floating-Point Function Field Bit Summary <BR>
Bits Field Meaning * <BR>
</B>15– 13 TRP Trapping modes: <BR>
<P>
12– 11 RND Rounding modes: <BR>
10– 9 SRC Source datatype: <BR>
<P>
<B>Contents Meaning for Opcodes 14 16 and 16 16 <BR>
</B>000 Imprecise (default) <BR>
001 Underflow enable (/ U) — floating-point output <BR>
Integer overflow enable (/ V) — integer output <BR>
<P>
010 UNPREDICTABLE for opcode 16 16 instructions <BR>
Reserved for opcode 14 16 instructions <BR>
<P>
011 UNPREDICTABLE for opcode 16 16 instructions <BR>
Reserved for opcode 14 16 instructions <BR>
<P>
100 UNPREDICTABLE for opcode 16 16 instructions <BR>
Reserved for opcode 14 16 instructions <BR>
<P>
101 /SU — floating-point output <BR>
/SV — integer output <BR>
<P>
110 UNPREDICTABLE for opcode 16 16 instructions <BR>
Reserved for opcode 14 16 instructions <BR>
<P>
111 /SUI — floating-point output <BR>
/SVI — integer output <BR>
<P>
<B>Contents Meaning for Opcodes 16 16 and 14 16 <BR>
</B>00 Chopped (/ C) <BR>
01 Minus infinity (/ M) <BR>
10 Normal (default) <BR>
11 Dynamic (/ D) <BR>
<P>
<B>Contents Meaning for <BR>
Opcode 16 16 <BR>
Meaning for <BR>
Opcode 14 16 <BR>
</B><P>
00 S_ floating S_ floating <BR>
01 Reserved Reserved <BR>
10 T_ floating T_ floating <BR>
11 Q_ fixed Reserved 
141
<BR>
<A href=#page141>141</A>
<strong><A name=page142> Page 142</A></strong>
<A href=#page143>143</A>
<BR>
<P>
<B>4– 86 </B>Alpha Architecture Handbook <BR>
8– 5 FNC Instruction class: <BR>
* Encodings for the instructions CVTST and CVTST/ S are exceptions to this table; use the <BR>
encodings in <A href="#page303">Section C. 1. <BR>
</A>
<P>
<B>Table 4– 12: IEEE Floating-Point Function Field Bit Summary (Continued) <BR>
Bits Field Meaning * <BR>
</B><P>
<B>Contents Meaning for <BR>
Opcode 16 16 <BR>
Meaning for <BR>
Opcode 14 16 <BR>
</B><P>
0000 ADDx Reserved <BR>
0001 SUBx Reserved <BR>
0010 MULx Reserved <BR>
0011 DIVx Reserved <BR>
0100 CMPxUN ITOFS/ ITOFT <BR>
0101 CMPxEQ Reserved <BR>
0110 CMPxLT Reserved <BR>
0111 CMPxLE Reserved <BR>
1000 Reserved Reserved <BR>
1001 Reserved Reserved <BR>
1010 Reserved Reserved <BR>
1011 Reserved SQRTS/ SQRTT <BR>
1100 CVTxS Reserved <BR>
1101 Reserved Reserved <BR>
1110 CVTxT Reserved <BR>
<P>
1111 CVTxQ Reserved 
142
<BR>
<A href=#page142>142</A>
<strong><A name=page143> Page 143</A></strong>
<A href=#page144>144</A>
<BR>
Instruction Descriptions <B>4– 87 <BR>
Table 4– 13: VAX Floating-Point Function Field Bit Summary <BR>
Bits Field Meaning <BR>
</B>15– 13 TRP Trapping modes: <BR>
<P>
12– 11 RND Rounding modes: <BR>
10– 9 SRC Source datatype: * <BR>
<P>
<B>Contents Meaning for Opcodes 14 16 and 15 16 <BR>
</B>000 Imprecise (default) <BR>
001 Underflow enable (/ U) – floating-point output <BR>
Integer overflow enable (/ V) – integer output <BR>
<P>
010 UNPREDICTABLE for opcode 15 16 instructions <BR>
Reserved for opcode 14 16 instructions <BR>
<P>
011 UNPREDICTABLE for opcode 15 16 instructions <BR>
Reserved for opcode 14 16 instructions <BR>
<P>
100 /S – Exception completion enable <BR>
101 /SU – floating-point output <BR>
/SV – integer output <BR>
<P>
110 UNPREDICTABLE for opcode 15 16 instructions <BR>
Reserved for opcode 14 16 instructions <BR>
<P>
111 UNPREDICTABLE for opcode 15 16 instructions <BR>
Reserved for opcode 14 16 instructions <BR>
<P>
<B>Contents Meaning for Opcodes 15 16 and 14 16 <BR>
</B>00 Chopped (/ C) <BR>
01 UNPREDICTABLE <BR>
10 Normal (default) <BR>
11 UNPREDICTABLE <BR>
<P>
<B>Contents Meaning for Opcode 15 16 Meaning for Opcode 14 16 <BR>
</B>00 F_ floating F_ floating <BR>
01 D_ floating F_ floating <BR>
10 G_ floating G_ floating <BR>
11 Q_ fixed Reserved 
143
<BR>
<A href=#page143>143</A>
<strong><A name=page144> Page 144</A></strong>
<A href=#page145>145</A>
<BR>
<P>
<B>4– 88 </B>Alpha Architecture Handbook <BR>
<B>4.7. 10 IEEE Standard <BR>
</B>The IEEE Standard for Binary Floating-Point Arithmetic (ANSI/ IEEE Standard 754-1985) is <BR>
included by reference. <BR>
<P>
This standard leaves certain operations as implementation dependent. The remainder of this <BR>
section specifies the behavior of the Alpha architecture in these situations. Note that this <BR>
behavior may be supplied by either hardware (if the invalid operation disable, or INVD, bit is <BR>
implemented) or by software. See <A href="#page134">Sections </A>
<A href="#page135">4.7.7.10, 4.7.7.11, </A>
<A href="#page135">4.7.8, </A>
<A href="#page139">4.7. 8.3, </A>
<A href="#page291">and Section B. </A>
1. <BR>
<P>
<B>4.7.10.1 Conversion of NaN and Infinity Values <BR>
</B>Conversion of a NaN or an Infinity value to an integer gives a result of zero. <BR>
<P>
Conversion of a NaN value from S_ floating to T_ floating gives a result identical to the input, <BR>
except that the most significant fraction bit (bit 51) is set to indicate a quiet NaN. <BR>
<P>
Conversion of a NaN value from T_ floating to S_ floating gives a result identical to the input, <BR>
except that the most significant fraction bit (bit 51) is set to indicate a quiet NaN, and bits <BR>
&lt;28: 0&gt; are cleared to zero. <BR>
<P>
8– 5 FNC Instruction class: <BR>
* In the SRC field, both 00 and 01 specify the F_ floating source datatype for opcode 14 16 . <BR>
<P>
<B>Table 4– 13: VAX Floating-Point Function Field Bit Summary (Continued) <BR>
Bits Field Meaning <BR>
</B><P>
<B>Contents Meaning for <BR>
Opcode 15 16 <BR>
Meaning for <BR>
Opcode 14 16 <BR>
</B><P>
0000 ADDx Reserved <BR>
0001 SUBx Reserved <BR>
0010 MULx Reserved <BR>
0011 DIVx Reserved <BR>
0100 CMPxUN ITOFF <BR>
0101 CMPxEQ Reserved <BR>
0110 CMPxLT Reserved <BR>
0111 CMPxLE Reserved <BR>
1000 Reserved Reserved <BR>
1001 Reserved Reserved <BR>
1010 Reserved SQRTF/ SQRTG <BR>
1011 Reserved Reserved <BR>
1100 CVTxF Reserved <BR>
1101 CVTxD Reserved <BR>
1110 CVTxG Reserved <BR>
1111 CVTxQ Reserved 
144
<BR>
<A href=#page144>144</A>
<strong><A name=page145> Page 145</A></strong>
<A href=#page146>146</A>
<BR>
Instruction Descriptions <B>4– 89 <BR>
4.7.10.2 Copying NaN Values <BR>
</B>Copying a NaN value without changing its precision does not cause an invalid operation <BR>
exception. <BR>
<P>
<B>4.7.10.3 Generating NaN Values <BR>
</B>When an operation is required to produce a NaN and none of its inputs are NaN values, the <BR>
result of the operation is the quiet NaN value that has the sign bit set to one, all exponent bits <BR>
set to one (to indicate a NaN), the most significant fraction bit set to one (to indicate that the <BR>
NaN is quiet), and all other fraction bits cleared to zero. This value is referred to as "the canon-ical <BR>
quiet NaN." <BR>
<P>
<B>4.7.10.4 Propagating NaN Values <BR>
</B>When an operation is required to produce a NaN and one or both of its inputs are NaN values, <BR>
the IEEE standard requires that quiet NaN values be propagated when possible. With the Alpha <BR>
architecture, the result of such an operation is a NaN generated according to the first of the fol-lowing <BR>
rules that is applicable: <BR>
<P>
1. If the operand in the Fb register of the operation is a quiet NaN, that value is used as the <BR>
result. <BR>
<P>
2. If the operand in the Fb register of the operation is a signaling NaN, the result is the quiet NaN formed from the Fb value by setting the most significant fraction bit (bit 51) <BR>
<P>
to a one bit. <BR>
3. If the operation uses its Fa operand and the value in the Fa register is a quiet NaN, that value is used as the result. <BR>
<P>
4. If the operation uses its Fa operand and the value in the Fa register is a signaling NaN, the result is the quiet NaN formed from the Fa value by setting the most significant <BR>
fraction bit (bit 51) to a one bit. <BR>
5. The result is the canonical quiet NaN. 
145
<BR>
<A href=#page145>145</A>
<strong><A name=page146> Page 146</A></strong>
<A href=#page147>147</A>
<BR>
<P>
<B>4– 90 </B>Alpha Architecture Handbook <BR>
<B>4. 8 Memory Format Floating-Point Instructions <BR>
</B>The instructions in this section move data between the floating-point registers and memory. <BR>
They use the Memory instruction format. They do not interpret the bits moved in any way; spe-cifically, <BR>
they do not trap on non-finite values. <BR>
<P>
The instructions are summarized <A href="#page146">in Table 4– 14. <BR>
</A>
<B>Table 4– 14: Memory Format Floating-Point Instructions Summary <BR>
Mnemonic Operation Subset <BR>
</B>LDF Load F_ floating VAX <BR>
LDG Load G_ floating (Load D_ floating) VAX <BR>
LDS Load S_ floating (Load Longword Integer) Both <BR>
LDT Load T_ floating (Load Quadword Integer) Both <BR>
<P>
STF Store F_ floating VAX <BR>
STG Store G_ floating (Store D_ floating) VAX <BR>
STS Store S_ floating (Store Longword Integer) Both <BR>
STT Store T_ floating (Store Quadword Integer) Both 
146
<BR>
<A href=#page146>146</A>
<strong><A name=page147> Page 147</A></strong>
<A href=#page148>148</A>
<BR>
<P>
Instruction Descriptions <B>4– 91 <BR>
4. 8.1 Load F_ floating <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>va </TT>¬ <TT>{Rbv + SEXT( disp)} <BR>
</TT><P>
<TT>CASE <BR>
big_ endian_ data: va' </TT>¬ <TT>va XOR 100 2 <BR>
</TT><P>
<TT>little_ endian_ data: va' </TT>¬ <TT>va <BR>
ENDCASE <BR>
</TT><P>
<TT>Fa </TT>¬ <TT>(va')&lt; 15&gt; || MAP_ F(( va')&lt; 14: 7&gt;) || (va')&lt; 6: 0&gt; || <BR>
(va')&lt; 31: 16&gt; || 0&lt; 28: 0&gt; <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>LDF fetches an F_ floating datum from memory and writes it to register Fa. If the data is not <BR>
naturally aligned, an alignment exception is generated. <BR>
<P>
The MAP_ F function causes the 8-bit memory-format exponent to be expanded to an 11-bit <BR>
register-format exponent according <A href="#page30">to Table 2– </A>
1. <BR>
<P>
The virtual address is computed by adding register Rb to the sign-extended 16-bit displace-ment. <BR>
For a big-endian longword access, va&lt; 2&gt; (bit 2 of the virtual address) is inverted, and <BR>
any memory management fault is reported for va (not va'). The source operand is fetched <BR>
from memory and the bytes are reordered to conform to the F_ floating register format. The <BR>
result is then zero-extended in the low-order longword and written to register Fa. <BR>
<P>
LDF Fa. wf, disp. ab( Rb. ab) !Memory format <BR>
Access Violation <BR>
Fault on Read <BR>
Alignment <BR>
Translation Not Valid <BR>
<P>
LDF Load F_ floating <BR>
None 
147
<BR>
<A href=#page147>147</A>
<strong><A name=page148> Page 148</A></strong>
<A href=#page149>149</A>
<BR>
<B>4– 92 </B>Alpha Architecture Handbook <BR>
<B>4.8. 2 Load G_ floating <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>va </TT>¬ <TT>{Rbv + SEXT( disp)} <BR>
Fa </TT>¬ <TT>(va)&lt; 15: 0&gt; || (va)&lt; 31: 16&gt; || (va)&lt; 47: 32&gt; || (va)&lt; 63: 48&gt; <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>LDG fetches a G_ floating (or D_ floating) datum from memory and writes it to register Fa. If <BR>
the data is not naturally aligned, an alignment exception is generated. <BR>
<P>
The virtual address is computed by adding register Rb to the sign-extended 16-bit displace-ment. <BR>
The source operand is fetched from memory, the bytes are reordered to conform to the <BR>
G_ floating register format (also conforming to the D_ floating register format), and the result is <BR>
then written to register Fa. <BR>
<P>
LDG Fa. wg, disp. ab( Rb. ab) !Memory format <BR>
Access Violation <BR>
Fault on Read <BR>
Alignment <BR>
Translation Not Valid <BR>
<P>
LDG Load G_ floating (Load D_ floating) <BR>
None 
148
<BR>
<A href=#page148>148</A>
<strong><A name=page149> Page 149</A></strong>
<A href=#page150>150</A>
<BR>
<P>
Instruction Descriptions <B>4– 93 <BR>
4.8. 3 Load S_ floating <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>va </TT>¬ <TT>{Rbv + SEXT( disp)} <BR>
</TT><P>
<TT>CASE <BR>
big_ endian_ data: va' </TT>¬ <TT>va XOR 100 2 <BR>
</TT><P>
<TT>little_ endian_ data: va' </TT>¬ <TT>va <BR>
ENDCASE <BR>
</TT><P>
<TT>Fa </TT>¬ <TT>(va')&lt; 31&gt; || MAP_ S(( va')&lt; 30: 23&gt;) || (va')&lt; 22: 0&gt; || 0&lt; 28: 0&gt; <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>LDS fetches a longword (integer or S_ floating) from memory and writes it to register Fa. If the <BR>
data is not naturally aligned, an alignment exception is generated. The MAP_ S function causes <BR>
the 8-bit memory-format exponent to be expanded to an 11-bit register-format exponent <BR>
according to <A href="#page33">Table 2– 2. <BR>
</A>
<P>
The virtual address is computed by adding register Rb to the sign-extended 16-bit displace-ment. <BR>
For a big-endian longword access, va&lt; 2&gt; (bit 2 of the virtual address) is inverted, and <BR>
any memory management fault is reported for va (not va'). The source operand is fetched <BR>
from memory, is zero-extended in the low-order longword, and then written to register Fa. <BR>
Longword integers in floating registers are stored in bits &lt;63: 62,58: 29&gt;, with bits &lt;61: 59&gt; <BR>
ignored and zeros in bits &lt;28: 0&gt;. <BR>
<P>
LDS Fa. ws, disp. ab( Rb. ab) !Memory format <BR>
Access Violation <BR>
Fault on Read <BR>
Alignment <BR>
Translation Not Valid <BR>
<P>
LDS Load S_ floating (Load Longword Integer) <BR>
None 
149
<BR>
<A href=#page149>149</A>
<strong><A name=page150> Page 150</A></strong>
<A href=#page151>151</A>
<BR>
<B>4– 94 </B>Alpha Architecture Handbook <BR>
<B>4. 8.4 Load T_ floating <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>va </TT>¬ <TT>{Rbv + SEXT( disp)} <BR>
</TT><P>
<TT>Fa </TT>¬ <TT>(va)&lt; 63: 0&gt; <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>LDT fetches a quadword (integer or T_ floating) from memory and writes it to register Fa. If <BR>
the data is not naturally aligned, an alignment exception is generated. <BR>
<P>
The virtual address is computed by adding register Rb to the sign-extended 16-bit displace-ment. <BR>
The source operand is fetched from memory and written to register Fa. <BR>
<P>
LDT Fa. wt, disp. ab( Rb. ab) !Memory format <BR>
Access Violation <BR>
Fault on Read <BR>
Alignment <BR>
Translation Not Valid <BR>
<P>
LDT Load T_ floating (Load Quadword Integer) <BR>
None 
150
<BR>
<A href=#page150>150</A>
<strong><A name=page151> Page 151</A></strong>
<A href=#page152>152</A>
<BR>
Instruction Descriptions <B>4– 95 <BR>
4. 8.5 Store F_ floating <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>va </TT>¬ <TT>{Rbv + SEXT( disp)} <BR>
</TT><P>
<TT>CASE <BR>
big_ endian_ data: va' </TT>¬ <TT>va XOR 100 2 <BR>
</TT><P>
<TT>little_ endian_ data: va' </TT>¬ <TT>va <BR>
ENDCASE <BR>
</TT><P>
<TT>(va')&lt; 31: 0&gt; </TT>¬ <TT>Fav&lt; 44: 29&gt; || Fav&lt; 63: 62&gt; || Fav&lt; 58: 45&gt; <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>STF stores an F_ floating datum from Fa to memory. If the data is not naturally aligned, an <BR>
alignment exception is generated. <BR>
<P>
The virtual address is computed by adding register Rb to the sign-extended 16-bit displace-ment. <BR>
For a big-endian longword access, va&lt; 2&gt; (bit 2 of the virtual address) is inverted, and <BR>
any memory management fault is reported for va (not va'). The bits of the source operand are <BR>
fetched from register Fa, the bits are reordered to conform to F_ floating memory format, and <BR>
the result is then written to memory. Bits &lt;61: 59&gt; and &lt;28: 0&gt; of Fa are ignored. No checking <BR>
is done. <BR>
<P>
STF Fa. rf, disp. ab( Rb. ab) !Memory format <BR>
Access Violation <BR>
Fault on Write <BR>
Alignment <BR>
Translation Not Valid <BR>
<P>
STF Store F_ floating <BR>
None 
151
<BR>
<A href=#page151>151</A>
<strong><A name=page152> Page 152</A></strong>
<A href=#page153>153</A>
<BR>
<B>4– 96 </B>Alpha Architecture Handbook <BR>
<B>4.8. 6 Store G_ floating <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>va </TT>¬ <TT>{Rbv + SEXT( disp)} <BR>
(va)&lt; 63: 0&gt; </TT>¬ <TT>Fav&lt; 15: 0&gt; || Fav&lt; 31: 16&gt; || Fav&lt; 47: 32&gt; || Fav&lt; 63: 48&gt; <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>STG stores a G_ floating (or D_ floating) datum from Fa to memory. If the data is not naturally <BR>
aligned, an alignment exception is generated. <BR>
<P>
The virtual address is computed by adding register Rb to the sign-extended 16-bit displace-ment. <BR>
The source operand is fetched from register Fa, the bytes are reordered to conform to the <BR>
G_ floating memory format (also conforming to the D_ floating memory format), and the result <BR>
is then written to memory. <BR>
<P>
STG Fa. rg, disp. ab( Rb. ab) !Memory format <BR>
Access Violation <BR>
Fault on Write <BR>
Alignment <BR>
Translation Not Valid <BR>
<P>
STG Store G_ floating (Store D_ floating) <BR>
None 
152
<BR>
<A href=#page152>152</A>
<strong><A name=page153> Page 153</A></strong>
<A href=#page154>154</A>
<BR>
Instruction Descriptions <B>4– 97 <BR>
4.8. 7 Store S_ floating <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>va </TT>¬ <TT>{Rbv + SEXT( disp)} <BR>
</TT><P>
<TT>CASE <BR>
big_ endian_ data: va' </TT>¬ <TT>va XOR 100 2 <BR>
</TT><P>
<TT>little_ endian_ data: va' </TT>¬ <TT>va <BR>
ENDCASE <BR>
</TT><P>
<TT>(va')&lt; 31: 0&gt; </TT>¬ <TT>Fav&lt; 63: 62&gt; || Fav&lt; 58: 29&gt; <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>STS stores a longword (integer or S_ floating) datum from Fa to memory. If the data is not nat-urally <BR>
aligned, an alignment exception is generated. <BR>
<P>
The virtual address is computed by adding register Rb to the sign-extended 16-bit displace-ment. <BR>
For a big-endian longword access, va&lt; 2&gt; (bit 2 of the virtual address) is inverted, and <BR>
any memory management fault is reported for va (not va'). The bits of the source operand are <BR>
fetched from register Fa, the bits are reordered to conform to S_ floating memory format, and <BR>
the result is then written to memory. Bits &lt;61: 59&gt; and &lt;28: 0&gt; of Fa are ignored. No checking <BR>
is done. <BR>
<P>
STS Fa. rs, disp. ab( Rb. ab) !Memory format <BR>
Access Violation <BR>
Fault on Write <BR>
Alignment <BR>
Translation Not Valid <BR>
<P>
STS Store S_ floating (Store Longword Integer) <BR>
None 
153
<BR>
<A href=#page153>153</A>
<strong><A name=page154> Page 154</A></strong>
<A href=#page155>155</A>
<BR>
<B>4– 98 </B>Alpha Architecture Handbook <BR>
<B>4.8. 8 Store T_ floating <BR>
</B>Format: <BR>
<P>
Operation: <BR>
<TT>va </TT>¬ <TT>{Rbv + SEXT( disp)} <BR>
(va)&lt; 63: 0&gt; </TT>¬ <TT>Fav&lt; 63: 0&gt; <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>STT stores a quadword (integer or T_ floating) datum from Fa to memory. If the data is not nat-urally <BR>
aligned, an alignment exception is generated. <BR>
<P>
The virtual address is computed by adding register Rb to the sign-extended 16-bit displace-ment. <BR>
The source operand is fetched from register Fa and written to memory. <BR>
<P>
STT Fa. rt, disp. ab( Rb. ab) !Memory format <BR>
Access Violation <BR>
Fault on Write <BR>
Alignment <BR>
Translation Not Valid <BR>
<P>
STT Store T_ floating (Store Quadword Integer) <BR>
None 
154
<BR>
<A href=#page154>154</A>
<strong><A name=page155> Page 155</A></strong>
<A href=#page156>156</A>
<BR>
<P>
Instruction Descriptions <B>4– 99 <BR>
4. 9 Branch Format Floating-Point Instructions <BR>
</B>Alpha provides six floating conditional branch instructions. These branch-format instructions <BR>
test the value of a floating-point register and conditionally change the PC. <BR>
<P>
They do not interpret the bits tested in any way; specifically, they do not trap on non-finite <BR>
values. <BR>
<P>
The test is based on the sign bit and whether the rest of the register is all zero bits. All 64 bits <BR>
of the register are tested. The test is independent of the format of the operand in the register. <BR>
Both plus and minus zero are equal to zero. A non-zero value with a sign of zero is greater than <BR>
zero. A non-zero value with a sign of one is less than zero. No reserved operand or non-finite <BR>
checking is done. <BR>
<P>
The floating-point branch operations are summarized <A href="#page155">in Table 4– 15: <BR>
</A>
<B>Table 4– 15: Floating-Point Branch Instructions Summary <BR>
Mnemonic Operation Subset <BR>
</B>FBEQ Floating Branch Equal Both <BR>
FBGE Floating Branch Greater Than or Equal Both <BR>
FBGT Floating Branch Greater Than Both <BR>
FBLE Floating Branch Less Than or Equal Both <BR>
FBLT Floating Branch Less Than Both <BR>
FBNE Floating Branch Not Equal Both 
155
<BR>
<A href=#page155>155</A>
<strong><A name=page156> Page 156</A></strong>
<A href=#page157>157</A>
<BR>
<B>4– 100 </B>Alpha Architecture Handbook <BR>
<B>4.9. 1 Conditional Branch <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>{update PC} <BR>
va </TT>¬ <TT>PC + {4* SEXT( disp)} <BR>
IF TEST( Fav, Condition_ based_ on_ Opcode) THEN <BR>
PC </TT>¬ <TT>va <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>Register Fa is tested. If the specified relationship is true, the PC is loaded with the target vir-tual <BR>
address; otherwise, execution continues with the next sequential instruction. <BR>
<P>
The displacement is treated as a signed longword offset. This means it is shifted left two bits <BR>
(to address a longword boundary), sign-extended to 64 bits, and added to the updated PC to <BR>
form the target virtual address. <BR>
<P>
The conditional branch instructions are PC-relative only. The 21-bit signed displacement gives <BR>
a forward/ backward branch distance of +/– 1M instructions. <BR>
<P>
FBxx Fa. rq, disp. al !Branch format <BR>
None <BR>
FBEQ Floating Branch Equal <BR>
FBGE Floating Branch Greater Than or Equal <BR>
FBGT Floating Branch Greater Than <BR>
FBLE Floating Branch Less Than or Equal <BR>
FBLT Floating Branch Less Than <BR>
FBNE Floating Branch Not Equal <BR>
<P>
None 
156
<BR>
<A href=#page156>156</A>
<strong><A name=page157> Page 157</A></strong>
<A href=#page158>158</A>
<BR>
Instruction Descriptions <B>4– 101 <BR>
Notes: <BR>
° </B>To branch properly on non-finite operands, compare to F31, then branch on the result of the compare. <BR>
<P>
<B>° </B>The largest negative integer (8000 0000 0000 0000 16 ) is the same bit pattern as floating minus zero, so it is treated as equal to zero by the branch instructions. To branch prop-erly <BR>
on the largest negative integer, convert it to floating or move it to an integer regis-ter <BR>
and do an integer branch. 
157
<BR>
<A href=#page157>157</A>
<strong><A name=page158> Page 158</A></strong>
<A href=#page159>159</A>
<BR>
<P>
<B>4– 102 </B>Alpha Architecture Handbook <BR>
<B>4. 10 Floating-Point Operate Format Instructions <BR>
</B>The floating-point bit-operate instructions perform copy and integer convert operations on <BR>
64-bit register values. The bit-operate instructions do not interpret the bits moved in any way; <BR>
specifically, they do not trap on non-finite values. <BR>
<P>
The floating-point arithmetic-operate instructions perform add, subtract, multiply, divide, com-pare, <BR>
register move, squre root, and floating convert operations on 64-bit register values in one <BR>
of the four specified floating formats. <BR>
<P>
Each instruction specifies the source and destination formats of the values, as well as the <BR>
rounding mode and trapping mode to be used. These instructions use the Floating-point Oper-ate <BR>
format. <BR>
<P>
<B>Floating-point convert and square-root (FIX) extension implementation note: <BR>
</B>The FIX extension to the architecture provides the FTOIx, ITOFx, and SQRTx <BR>
instructions. Alpha processors for which the AMASK instruction returns bit 1 set <BR>
implement these instructions. Those processors for which AMASK does not return bit 1 set <BR>
can take an Illegal Instruction trap, and software can emulate their function, if required. <BR>
AMASK is described in <A href="#page189">Sections 4.11.1 </A>
<A href="#page327">and D. </A>
3. <BR>
<P>
The floating-point operate instructions are summarized <A href="#page158">in Table 4– 16. <BR>
</A>
<B>Table 4– 16: Floating-Point Operate Instructions Summary <BR>
Mnemonic Operation Subset <BR>
Bit and FPCR Operations: <BR>
</B>CPYS Copy Sign Both <BR>
CPYSE Copy Sign and Exponent Both <BR>
CPYSN Copy Sign Negate Both <BR>
<P>
CVTLQ Convert Longword to Quadword Both <BR>
CVTQL Convert Quadword to Longword Both <BR>
<P>
FCMOVxx Floating Conditional Move Both <BR>
MF_ FPCR Move from Floating-point Control Register Both <BR>
MT_ FPCR Move to Floating-point Control Register Both 
158
<BR>
<A href=#page158>158</A>
<strong><A name=page159> Page 159</A></strong>
<A href=#page160>160</A>
<BR>
Instruction Descriptions <B>4– 103 <BR>
Arithmetic Operations <BR>
</B>ADDF Add F_ floating VAX <BR>
ADDG Add G_ floating VAX <BR>
ADDS Add S_ floating IEEE <BR>
ADDT Add T_ floating IEEE <BR>
<P>
CMPGxx Compare G_ floating VAX <BR>
CMPTxx Compare T_ floating IEEE <BR>
<P>
CVTDG Convert D_ floating to G_ floating VAX <BR>
CVTGD Convert G_ floating to D_ floating VAX <BR>
CVTGF Convert G_ floating to F_ floating VAX <BR>
CVTGQ Convert G_ floating to Quadword VAX <BR>
CVTQF Convert Quadword to F_ floating VAX <BR>
CVTQG Convert Quadword to G_ floating VAX <BR>
CVTQS Convert Quadword to S_ floating IEEE <BR>
CVTQT Convert Quadword to T_ floating IEEE <BR>
CVTST Convert S_ floating to T_ floating IEEE <BR>
CVTTQ Convert T_ floating to Quadword IEEE <BR>
CVTTS Convert T_ floating to S_ floating IEEE <BR>
<P>
DIVF Divide F_ floating VAX <BR>
DIVG Divide G_ floating VAX <BR>
DIVS Divide S_ floating IEEE <BR>
DIVT Divide T_ floating IEEE <BR>
<P>
FTOIS Floating-point to integer register move, S_ floating IEEE <BR>
FTOIT Floating-point to integer register move, T_ floating IEEE <BR>
ITOFF Integer to floating-point register move, F_ floating VAX <BR>
ITOFS Integer to floating-point register move, S_ floating IEEE <BR>
ITOFT Integer to floating-point register move, T_ floating IEEE <BR>
<P>
<B>Table 4– 16: Floating-Point Operate Instructions Summary (Continued) <BR>
Mnemonic Operation Subset </B>
159
<BR>
<A href=#page159>159</A>
<strong><A name=page160> Page 160</A></strong>
<A href=#page161>161</A>
<BR>
<B>4– 104 </B>Alpha Architecture Handbook <BR>
<B>Arithmetic Operations <BR>
</B>MULF Multiply F_ floating VAX <BR>
MULG Multiply G_ floating VAX <BR>
MULS Multiply S_ floating IEEE <BR>
MULT Multiply T_ floating IEEE <BR>
<P>
SQRTF Square root F_ floating VAX <BR>
SQRTG Square root G_ floating VAX <BR>
SQRTS Square root S_ floating IEEE <BR>
SQRTT Square root T_ floating IEEE <BR>
<P>
SUBF Subtract F_ floating VAX <BR>
SUBG Subtract G_ floating VAX <BR>
SUBS Subtract S_ floating IEEE <BR>
SUBT Subtract T_ floating IEEE <BR>
<P>
<B>Table 4– 16: Floating-Point Operate Instructions Summary (Continued) <BR>
Mnemonic Operation Subset </B>
160
<BR>
<A href=#page160>160</A>
<strong><A name=page161> Page 161</A></strong>
<A href=#page162>162</A>
<BR>
Instruction Descriptions <B>4– 105 <BR>
4.10. 1 Copy Sign <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>CASE <BR>
CPYS: Fc </TT>¬ <TT>Fav&lt; 63&gt; || Fbv&lt; 62: 0&gt; <BR>
CPYSN: Fc </TT>¬ <TT>NOT( Fav&lt; 63&gt;) || Fbv&lt; 62: 0&gt; <BR>
CPYSE: Fc </TT>¬ <TT>Fav&lt; 63: 52&gt; || Fbv&lt; 51: 0&gt; <BR>
ENDCASE <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>For CPYS and CPYSN, the sign bit of Fa is fetched (and complemented in the case of CPYSN) <BR>
and concatenated with the exponent and fraction bits from Fb; the result is stored in Fc. <BR>
<P>
For CPYSE, the sign and exponent bits from Fa are fetched and concatenated with the fraction <BR>
bits from Fb; the result is stored in Fc. <BR>
<P>
No checking of the operands is performed. <BR>
<P>
<B>Notes: <BR>
° </B>Register moves can be performed using CPYS Fx, Fx, Fy. Floating-point absolute value can be done using CPYS F31,Fx, Fy. Floating-point negation can be done using <BR>
<P>
CPYSN Fx, Fx, Fy. Floating values can be scaled to a known range by using CPYSE. <BR>
<P>
CPYSy Fa. rq, Fb. rq, Fc. wq !Floating-point Operate format <BR>
None <BR>
CPYS Copy Sign <BR>
CPYSE Copy Sign and Exponent <BR>
CPYSN Copy Sign Negate <BR>
<P>
None 
161
<BR>
<A href=#page161>161</A>
<strong><A name=page162> Page 162</A></strong>
<A href=#page163>163</A>
<BR>
<B>4– 106 </B>Alpha Architecture Handbook <BR>
<B>4.10. 2 Convert Integer to Integer <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>CASE <BR>
CVTQL: Fc </TT>¬ <TT>Fbv&lt; 31: 30&gt; || 0&lt; 2: 0&gt; || Fbv&lt; 29: 0&gt; || 0&lt; 28: 0&gt; <BR>
CVTLQ: Fc </TT>¬ <TT>SEXT( Fbv&lt; 63: 62&gt; || Fbv&lt; 58: 29&gt;) <BR>
ENDCASE <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>The two's-complement operand in register Fb is converted to a two's-complement result and <BR>
written to register Fc. Register Fa must be F31. <BR>
<P>
The conversion from quadword to longword is a repositioning of the low 32 bits of the oper-and, <BR>
with zero fill and optional integer overflow checking. Integer overflow occurs if Fb is <BR>
outside the range –2** 31.. 2** 31– 1. If integer overflow occurs, the truncated result is stored in <BR>
Fc, and an arithmetic trap is taken if enabled. <BR>
<P>
The conversion from longword to quadword is a repositioning of 32 bits of the operand, with <BR>
sign extension. <BR>
<P>
CVTxy Fb. rq, Fc. wx !Floating-point Operate format <BR>
Integer Overflow, CVTQL only <BR>
CVTLQ Convert Longword to Quadword <BR>
CVTQL Convert Quadword to Longword <BR>
<P>
Trapping: Exception Completion (/ S) (CVTQL only) <BR>
Integer Overflow Enable (/ V) (CVTQL only) 
162
<BR>
<A href=#page162>162</A>
<strong><A name=page163> Page 163</A></strong>
<A href=#page164>164</A>
<BR>
<P>
Instruction Descriptions <B>4– 107 <BR>
4.10. 3 Floating-Point Conditional Move <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>IF TEST( Fav, Condition_ based_ on_ Opcode) THEN <BR>
</TT><P>
<TT>Fc </TT>¬ <TT>Fbv <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>Register Fa is tested. If the specified relationship is true, register Fb is written to register Fc; <BR>
otherwise, the move is suppressed and register Fc is unchanged. The test is based on the sign <BR>
bit and whether the rest of the register is all zero bits, as described for floating branches in <A href="#page155">Sec-tion <BR>
</A>
<A href="#page155">4.9. <BR>
</A>
<P>
FCMOVxx Fa. rq, Fb. rq, Fc. wq !Floating-point Operate format <BR>
None <BR>
FCMOVEQ FCMOVE if Register Equal to Zero <BR>
FCMOVGE FCMOVE if Register Greater Than or Equal to Zero <BR>
FCMOVGT FCMOVE if Register Greater Than Zero <BR>
FCMOVLE FCMOVE if Register Less Than or Equal to Zero <BR>
FCMOVLT FCMOVE if Register Less Than Zero <BR>
FCMOVNE FCMOVE if Register Not Equal to Zero <BR>
<P>
None 
163
<BR>
<A href=#page163>163</A>
<strong><A name=page164> Page 164</A></strong>
<A href=#page165>165</A>
<BR>
<B>4– 108 </B>Alpha Architecture Handbook <BR>
<B>Notes: <BR>
</B>Except that it is likely in many implementations to be substantially faster, the instruction: <BR>
<P>
<TT>FCMOVxx Fa, Fb, Fc <BR>
</TT>is exactly equivalent to: <BR>
<TT>FByy Fa, label ! yy = NOT xx <BR>
CPYS Fb, Fb, Fc <BR>
label: ... <BR>
</TT><P>
For example, a branchless sequence for: <BR>
<TT>F1= MAX( F1, F2) <BR>
</TT>is: <BR>
<TT>CMPxLT F1, F2, F3 ! F3= one if F1&lt; F2; x= F/ G/ S/ T <BR>
FCMOVNE F3, F2, F1 ! Move F2 to F1 if F1&lt; F2 </TT>
164
<BR>
<A href=#page164>164</A>
<strong><A name=page165> Page 165</A></strong>
<A href=#page166>166</A>
<BR>
<P>
Instruction Descriptions <B>4– 109 <BR>
4.10. 4 Move from/ to Floating-Point Control Register <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>CASE <BR>
MF_ FPCR: Fa </TT>¬ <TT>FPCR <BR>
MT_ FPCR: FPCR </TT>¬ <TT>Fav <BR>
ENDCASE <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>The Floating-point Control Register (FPCR) is read from (MF_ FPCR) or written to <BR>
(MT_ FPCR), a floating-point register. The floating-point register to be used is specified by the <BR>
Fa, Fb, and Fc fields all pointing to the same floating-point register. If the Fa, Fb, and Fc fields <BR>
do not all point to the same floating-point register, then it is UNPREDICTABLE which regis-ter <BR>
is used. If the Fa, Fb, and Fc fields do not all point to the same floating-point register, the <BR>
resulting values in the Fc register and in FPCR are UNPREDICTABLE. <BR>
<P>
If the Fc f ield is F31 in the case of MT_ FPCR, the resulting value in FPCR is <BR>
UNPREDICTABLE. <BR>
<P>
The use of these instructions and the FPCR are described <A href="#page135">in Section 4.7.8. <BR>
</A>
<P>
Mx_ FPCR Fa. rq, Fa. rq, Fa. wq !Floating-point Operate format <BR>
None <BR>
MF_ FPCR Move from Floating-point Control Register <BR>
MT_ FPCR Move to Floating-point Control Register <BR>
<P>
None 
165
<BR>
<A href=#page165>165</A>
<strong><A name=page166> Page 166</A></strong>
<A href=#page167>167</A>
<BR>
<P>
<B>4– 110 </B>Alpha Architecture Handbook <BR>
<B>4.10. 5 VAX Floating Add <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Fc </TT>¬ <TT>Fav + Fbv <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
</B><P>
<B>Description: <BR>
</B>Register Fa is added to register Fb, and the sum is written to register Fc. <BR>
<P>
The sum is rounded or chopped to the specified precision, and then the corresponding range is <BR>
checked for overflow/ underflow. The single-precision operation on canonical single-precision <BR>
values produces a canonical single-precision result. <BR>
<P>
An invalid operation trap is signaled if either operand has exp= 0 and is not a true zero (that is, <BR>
VAX reserved operands and dirty zeros trap). The contents of Fc are UNPREDICTABLE if <BR>
this occurs. See <A href="#page125">Section 4.7.7 </A>
for details of the stored result on overflow or underflow. <BR>
<P>
ADDx Fa. rx, Fb. rx, Fc. wx !Floating-point Operate format <BR>
Invalid Operation <BR>
Overflow <BR>
Underflow <BR>
<P>
ADDF Add F_ floating <BR>
ADDG Add G_ floating <BR>
<P>
Rounding: Chopped (/ C) <BR>
Trapping: Exception Completion (/ S) <BR>
Underflow Enable (/ U) 
166
<BR>
<A href=#page166>166</A>
<strong><A name=page167> Page 167</A></strong>
<A href=#page168>168</A>
<BR>
<P>
Instruction Descriptions <B>4– 111 <BR>
4.10. 6 IEEE Floating Add <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Fc </TT>¬ <TT>Fav + Fbv <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
</B><P>
<B>Description: <BR>
</B>Register Fa is added to register Fb, and the sum is written to register Fc. <BR>
<P>
The sum is rounded to the specified precision and then the corresponding range is checked for <BR>
overflow/ underflow. The single-precision operation on canonical single-precision values pro-duces <BR>
a canonical single-precision result. <BR>
<P>
See <A href="#page125">Section 4.7.7 </A>
for details of the stored result on overflow, underflow, or inexact result. <BR>
<P>
ADDx Fa. rx, Fb. rx, Fc. wx !Floating-point Operate format <BR>
Invalid Operation <BR>
Overflow <BR>
Underflow <BR>
Inexact Result <BR>
<P>
ADDS Add S_ floating <BR>
ADDT Add T_ floating <BR>
<P>
Rounding: Dynamic (/ D) <BR>
Minus infinity (/ M) <BR>
Chopped (/ C) <BR>
Trapping: Exception Completion (/ S) <BR>
Underflow Enable (/ U) <BR>
Inexact Enable (/ I) 
167
<BR>
<A href=#page167>167</A>
<strong><A name=page168> Page 168</A></strong>
<A href=#page169>169</A>
<BR>
<B>4– 112 </B>Alpha Architecture Handbook <BR>
<B>4.10. 7 VAX Floating Compare <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>IF Fav SIGNED_ RELATION Fbv THEN <BR>
Fc </TT>¬ <TT>4000 0000 0000 0000 16 <BR>
</TT><P>
<TT>ELSE <BR>
Fc </TT>¬ <TT>0000 0000 0000 0000 16 <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>The two operands in Fa and Fb are compared. If the relationship specified by the qualifier is <BR>
true, a non-zero floating value (0. 5) is written to register Fc; otherwise, a true zero is written to <BR>
Fc. <BR>
<P>
Comparisons are exact and never overflow or underflow. Three mutually exclusive relations <BR>
are possible: less than, equal, and greater than. <BR>
<P>
An invalid operation trap is signaled if either operand has exp= 0 and is not a true zero (that is, <BR>
VAX reserved operands and dirty zeros trap). The contents of Fc are UNPREDICTABLE if <BR>
this occurs. <BR>
<P>
<B>Notes: <BR>
° </B>Compare Less Than A, B is the same as Compare Greater Than B, A; Compare Less Than or Equal A, B is the same as Compare Greater Than or Equal B, A. Therefore, only <BR>
<P>
the less-than operations are included. <BR>
<P>
CMPGyy Fa. rg, Fb. rg, Fc. wq !Floating-point Operate format <BR>
Invalid Operation <BR>
CMPGEQ Compare G_ floating Equal <BR>
CMPGLE Compare G_ floating Less Than or Equal <BR>
CMPGLT Compare G_ floating Less Than <BR>
<P>
Trapping: Exception Completion (/ S) 
168
<BR>
<A href=#page168>168</A>
<strong><A name=page169> Page 169</A></strong>
<A href=#page170>170</A>
<BR>
Instruction Descriptions <B>4– 113 <BR>
4.10. 8 IEEE Floating Compare <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>IF Fav SIGNED_ RELATION Fbv THEN <BR>
Fc </TT>¬ <TT>4000 0000 0000 0000 16 <BR>
</TT><P>
<TT>ELSE <BR>
Fc </TT>¬ <TT>0000 0000 0000 0000 16 <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>The two operands in Fa and Fb are compared. If the relationship specified by the qualifier is <BR>
true, a non-zero floating value (2. 0) is written to register Fc; otherwise, a true zero is written to <BR>
Fc. <BR>
<P>
Comparisons are exact and never overflow or underflow. Four mutually exclusive relations are <BR>
possible: less than, equal, greater than, and unordered. The unordered relation is true if one or <BR>
both operands are NaN. (This behavior must be provided by an operating system (OS) comple-tion <BR>
handler, since NaNs trap.) Comparisons ignore the sign of zero, so +0 = –0. <BR>
<P>
Comparisons with plus and minus infinity execute normally and do not take an invalid operation <BR>
trap. <BR>
<P>
<B>Notes: <BR>
</B><P>
<B>° </B>In order to use CMPTxx with exception completion handling, it is necessary to specify the /SU IEEE trap mode, even though an underflow trap is not possible. <BR>
<P>
<B>° </B>Compare Less Than A, B is the same as Compare Greater Than B, A; Compare Less Than or Equal A, B is the same as Compare Greater Than or Equal B, A. Therefore, only <BR>
the less-than operations are included. <BR>
<P>
CMPTyy Fa. rx, Fb. rx, Fc. wq !Floating-point Operate format <BR>
Invalid Operation <BR>
CMPTEQ Compare T_ floating Equal <BR>
CMPTLE Compare T_ floating Less Than or Equal <BR>
CMPTLT Compare T_ floating Less Than <BR>
CMPTUN Compare T_ floating Unordered <BR>
<P>
Trapping: Exception Completion (/ SU) 
169
<BR>
<A href=#page169>169</A>
<strong><A name=page170> Page 170</A></strong>
<A href=#page171>171</A>
<BR>
<P>
<B>4– 114 </B>Alpha Architecture Handbook <BR>
<B>4.10. 9 Convert VAX Floating to Integer <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Fc </TT>¬ <TT>{conversion of Fbv} <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
</B><P>
<B>Description: <BR>
</B>The floating operand in register Fb is converted to a two's-complement quadword number and <BR>
written to register Fc. The conversion aligns the operand fraction with the binary point just to <BR>
the right of bit zero, rounds as specified, and complements the result if negative. Register Fa <BR>
must be F31. <BR>
<P>
An invalid operation trap is signaled if the operand has exp= 0 and is not a true zero (that is, <BR>
VAX reserved operands and dirty zeros trap). The contents of Fc are UNPREDICTABLE if <BR>
this occurs. <BR>
<P>
See <A href="#page125">Section 4.7.7 </A>
for details of the stored result on integer overflow. <BR>
<P>
CVTGQ Fb. rx, Fc. wq !Floating-point Operate format <BR>
Invalid Operation <BR>
Integer Overflow <BR>
<P>
CVTGQ Convert G_ floating to Quadword <BR>
Rounding: Chopped (/ C) <BR>
Trapping: Exception Completion (/ S) <BR>
Integer Overflow Enable (/ V) 
170
<BR>
<A href=#page170>170</A>
<strong><A name=page171> Page 171</A></strong>
<A href=#page172>172</A>
<BR>
Instruction Descriptions <B>4– 115 <BR>
4.10. 10 Convert Integer to VAX Floating <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Fc </TT>¬ <TT>{conversion of Fbv&lt; 63: 0&gt;} <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>The two's-complement quadword operand in register Fb is converted to a single-or dou-ble-<BR>
precision floating result and written to register Fc. The conversion complements a number <BR>
if negative, normalizes it, rounds to the target precision, and packs the result with an appropri-ate <BR>
sign and exponent field. Register Fa must be F31. <BR>
<P>
CVTQy Fb. rq, Fc. wx !Floating-point Operate format <BR>
None <BR>
CVTQF Convert Quadword to F_ floating <BR>
CVTQG Convert Quadword to G_ floating <BR>
<P>
Rounding: Chopped (/ C) 
171
<BR>
<A href=#page171>171</A>
<strong><A name=page172> Page 172</A></strong>
<A href=#page173>173</A>
<BR>
<P>
<B>4– 116 </B>Alpha Architecture Handbook <BR>
<B>4.10. 11 Convert VAX Floating to VAX Floating <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Fc </TT>¬ <TT>{conversion of Fbv} <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>The floating operand in register Fb is converted to the specified alternate floating format and <BR>
written to register Fc. Register Fa must be F31. <BR>
<P>
An invalid operation trap is signaled if the operand has exp= 0 and is not a true zero (that is, <BR>
VAX reserved operands and dirty zeros trap). The contents of Fc are UNPREDICTABLE if <BR>
this occurs. <BR>
<P>
See <A href="#page125">Section 4.7.7 </A>
for details of the stored result on overflow or underflow. <BR>
<P>
<B>Notes: <BR>
° </B>The only arithmetic operations on D_ floating values are conversions to and from G_ floating. The conversion to G_ floating rounds or chops as specified, removing three <BR>
<P>
fraction bits. The conversion from G_ floating to D_ floating adds three low-order zeros <BR>
as fraction bits, then the 8-bit exponent range is checked for overflow/ underflow. <BR>
<P>
<B>° </B>The conversion from G_ floating to F_ floating rounds or chops to single precision, then the 8-bit exponent range is checked for overflow/ underflow. <BR>
<P>
<B>° </B>No conversion from F_ floating to G_ floating is required, since F_ floating values are always stored in registers as equivalent G_ floating values. <BR>
<P>
CVTxy Fb. rx, Fc. wx !Floating-point Operate format <BR>
Invalid Operation <BR>
Overflow <BR>
Underflow <BR>
<P>
CVTDG Convert D_ floating to G_ floating <BR>
CVTGD Convert G_ floating to D_ floating <BR>
CVTGF Convert G_ floating to F_ floating <BR>
<P>
Rounding: Chopped (/ C) <BR>
Trapping: Exception Completion (/ S) <BR>
Underflow Enable (/ U) 
172
<BR>
<A href=#page172>172</A>
<strong><A name=page173> Page 173</A></strong>
<A href=#page174>174</A>
<BR>
<P>
Instruction Descriptions <B>4– 117 <BR>
4.10. 12 Convert IEEE Floating to Integer <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Fc </TT>¬ <TT>{conversion of Fbv} <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
</B><P>
<B>Description: <BR>
</B>The floating operand in register Fb is converted to a two's-complement number and written to <BR>
register Fc. The conversion aligns the operand fraction with the binary point just to the right of <BR>
bit zero, rounds as specified, and complements the result if negative. Register Fa must be F31. <BR>
<P>
See <A href="#page125">Section 4.7.7 </A>
for details of the stored result on integer overflow and inexact result. <BR>
<P>
CVTTQ Fb. rx, Fc. wq !Floating-point Operate format <BR>
Invalid Operation <BR>
Inexact Result <BR>
Integer Overflow <BR>
<P>
CVTTQ Convert T_ floating to Quadword <BR>
Rounding: Dynamic (/ D) <BR>
Minus infinity (/ M) <BR>
Chopped (/ C) <BR>
Trapping: Exception Completion (/ S) <BR>
Integer Overflow Enable (/ V) <BR>
Inexact Enable (/ I) 
173
<BR>
<A href=#page173>173</A>
<strong><A name=page174> Page 174</A></strong>
<A href=#page175>175</A>
<BR>
<P>
<B>4– 118 </B>Alpha Architecture Handbook <BR>
<B>4.10. 13 Convert Integer to IEEE Floating <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Fc </TT>¬ <TT>{conversion of Fbv&lt; 63: 0&gt;} <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
</B><P>
<B>Description: <BR>
</B>The two's-complement operand in register Fb is converted to a single-or double-precision <BR>
floating result and written to register Fc. The conversion complements a number if negative, <BR>
normalizes it, rounds to the target precision, and packs the result with an appropriate sign and <BR>
exponent field. Register Fa must be F31. <BR>
<P>
See <A href="#page125">Section 4.7.7 </A>
for details of the stored result on inexact result. <BR>
<P>
<B>Notes: <BR>
° </B>In order to use CVTQS or CVTQT with exception completion handling, it is necessary to specify the /SUI IEEE trap mode, even though an underflow trap is not possible. <BR>
<P>
CVTQy Fb. rq, Fc. wx !Floating-point Operate format <BR>
Inexact Result <BR>
CVTQS Convert Quadword to S_ floating <BR>
CVTQT Convert Quadword to T_ floating <BR>
<P>
Rounding: Dynamic (/ D) <BR>
Minus infinity (/ M) <BR>
Chopped (/ C) <BR>
Trapping: Exception Completion (/ S) <BR>
Inexact Enable (/ I) 
174
<BR>
<A href=#page174>174</A>
<strong><A name=page175> Page 175</A></strong>
<A href=#page176>176</A>
<BR>
Instruction Descriptions <B>4– 119 <BR>
4.10. 14 Convert IEEE S_ Floating to IEEE T_ Floating <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Fc </TT>¬ <TT>{conversion of Fbv} <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>The S_ floating operand in register Fb is converted to T_ floating format and written to register <BR>
Fc. Register Fa must be F31. <BR>
<P>
<B>Notes: <BR>
° </B>The conversion from S_ floating to T_ floating is exact. No rounding occurs. No under-flow, overflow, or inexact result can occur. In fact, the conversion for finite values is the <BR>
<P>
identity transformation. <BR>
<B>° </B>A trap handler can convert an S_ floating denormal value into the corresponding T_ floating finite value by adding 896 to the exponent and normalizing. <BR>
<P>
CVTST Fb. rx, Fc. wx ! Floating-point Operate format <BR>
Invalid Operation <BR>
CVTST Convert S_ floating to T_ floating <BR>
Trapping: Exception Completion (/ S) 
175
<BR>
<A href=#page175>175</A>
<strong><A name=page176> Page 176</A></strong>
<A href=#page177>177</A>
<BR>
<P>
<B>4– 120 </B>Alpha Architecture Handbook <BR>
<B>4.10. 15 Convert IEEE T_ Floating to IEEE S_ Floating <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Fc </TT>¬ <TT>{conversion of Fbv} <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
</B><P>
<B>Description: <BR>
</B>The T_ floating operand in register Fb is converted to S_ floating format and written to register <BR>
Fc. Register Fa must be F31. <BR>
<P>
See <A href="#page125">Section 4.7.7 </A>
for details of the stored result on overflow, underflow, or inexact result. <BR>
<P>
CVTTS Fb. rx, Fc. wx !Floating-point Operate format <BR>
Invalid Operation <BR>
Overflow <BR>
Underflow <BR>
Inexact Result <BR>
<P>
CVTTS Convert T_ floating to S_ floating <BR>
Rounding: Dynamic (/ D) <BR>
Minus infinity (/ M) <BR>
Chopped (/ C) <BR>
Trapping: Exception Completion (/ S) <BR>
Underflow Enable (/ U) <BR>
Inexact Enable (/ I) 
176
<BR>
<A href=#page176>176</A>
<strong><A name=page177> Page 177</A></strong>
<A href=#page178>178</A>
<BR>
<P>
Instruction Descriptions <B>4– 121 <BR>
4.10. 16 VAX Floating Divide <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Fc </TT>¬ <TT>Fav / Fbv <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
</B><P>
<B>Description: <BR>
</B>The dividend operand in register Fa is divided by the divisor operand in register Fb and the <BR>
quotient is written to register Fc. <BR>
<P>
The quotient is rounded or chopped to the specified precision and then the corresponding range <BR>
is checked for overflow/ underflow. The single-precision operation on canonical single-preci-sion <BR>
values produces a canonical single-precision result. <BR>
<P>
An invalid operation trap is signaled if either operand has exp= 0 and is not a true zero (that is, <BR>
VAX reserved operands and dirty zeros trap). The contents of Fc are UNPREDICTABLE if <BR>
this occurs. <BR>
<P>
A division by zero trap is signaled if Fbv is zero. The contents of Fc are UNPREDICTABLE if <BR>
this occurs. <BR>
<P>
See <A href="#page125">Section 4.7.7 </A>
for details of the stored result on overflow or underflow. <BR>
<P>
DIVx Fa. rx, Fb. rx, Fc. wx !Floating-point Operate format <BR>
Invalid Operation <BR>
Division by Zero <BR>
Overflow <BR>
Underflow <BR>
<P>
DIVF Divide F_ floating <BR>
DIVG Divide G_ floating <BR>
<P>
Rounding: Chopped (/ C) <BR>
Trapping: Exception Completion (/ S) <BR>
Underflow Enable (/ U) 
177
<BR>
<A href=#page177>177</A>
<strong><A name=page178> Page 178</A></strong>
<A href=#page179>179</A>
<BR>
<P>
<B>4– 122 </B>Alpha Architecture Handbook <BR>
<B>4.10. 17 IEEE Floating Divide <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Fc </TT>¬ <TT>Fav / Fbv <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
</B><P>
<B>Description: <BR>
</B>The dividend operand in register Fa is divided by the divisor operand in register Fb and the <BR>
quotient is written to register Fc. <BR>
<P>
The quotient is rounded to the specified precision and then the corresponding range is checked <BR>
for overflow/ underflow. The single-precision operation on canonical single-precision values <BR>
produces a canonical single-precision result. <BR>
<P>
See <A href="#page125">Section 4.7.7 </A>
for details of the stored result on overflow, underflow, or inexact result. <BR>
<P>
DIVx Fa. rx, Fb. rx, Fc. wx !Floating-point Operate format <BR>
Invalid Operation <BR>
Division by Zero <BR>
Overflow <BR>
Underflow <BR>
Inexact Result <BR>
<P>
DIVS Divide S_ floating <BR>
DIVT Divide T_ floating <BR>
<P>
Rounding: Dynamic (/ D) <BR>
Minus infinity (/ M) <BR>
Chopped (/ C) <BR>
Trapping: Exception Completion (/ S) <BR>
Underflow Enable (/ U) <BR>
Inexact Enable (/ I) 
178
<BR>
<A href=#page178>178</A>
<strong><A name=page179> Page 179</A></strong>
<A href=#page180>180</A>
<BR>
Instruction Descriptions <B>4– 123 <BR>
4.10. 18 Floating-Point Register to Integer Register Move <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>CASE: <BR>
FTOIS: <BR>
Rc&lt; 63: 32&gt; </TT>¬ <TT>SEXT( Fav&lt; 63&gt;) <BR>
Rc&lt; 31: 0&gt; </TT>¬ <TT>Fav&lt; 63: 62&gt; || Fav &lt;58: 29&gt; <BR>
FTOIT: <BR>
Rc &lt;-Fav <BR>
ENDCASE <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>Data in a floating-point register file is moved to an integer register file. <BR>
<P>
The Fb field must be F31. <BR>
The instructions do not interpret bits in the register files; specifically, the instructions do not <BR>
trap on non-finite values. Also, the instructions do not access memory. <BR>
<P>
FTOIS is exactly equivalent to the sequence: <BR>
<TT>STS <BR>
LDL <BR>
</TT><P>
FTOIT is exactly equivalent to the sequence: <BR>
<TT>STT <BR>
LDQ <BR>
</TT><P>
<B>Software Note: <BR>
</B>FTOIS and FTOIT are no slower than the corresponding store/ load sequence and can be <BR>
significantly faster. <BR>
<P>
FTOIx Fa. rq, Rc. wq !Floating-point Operate format <BR>
None <BR>
FTOIS Floating-point to Integer Register Move, S_ floating <BR>
FTOIT Floating-point to Integer Register Move, T_ floating <BR>
<P>
None 
179
<BR>
<A href=#page179>179</A>
<strong><A name=page180> Page 180</A></strong>
<A href=#page181>181</A>
<BR>
<B>4– 124 </B>Alpha Architecture Handbook <BR>
<B>4.10. 19 Integer Register to Floating-Point Register Move <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>CASE: <BR>
ITOFF: <BR>
Fc </TT>¬ <TT>Rav&lt; 31&gt; || MAP_ F( Rav&lt; 30: 23&gt; || Rav&lt; 22: 0&gt; || 0&lt; 28: 0&gt; <BR>
ITOFS: <BR>
Fc </TT>¬ <TT>Rav&lt; 31&gt; || MAP_ S( Rav&lt; 30: 23&gt; || Rav&lt; 22: 0&gt; || 0&lt; 28: 0&gt; <BR>
ITOFT: <BR>
Fc &lt;-Rav <BR>
ENDCASE <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>Data in an integer register file is moved to a floating-point register file. <BR>
<P>
The Rb field must be R31. <BR>
The instructions do not interpret bits in the register files; specifically, the instructions do not <BR>
trap on non-finite values. Also, the instructions do not access memory. <BR>
<P>
ITOFF is equivalent to the following sequence, except that the word swapping that LDF nor-mally <BR>
performs is not performed by ITOFF: <BR>
<P>
<TT>STL <BR>
LDF <BR>
</TT><P>
ITOFx Ra. rq, Fc. wq !Floating-point Operate format <BR>
None <BR>
ITOFF Integer to Floating-point Register Move, F_ floating <BR>
ITOFS Integer to Floating-point Register Move, S_ floating <BR>
ITOFT Integer to Floating-point Register Move, T_ floating <BR>
<P>
None 
180
<BR>
<A href=#page180>180</A>
<strong><A name=page181> Page 181</A></strong>
<A href=#page182>182</A>
<BR>
Instruction Descriptions <B>4– 125 <BR>
</B>ITOFS is exactly equivalent to the sequence: <BR>
<TT>STL <BR>
LDS <BR>
</TT>ITOFT is exactly equivalent to the sequence: <BR>
<P>
<TT>STQ <BR>
LDT <BR>
</TT><P>
<B>Software Note: <BR>
</B>ITOFF, ITOFS, and ITOFT are no slower than the corresponding store/ load sequence and <BR>
can be significantly faster. 
181
<BR>
<A href=#page181>181</A>
<strong><A name=page182> Page 182</A></strong>
<A href=#page183>183</A>
<BR>
<P>
<B>4– 126 </B>Alpha Architecture Handbook <BR>
<B>4.10. 20 VAX Floating Multiply <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Fc </TT>¬ <TT>Fav * Fbv <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
</B><P>
<B>Description: <BR>
</B>The multiplicand operand in register Fb is multiplied by the multiplier operand in register Fa <BR>
and the product is written to register Fc. <BR>
<P>
The product is rounded or chopped to the specified precision and then the corresponding range <BR>
is checked for overflow/ underflow. The single-precision operation on canonical single-preci-<BR>
sion values produces a canonical single-precision result. <BR>
<P>
An invalid operation trap is signaled if either operand has exp= 0 and is not a true zero (that is, <BR>
VAX reserved operands and dirty zeros trap). The contents of Fc are UNPREDICTABLE if <BR>
this occurs. <BR>
<P>
See <A href="#page125">Section 4.7.7 </A>
for details of the stored result on overflow or underflow. <BR>
<P>
MULx Fa. rx, Fb. rx, Fc. wx !Floating-point Operate format <BR>
Invalid Operation <BR>
Overflow <BR>
Underflow <BR>
<P>
MULF Multiply F_ floating <BR>
MULG Multiply G_ floating <BR>
<P>
Rounding: Chopped (/ C) <BR>
Trapping: Exception Completion (/ S) <BR>
Underflow Enable (/ U) 
182
<BR>
<A href=#page182>182</A>
<strong><A name=page183> Page 183</A></strong>
<A href=#page184>184</A>
<BR>
<P>
Instruction Descriptions <B>4– 127 <BR>
4.10. 21 IEEE Floating Multiply <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Fc </TT>¬ <TT>Fav * Fbv <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
</B><P>
<B>Description: <BR>
</B>The multiplicand operand in register Fb is multiplied by the multiplier operand in register Fa <BR>
and the product is written to register Fc. <BR>
<P>
The product is rounded to the specified precision and then the corresponding range is checked <BR>
for overflow/ underflow. The single-precision operation on canonical single-precision values <BR>
produces a canonical single-precision result. <BR>
<P>
See <A href="#page125">Section 4.7.7 </A>
for details of the stored result on overflow, underflow, or inexact result. <BR>
<P>
MULx Fa. rx, Fb. rx, Fc. wx !Floating-point Operate format <BR>
Invalid Operation <BR>
Overflow <BR>
Underflow <BR>
Inexact Result <BR>
<P>
MULS Multiply S_ floating <BR>
MULT Multiply T_ floating <BR>
<P>
Rounding: Dynamic (/ D) <BR>
Minus infinity (/ M) <BR>
Chopped (/ C) <BR>
Trapping: Exception Completion (/ S) <BR>
Underflow Enable (/ U) <BR>
Inexact Enable (/ I) 
183
<BR>
<A href=#page183>183</A>
<strong><A name=page184> Page 184</A></strong>
<A href=#page185>185</A>
<BR>
<B>4– 128 </B>Alpha Architecture Handbook <BR>
<B>4.10. 22 VAX Floating Square Root <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Fc </TT>¬ <TT>Fb ** (1/ 2) <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
</B><P>
<B>Description: <BR>
</B>The square root of the floating-point operand in register Fb is written to register Fc. (The Fa <BR>
field of this instruction must be set to a value of F31.) <BR>
<P>
The result is rounded or chopped to the specified precision. The single-precision operation on a <BR>
canonical single-precision value produces a canonical single-precision result. <BR>
<P>
An invalid operation is signaled if the operand has exp= 0 and is not a true zero (that is, VAX <BR>
reserved operands and dirty zeros trap). An invalid operation is signaled if the sign of the oper-and <BR>
is negative. <BR>
<P>
The contents of the Fc are UNPREDICTABLE if an invalid operation is signaled. <BR>
<P>
<B>Notes: <BR>
° </B>Floating-point overflow and underflow are not possible for square root operation. The underflow enable qualifier is ignored. <BR>
<P>
SQRTx Fb. rx, Fc. wx !Floating-point Operate format <BR>
Invalid operation <BR>
SQRTF Square root F_ floating <BR>
SQRTG Square root G_ floating <BR>
<P>
Rounding: Chopped (/ C) <BR>
Trapping: Exception Completion (/ S) <BR>
Underflow Enable (/ U) — See Notes below 
184
<BR>
<A href=#page184>184</A>
<strong><A name=page185> Page 185</A></strong>
<A href=#page186>186</A>
<BR>
Instruction Descriptions <B>4– 129 <BR>
4.10. 23 IEEE Floating Square Root <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Fc </TT>¬ <TT>Fb ** (1/ 2) <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
</B><P>
<B>Description: <BR>
</B>The square root of the floating-point operand in register Fb is written to register Fc. (The Fa <BR>
field of this instruction must be set to a value of F31.) <BR>
<P>
The result is rounded to the specified precision. The single-precision operation on a canonical <BR>
single-precision value produces a canonical single-precision result. <BR>
<P>
An invalid operation is signaled if the sign of the operand is less than zero. However, SQRT <BR>
(– 0) produces a result of –0. <BR>
<P>
<B>Notes: <BR>
° </B>Floating-point overflow and underflow are not possible for square root operation. The underflow enable qualifier is ignored. <BR>
<P>
SQRTx Fb. rx, Fc. wx !Floating-point Operate format <BR>
Inexact result <BR>
Invalid operation <BR>
<P>
SQRTS Square root S_ floating <BR>
SQRTT Square root T_ floating <BR>
<P>
Rounding: Chopped (/ C) <BR>
Dynamic (/ D) <BR>
Minus infinity (/ M) <BR>
Trapping: Inexact Enable (/ I) <BR>
Exception Completion (/ S) <BR>
Underflow Enable (/ U) — See Notes below 
185
<BR>
<A href=#page185>185</A>
<strong><A name=page186> Page 186</A></strong>
<A href=#page187>187</A>
<BR>
<P>
<B>4– 130 </B>Alpha Architecture Handbook <BR>
<B>4.10. 24 VAX Floating Subtract <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Fc </TT>¬ <TT>Fav -Fbv <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
</B><P>
<B>Description: <BR>
</B>The subtrahend operand in register Fb is subtracted from the minuend operand in register Fa <BR>
and the difference is written to register Fc. <BR>
<P>
The difference is rounded or chopped to the specified precision and then the corresponding <BR>
range is checked for overflow/ underflow. The single-precision operation on canonical sin-gle-<BR>
precision values produces a canonical single-precision result. <BR>
<P>
An invalid operation trap is signaled if either operand has exp= 0 and is not a true zero (that is, <BR>
VAX reserved operands and dirty zeros trap). The contents of Fc are UNPREDICTABLE if <BR>
this occurs. <BR>
<P>
See <A href="#page125">Section 4.7.7 </A>
for details of the stored result on overflow or underflow. <BR>
<P>
SUBx Fa. rx, Fb. rx, Fc. wx !Floating-point Operate format <BR>
Invalid Operation <BR>
Overflow <BR>
Underflow <BR>
<P>
SUBF Subtract F_ floating <BR>
SUBG Subtract G_ floating <BR>
<P>
Rounding: Chopped (/ C) <BR>
Trapping: Exception Completion (/ S) <BR>
Underflow Enable (/ U) 
186
<BR>
<A href=#page186>186</A>
<strong><A name=page187> Page 187</A></strong>
<A href=#page188>188</A>
<BR>
<P>
Instruction Descriptions <B>4– 131 <BR>
4.10. 25 IEEE Floating Subtract <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Fc </TT>¬ <TT>Fav -Fbv <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
</B><P>
<B>Description: <BR>
</B>The subtrahend operand in register Fb is subtracted from the minuend operand in register Fa <BR>
and the difference is written to register Fc. <BR>
<P>
The difference is rounded to the specified precision and then the corresponding range is <BR>
checked for overflow/ underflow. The single-precision operation on canonical single-precision <BR>
values produces a canonical single-precision result. <BR>
<P>
See <A href="#page125">Section 4.7.7 </A>
for details of the stored result on overflow, underflow, or inexact result. <BR>
<P>
SUBx Fa. rx, Fb. rx, Fc. wx !Floating-point Operate format <BR>
Invalid Operation <BR>
Overflow <BR>
Underflow <BR>
Inexact Result <BR>
<P>
SUBS Subtract S_ floating <BR>
SUBT Subtract T_ floating <BR>
<P>
Rounding: Dynamic (/ D) <BR>
Minus infinity (/ M) <BR>
Chopped (/ C) <BR>
Trapping: Exception Completion (/ S) <BR>
Underflow Enable (/ U) <BR>
Inexact Enable (/ I) 
187
<BR>
<A href=#page187>187</A>
<strong><A name=page188> Page 188</A></strong>
<A href=#page189>189</A>
<BR>
<P>
<B>4– 132 </B>Alpha Architecture Handbook <BR>
<B>4.11 Miscellaneous Instructions <BR>
</B>Alpha provides the miscellaneous instructions shown <A href="#page188">in Table 4– 17. <BR>
</A>
<P>
<B>Table 4– 17: Miscellaneous Instructions Summary <BR>
Mnemonic Operation <BR>
</B>AMASK Architecture Mask <BR>
CALL_ PAL Call Privileged Architecture Library Routine <BR>
ECB Evict Cache Block <BR>
EXCB Exception Barrier <BR>
FETCH Prefetch Data <BR>
FETCH_ M Prefetch Data, Modify Intent <BR>
IMPLVER Implementation Version <BR>
MB Memory Barrier <BR>
RPCC Read Processor Cycle Counter <BR>
TRAPB Trap Barrier <BR>
WH64 Write Hint — 64 Bytes <BR>
WMB Write Memory Barrier 
188
<BR>
<A href=#page188>188</A>
<strong><A name=page189> Page 189</A></strong>
<A href=#page190>190</A>
<BR>
<P>
Instruction Descriptions <B>4– 133 <BR>
4.11. 1 Architecture Mask <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Rc </TT>¬ <TT>Rbv AND {NOT CPU_ feature_ mask} <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>Rbv represents a mask of the requested architectural extensions. Bits are cleared that corre-spond <BR>
to architectural extensions that are present. Reserved bits and bits that correspond to <BR>
absent extensions are copied unchanged. In either case, the result is placed in Rc. If the result <BR>
is zero, all requested features are present. <BR>
<P>
Software may specify an Rbv of all 1's to determine the complete set of architectural exten-sions <BR>
implemented by a processor. Assigned bit definitions are located <A href="#page327">in Section D. </A>
3. <BR>
<P>
Ra must be R31 or the result in Rc is UNPREDICTABLE and it is UNPREDICTABLE <BR>
whether an exception is signaled. <BR>
<P>
<B>Software Note: <BR>
</B>Use this instruction to make instruction-set decisions; use IMPLVER to make code-tuning <BR>
decisions. <BR>
<P>
<B>Implementation Note: <BR>
</B>Instruction encoding is implemented as follows: <BR>
<P>
<B>° </B>On 21064/ 21064A/ 21066/ 21068/ 21066A (EV4/ EV45/ LCA/ LCA45 chips), AMASK copies Rbv to Rc. <BR>
<P>
<B>° </B>On 21164 (EV5), AMASK copies Rbv to Rc. <BR>
<P>
AMASK Rb. rq, Rc. wq !Operate format <BR>
AMASK #b. ib, Rc. wq !Operate format <BR>
<P>
None <BR>
AMASK Architecture Mask <BR>
None 
189
<BR>
<A href=#page189>189</A>
<strong><A name=page190> Page 190</A></strong>
<A href=#page191>191</A>
<BR>
<P>
<B>4– 134 </B>Alpha Architecture Handbook <BR>
<B>° </B>On 21164A (EV56), 21164PC (PCA56), and 21264 (EV6), AMASK correctly indicates support for architecture extensions by copying Rbv to Rc and clearing appropriate bits. <BR>
Bits are assigned and placed in Appendix <A href="#page325">D </A>
for architecture extensions as ECOs for those <BR>
extensions are passed. The low 8 bits are reserved for standard architecture extensions so <BR>
they can be tested with a literal; application-specific extensions are assigned from bit 8 <BR>
upward. 
190
<BR>
<A href=#page190>190</A>
<strong><A name=page191> Page 191</A></strong>
<A href=#page192>192</A>
<BR>
Instruction Descriptions <B>4– 135 <BR>
4.11. 2 Call Privileged Architecture Library <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>{Stall instruction issuing until all <BR>
prior instructions are guaranteed to <BR>
complete without incurring exceptions.} <BR>
{Trap to PALcode.} <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>The CALL_ PAL instruction is not issued until all previous instructions are guaranteed to com-plete <BR>
without exceptions. If an exception occurs, the continuation PC in the exception stack <BR>
frame points to the CALL_ PAL instruction. The CALL_ PAL instruction causes a trap to <BR>
PALcode. <BR>
<P>
CALL_ PAL fnc. ir !PAL format <BR>
None <BR>
CALL_ PAL Call Privileged Architecture Library <BR>
None 
191
<BR>
<A href=#page191>191</A>
<strong><A name=page192> Page 192</A></strong>
<A href=#page193>193</A>
<BR>
<B>4– 136 </B>Alpha Architecture Handbook <BR>
<B>4.11. 3 Evict Data Cache Block <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>va </TT>¬ <TT>Rbv <BR>
</TT><P>
<TT>IF { va maps to memory space } THEN <BR>
Prepare to reuse cache resources that are occupied by the <BR>
the addressed byte. <BR>
END <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>The ECB instruction provides a hint that the addressed location will not be referenced again in <BR>
the near future, so any cache space it occupies should be made available to cache other mem-ory <BR>
locations. If the cache copy of the location is dirty, the processor may start writing it back; <BR>
if the cache has multiple sets, the processor may arrange for the set containing the addressed <BR>
byte to be the next set allocated. <BR>
<P>
The ECB instruction does not generate exceptions; if it encounters data address translation <BR>
errors (access violation, translation not valid, and so forth) during execution, it is treated as a <BR>
NOP. <BR>
<P>
If the address maps to non-memory-like (I/ O) space, ECB is treated as a NOP. <BR>
<P>
<B>Software Note: <BR>
° </B>ECB makes a particular cache location available for reuse by evicting and invalidating its contents. The intent is to give software more control over cache allocation policy in <BR>
<P>
set-associative caches so that "useful" blocks can be retained in the cache. <BR>
<B>° </B>ECB is a performance hint — it does not serialize the eviction of the addressed cache block with any preceding or following memory operation. <BR>
<P>
ECB (Rb. ab) ! Memory format <BR>
None <BR>
ECB Evict Cache Block <BR>
None 
192
<BR>
<A href=#page192>192</A>
<strong><A name=page193> Page 193</A></strong>
<A href=#page194>194</A>
<BR>
Instruction Descriptions <B>4– 137 <BR>
° </B>ECB is not intended for flushing caches prior to power failure or low power operation — CFLUSH is intended for that purpose. <BR>
<B>Implementation Note: <BR>
</B>Implementations with set-associative caches are encouraged to update their allocation <BR>
pointer so that the next D-stream reference that misses the cache and maps to this line is <BR>
allocated into the vacated set. 
193
<BR>
<A href=#page193>193</A>
<strong><A name=page194> Page 194</A></strong>
<A href=#page195>195</A>
<BR>
<P>
<B>4– 138 </B>Alpha Architecture Handbook <BR>
<B>4. 11. 4 Exception Barrier <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>{EXCB does not appear to issue until completion of all <BR>
exceptions and dependencies on the Floating-point Control <BR>
Register (FPCR) from prior instructions.} <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>The EXCB instruction allows software to guarantee that in a pipelined implementation, all pre-vious <BR>
instructions have completed any behavior related to exceptions or rounding modes before <BR>
any instructions after the EXCB are issued. <BR>
<P>
In particular, all changes to the Floating-point Control Register (FPCR) are guaranteed to have <BR>
been made, whether or not there is an associated exception. Also, all potential floating-point <BR>
exceptions and integer overflow exceptions are guaranteed to have been taken. EXCB is thus a <BR>
superset of TRAPB. <BR>
<P>
If a floating-point exception occurs for which trapping is enabled, the EXCB instruction acts <BR>
like a fault. In this case, the value of the Program Counter reported to the program may be the <BR>
address of the EXCB instruction (or earlier) but is never the address of an instruction follow-ing <BR>
the EXCB. <BR>
<P>
The relationship between EXCB and the FPCR is described <A href="#page138">in Section 4. 7.8.1. <BR>
</A>
<P>
EXCB ! Memory format <BR>
None <BR>
EXCB Exception Barrier <BR>
None 
194
<BR>
<A href=#page194>194</A>
<strong><A name=page195> Page 195</A></strong>
<A href=#page196>196</A>
<BR>
<P>
Instruction Descriptions <B>4– 139 <BR>
4.11. 5 Prefetch Data <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>va </TT>¬ <TT>{Rbv} <BR>
{Optionally prefetch aligned 512-byte block surrounding va.} <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>The virtual address is given by Rbv. This address is used to designate an aligned 512-byte <BR>
block of data. An implementation may optionally attempt to move all or part of this block (or a <BR>
larger surrounding block) of data to a part of the memory hierarchy that has faster-access, in <BR>
anticipation of subsequent Load or Store instructions that access that data. <BR>
<P>
<B>Implementation Note: <BR>
</B>FETCHx is intended to help software overlap memory latencies when such latencies are on <BR>
the order of at least 100 cycles. FETCHx is unlikely to help (or be implemented) for <BR>
significantly shorter memory latencies. Code scheduling and cache-line prefetching (See <BR>
<A href="#page282">Section A. 3.5) </A>
should be used to overlap such shorter latencies. <BR>
<P>
Existing Alpha implementations (through the 21264) have memory latencies that are too <BR>
short to profitably implement FETCHx. Therefore, FETCHx does not improve memory <BR>
performance in existing Alpha implementations. <BR>
<P>
The FETCH instruction is a hint to the implementation that may allow faster execution. An <BR>
implementation is free to ignore the hint. If prefetching is done in an implementation, the order <BR>
of fetch within the designated block is UNPREDICTABLE. <BR>
<P>
The FETCH_ M instruction gives the additional hint that modifications (stores) to some or all <BR>
of the data block are anticipated. <BR>
<P>
FETCHx 0( Rb. ab) !Memory format <BR>
None <BR>
FETCH Prefetch Data <BR>
FETCH_ M Prefetch Data, Modify Intent <BR>
<P>
None 
195
<BR>
<A href=#page195>195</A>
<strong><A name=page196> Page 196</A></strong>
<A href=#page197>197</A>
<BR>
<B>4– 140 </B>Alpha Architecture Handbook <BR>
No exceptions are generated by FETCHx. If a Load (or Store in the case of FETCH_ M) that <BR>
uses the same address would fault, the prefetch request is ignored. It is UNPREDICTABLE <BR>
whether a TB-miss fault is ever taken by FETCHx. <BR>
<P>
<B>Implementation Note: <BR>
</B>Implementations are encouraged to take the TB-miss fault, then continue the prefetch. 
196
<BR>
<A href=#page196>196</A>
<strong><A name=page197> Page 197</A></strong>
<A href=#page198>198</A>
<BR>
Instruction Descriptions <B>4– 141 <BR>
4.11. 6 Implementation Version <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Rc </TT>¬ <TT>value, which is defined in Appendix D <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Description: <BR>
</B>A small integer is placed in Rc that specifies the major implementation version of the proces-sor <BR>
on which it is executed. This information can be used to make code-scheduling or tuning <BR>
decisions, or the information can be used to branch to different pieces of code optimized for <BR>
different implementations. <BR>
<P>
<B>Notes: <BR>
° </B>The value returned by IMPLVER does not identify the particular processor type. Rather, it identifies a group of processors that can be treated similarly for performance <BR>
<P>
characteristics such as scheduling. Ra must be R31 and Rb must be the literal #1 or the <BR>
result in Rc is UNPREDICTABLE and it is UNPREDICTABLE whether an exception <BR>
is signaled. <BR>
<P>
<B>Software Note: <BR>
</B>Use this instruction to make code-tuning decisions; use AMASK to make instruction-set <BR>
decisions. <BR>
<P>
IMPLVER Rc !Operate format <BR>
None <BR>
IMPLVER Implementation Version 
197
<BR>
<A href=#page197>197</A>
<strong><A name=page198> Page 198</A></strong>
<A href=#page199>199</A>
<BR>
<B>4– 142 </B>Alpha Architecture Handbook <BR>
<B>4.11. 7 Memory Barrier <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>{Guarantee that all subsequent loads or stores <BR>
will not access memory until after all previous <BR>
loads and stores have accessed memory, as <BR>
observed by other processors.} <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>The use of the Memory Barrier (MB) instruction is required only in multiprocessor systems. <BR>
<P>
In the absence of an MB instruction, loads and stores to different physical locations are <BR>
allowed to complete out of order on the issuing processor as observed by other processors. The <BR>
MB instruction allows memory accesses to be serialized on the issuing processor as observed <BR>
by other processors. See Chapter 5 for details on using the MB instruction to serialize these <BR>
accesses. Chapter 5 also details coordinating memory accesses across processors. <BR>
<P>
Note that MB ensures serialization only; it does not necessarily accelerate the progress of <BR>
memory operations. <BR>
<P>
MB !Memory format <BR>
None <BR>
MB Memory Barrier <BR>
None 
198
<BR>
<A href=#page198>198</A>
<strong><A name=page199> Page 199</A></strong>
<A href=#page200>200</A>
<BR>
<P>
Instruction Descriptions <B>4– 143 <BR>
4.11. 8 Read Processor Cycle Counter <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Ra </TT>¬ <TT>{cycle counter} <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>Register Ra is written with the processor cycle counter (PCC). The PCC register consists of <BR>
two 32-bit fields. The low-order 32 bits (PCC&lt; 31: 0&gt;) are an unsigned, wrapping counter, <BR>
PCC_ CNT. The high-order 32 bits (PCC&lt; 63: 32&gt;), PCC_ OFF, are operating-system depen-dent <BR>
in their implementation. <BR>
<P>
See <A href="#page43">Section 3.1.5 </A>
for a description of the PCC. <BR>
If an operating system uses PCC_ OFF to calculate the per-process or per-thread cycle count, <BR>
that count must be derived from the 32-bit sum of PCC_ OFF and PCC_ CNT. The following <BR>
example computes that cycle count, modulo 2** 32, and returns the count value in R0. Notice <BR>
the care taken not to cause an unwanted sign extension. <BR>
<P>
<TT>RPCC R0 ; Read the process cycle counter <BR>
SLL R0, #32, R1 ; Line up the offset and count fields <BR>
ADDQ R0, R1, R0 ; Do add <BR>
SRL R0, #32, R0 ; Zero extend the count to 64 bits <BR>
</TT><P>
The following example code returns the value of PCC_ CNT in R0&lt; 31: 0&gt; and all zeros in <BR>
R0&lt; 63: 32&gt;. <BR>
<P>
<TT>RPCC R0 <BR>
ZAPNOT R0,# 15, R0 <BR>
</TT><P>
RPCC Ra. wq !Memory format <BR>
None <BR>
RPCC Read Processor Cycle Counter <BR>
None 
199
<BR>
<A href=#page199>199</A>
<strong><A name=page200> Page 200</A></strong>
<A href=#page201>201</A>
<BR>
<P>
<B>4– 144 </B>Alpha Architecture Handbook <BR>
<B>4.11. 9 Trap Barrier <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>{TRAPB does not appear to issue until all prior instructions <BR>
are guaranteed to complete without causing any arithmetic traps}. <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>The TRAPB instruction allows software to guarantee that in a pipelined implementation, all <BR>
previous arithmetic instructions will complete without incurring any arithmetic traps before the <BR>
TRAPB or any instructions after it are issued. <BR>
<P>
If an arithmetic exception occurs for which trapping is enabled, the TRAPB instruction acts <BR>
like a fault. In this case, the value of the Program Counter reported to the program may be the <BR>
address of the TRAPB instruction (or earlier) but is never the address of the instruction follow-ing <BR>
the TRAPB. <BR>
<P>
This fault behavior by TRAPB allows software, using one TRAPB instruction for each excep-tion <BR>
domain, to isolate the address range in which an exception occurs. If the address of the <BR>
instruction following the TRAPB were allowed, there would be no way to distinguish an <BR>
exception in the address range preceding a label from an exception in the range that includes <BR>
the label along with the faulting instruction and a branch back to the label. This case arises <BR>
when the code is not following exception completion rules but is inserting TRAPB instruc-tions <BR>
to isolate exceptions to the proper scope. <BR>
<P>
Use of TRAPB should be compared with use of the EXCB instruction; <A href="#page194">see Section 4. 11.4. <BR>
</A>
<P>
TRAPB !Memory format <BR>
None <BR>
TRAPB Trap Barrier <BR>
None 
200
<BR>
<A href=#page200>200</A>
<strong><A name=page201> Page 201</A></strong>
<A href=#page202>202</A>
<BR>
<P>
Instruction Descriptions <B>4– 145 <BR>
4.11. 10 Write Hint <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>va </TT>¬ <TT>Rbv <BR>
IF { va maps to memory space } THEN <BR>
Write UNPREDICTABLE data to the aligned 64-byte region <BR>
containing the addressed byte. <BR>
END <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>The WH64 instruction provides a hint that the current contents of the aligned 64-byte block <BR>
containing the addressed byte will never be read again but will be overwritten in the near <BR>
future. <BR>
<P>
The processor may allocate cache resources to hold the block without reading its previous con-tents <BR>
from memory; the contents of the block may be set to any value that does not introduce a <BR>
security hole, as described <A href="#page23">in Section 1.6.3. <BR>
</A>
<P>
The WH64 instruction does not generate exceptions; if it encounters data address translation <BR>
errors (access violation, translation not valid, and so forth), it is treated as a NOP. <BR>
<P>
If the address maps to non-memory-like (I/ O) space, WH64 is treated as a NOP. <BR>
<P>
<B>Software Note: <BR>
</B>This instruction is a performance hint that should be used when writing a large continuous <BR>
region of memory. The intended code sequence consists of one WH64 instruction followed <BR>
by eight quadword stores for each aligned 64-byte region to be written. <BR>
<P>
Sometimes, the UNPREDICTABLE data will exactly match some or all of the previous <BR>
contents of the addressed block of memory. <BR>
<P>
WH64 (Rb. ab) ! Memory format <BR>
None <BR>
WH64 Write Hint -64 Bytes <BR>
None 
201
<BR>
<A href=#page201>201</A>
<strong><A name=page202> Page 202</A></strong>
<A href=#page203>203</A>
<BR>
<B>4– 146 </B>Alpha Architecture Handbook <BR>
<B>Implementation Note: <BR>
</B>If the 64-byte region containing the addressed byte is not in the data cache, <BR>
implementations are encouraged to allocate the region in the data cache without first <BR>
reading it from memory. However, if any of the addressed bytes exist in the caches of <BR>
other processors, they must be kept coherent with respect to those processors. <BR>
<P>
Processors with cache blocks smaller than 64 bytes are encouraged to implement WH64 as <BR>
defined. However, they may instead implement the instruction by allocating a smaller <BR>
aligned cache block for write access or by treating WH64 as a NOP. <BR>
<P>
Processors with cache blocks larger than 64 bytes are also encouraged to implement WH64 <BR>
as defined. However, they may instead treat WH64 as a NOP. 
202
<BR>
<A href=#page202>202</A>
<strong><A name=page203> Page 203</A></strong>
<A href=#page204>204</A>
<BR>
Instruction Descriptions <B>4– 147 <BR>
4.11. 11 Write Memory Barrier <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>{ Guarantee that <BR>
{ All preceding stores that access memory-like <BR>
{ regions are ordered before any subsequent stores <BR>
{ that access memory-like regions and <BR>
{ All preceding stores that access non-memory-like <BR>
{ regions are ordered before any subsequent stores <BR>
{ that access non-memory-like regions. <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>The WMB instruction provides a way for software to control write buffers. It guarantees that <BR>
writes preceding the WMB are not aggregated with writes that follow the WMB. <BR>
<P>
WMB guarantees that writes to memory-like regions that precede the WMB are ordered before <BR>
writes to memory-like regions that follow the WMB. Similarly, WMB guarantees that writes to <BR>
non-memory-like regions that precede the WMB are ordered before writes to non-mem-ory-<BR>
like regions that follow the WMB. It does not order writes to memory-like regions relative <BR>
to writes to non-memory-like regions. <BR>
<P>
WMB causes writes that are contained in buffers to be completed without unnecessary delay. It <BR>
is particularly suited for batching writes to high-performance I/ O devices. <BR>
<P>
WMB prevents writes that precede the WMB from being merged with writes that follow the <BR>
WMB. In particular, two writes that access the same location and are separated by a WMB <BR>
cause two distinct and ordered write events. <BR>
<P>
In the absence of a WMB (or IMB or MB) instruction, stores to memory-like or non-mem-ory-<BR>
like regions can be aggregated and/ or buffered and completed in any order. <BR>
<P>
WMB !Memory format <BR>
None <BR>
WMB Write Memory Barrier <BR>
None 
203
<BR>
<A href=#page203>203</A>
<strong><A name=page204> Page 204</A></strong>
<A href=#page205>205</A>
<BR>
<P>
<B>4– 148 </B>Alpha Architecture Handbook <BR>
The WMB instruction is the preferred method for providing high-bandwidth write streams <BR>
where order must be preserved between writes in that stream. <BR>
<P>
<B>Notes: <BR>
</B>WMB is useful for ordering streams of writes to a non-memory-like region, such as to mem-ory-<BR>
mapped control registers or to a graphics frame buffer. While both MB and WMB can <BR>
ensure that writes to a non-memory-like region occur in order, without being aggregated or <BR>
reordered, the WMB is usually faster and is never slower than MB. <BR>
<P>
WMB can correctly order streams of writes in programs that operate on shared sections of data <BR>
if the data in those sections are protected by a classic semaphore protocol. The following <BR>
example illustrates such a protocol: <BR>
<P>
The example above is similar to that in <A href="#page221">Section 5.5.4, </A>
except a WMB is substituted for the sec-ond <BR>
MB in the lock-update-release sequence. It is correct to substitute WMB for the second <BR>
MB only if: <BR>
<P>
1. All data locations that are read or written in the critical section are accessed only after <BR>
acquiring a software lock by using lock_ variable (and before releasing the software <BR>
lock). <BR>
<P>
2. For each read <I>u </I>of shared data in the critical section, there is a write <I>v </I>such that: <BR>
a. <I>v </I>is BEFORE the WMB <BR>
b. <I>v </I>follows <I>u </I>in processor issue sequence <A href="#page224">(see Section 5.6.1.1) <BR>
</A>
c. <I>v </I>either depends on <I>u <A href="#page227">(see Section 5.6. 1.7) </A>
or overlaps <I>u <A href="#page222">(see Section 5.6.1), </A>
or both. <BR>
<P>
3. Both lock_ variable and all the shared data are in memory-like regions (or lock_ variable and all the shared data are in non-memory-like regions). If the lock_ variable is in a <BR>
non-memory-like region, the atomic lock protocol must use some implementation-spe-cific hardware support. <BR>
<P>
The substitution of a WMB for the second MB is usually faster and never slower. <BR>
<P>
<B>Processor i Processor j <BR>
</B>&lt;Acquire lock&gt; <BR>
MB <BR>
&lt;Read and write data <BR>
in shared section&gt; <BR>
<P>
WMB <BR>
&lt;Release lock&gt; Þ &lt;Acquire lock&gt; <BR>
MB <BR>
&lt;Read and write data in shared section&gt; <BR>
WMB 
204
<BR>
<A href=#page204>204</A>
<strong><A name=page205> Page 205</A></strong>
<A href=#page206>206</A>
<BR>
<P>
Instruction Descriptions <B>4– 149 <BR>
4.12 VAX Compatibility Instructions <BR>
</B>Alpha provides the instructions shown in <A href="#page205">Table 4– 18 </A>
for use in translated VAX code. These <BR>
instructions are not a permanent part of the architecture and will not be available in some <BR>
future implementations. They are intended to preserve customer assumptions about VAX <BR>
instruction atomicity in porting code from VAX to Alpha. <BR>
<P>
These instructions should be generated only by the VAX-to-Alpha software translator; they <BR>
should never be used in native Alpha code. Any native code that uses them may cease to work. <BR>
<P>
<B>Table 4– 18: VAX Compatibility Instructions Summary <BR>
Mnemonic Operation <BR>
</B>RC Read and Clear <BR>
RS Read and Set 
205
<BR>
<A href=#page205>205</A>
<strong><A name=page206> Page 206</A></strong>
<A href=#page207>207</A>
<BR>
<B>4– 150 </B>Alpha Architecture Handbook <BR>
<B>4.12. 1 VAX Compatibility Instructions <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>Ra </TT>¬ <TT>intr_ flag <BR>
intr_ flag </TT>¬ <TT>0 !RC <BR>
intr_ flag </TT>¬ <TT>1 !RS <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>The intr_ flag is returned in Ra and then cleared to zero (RC) or set to one (RS). <BR>
<P>
These instructions may be used to determine whether the sequence of Alpha instructions <BR>
between RS and RC (corresponding to a single VAX instruction) was executed without inter-ruption <BR>
or exception. <BR>
<P>
Intr_ flag is a per-processor state bit. The intr_ flag is cleared if that processor encounters a <BR>
CALL_ PAL REI instruction. <BR>
<P>
It is UNPREDICTABLE whether a processor's intr_ flag is affected when that processor exe-cutes <BR>
an LDx_ L or STx_ C instruction. A processor's intr_ flag is not affected when that <BR>
processor executes a normal load or store instruction. <BR>
<P>
A processor's intr_ flag is not affected when that processor executes a taken branch. <BR>
<P>
<B>Notes: <BR>
° </B>These instructions are intended <I>only </I>for use by the VAX-to-Alpha software translator; they should never be used by native code. <BR>
<P>
Rx Ra. wq !Memory format <BR>
None <BR>
RC Read and Clear <BR>
RS Read and Set <BR>
<P>
None 
206
<BR>
<A href=#page206>206</A>
<strong><A name=page207> Page 207</A></strong>
<A href=#page208>208</A>
<BR>
Instruction Descriptions <B>4– 151 <BR>
4. 13 Multimedia (Graphics and Video) Support <BR>
</B>Alpha provides the following instructions that enhance support for graphics and video <BR>
algorithms: <BR>
<P>
The MIN and MAX instructions allow the clamping of pixel values to maximium values that <BR>
are allowed in different standards and stages of the CODECs. <BR>
<P>
The PERR instruction accelerates the macroblock search in motion estimation. <BR>
The pack and unpack (PKxB and UNPKBx) instructions accelerate the blocking of interleaved <BR>
YUV coordinates for processing by the CODEC. <BR>
<P>
<B>Implementation Note: <BR>
</B>Alpha processors for which the AMASK instruction returns bit 8 set implement these <BR>
instructions. Those processors for which AMASK does not return bit 8 set can take an <BR>
Illegal Instruction trap, and software can emulate their function, if required. <BR>
<P>
<B>Mnemonic Operation <BR>
</B>MINUB8 Vector Unsigned Byte Minimum <BR>
MINSB8 Vector Signed Byte Minimum <BR>
MINUW4 Vector Unsigned Word Minimum <BR>
MINSW4 Vector Signed Word Minimum <BR>
MAXUB8 Vector Unsigned Byte Maximum <BR>
MAXSB8 Vector Signed Byte Maximum <BR>
MAXUW4 Vector Unsigned Word Maximum <BR>
MAXSW4 Vector Signed Word Maximum <BR>
<P>
PERR Pixel Error <BR>
PKLB Pack Longwords to Bytes <BR>
PKWB Pack Words to Bytes <BR>
UNPKBL Unpack Bytes to Longwords <BR>
UNPKBW Unpack Bytes to Words 
207
<BR>
<A href=#page207>207</A>
<strong><A name=page208> Page 208</A></strong>
<A href=#page209>209</A>
<BR>
<B>4– 152 </B>Alpha Architecture Handbook <BR>
<B>4.13. 1 Byte and Word Minimum and Maximum <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>CASE <BR>
MINUB8: <BR>
FOR i FROM 0 TO 7 <BR>
Rcv&lt; i* 8+ 7: i* 8&gt; = MINU( Rav&lt; i* 8+ 7: i* 8&gt;, Rbv&lt; i* 8+ 7: i* 8&gt;) <BR>
END <BR>
MINSB8: <BR>
FOR i FROM 0 TO 7 <BR>
Rcv&lt; i* 8+ 7: i* 8&gt; = MINS( Rav&lt; i* 8+ 7: i* 8&gt;, Rbv&lt; i* 8+ 7: i* 8&gt;) <BR>
END <BR>
MINUW4: <BR>
FOR i FROM 0 TO 3 <BR>
Rcv&lt; i* 16+ 15: i* 16&gt; = MINU( Rav&lt; i* 16+ 15: i* 16&gt;, Rbv&lt; i* 16+ 15: i* 16&gt;) <BR>
END <BR>
MINSW4: <BR>
FOR i FROM 0 TO 3 <BR>
Rcv&lt; i* 16+ 15: i* 16&gt; = MINS( Rav&lt; i* 16+ 15: i* 16&gt;, Rbv&lt; i* 16+ 15: i* 16&gt;) <BR>
END <BR>
MAXUB8: <BR>
FOR i FROM 0 TO 7 <BR>
Rcv&lt; i* 8+ 7: i* 8&gt; = MAXU( Rav&lt; i* 8+ 7: i* 8&gt;, Rbv&lt; i* 8+ 7: i* 8&gt;) <BR>
END <BR>
MAXSB8: <BR>
FOR i FROM 0 TO 7 <BR>
Rcv&lt; i* 8+ 7: i* 8&gt; = MAXS( Rav&lt; i* 8+ 7: i* 8&gt;, Rbv&lt; i* 8+ 7: i* 8&gt;) <BR>
END <BR>
MAXUW4: <BR>
FOR i FROM 0 TO 3 <BR>
Rcv&lt; i* 16+ 15: i* 16&gt; = MAXU( Rav&lt; i* 16+ 15: i* 16&gt;, Rbv&lt; i* 16+ 15: i* 16&gt;) <BR>
END <BR>
MAXSW4: <BR>
FOR i FROM 0 TO 3 <BR>
Rcv&lt; i* 16+ 15: i* 16&gt; = MAXS( Rav&lt; i* 16+ 15: i* 16&gt;, Rbv&lt; i* 16+ 15: i* 16&gt;) <BR>
END <BR>
ENDCASE: <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
MINxxx Ra. rq, Rb. rq, Rc. wq <BR>
Ra. rq,# b. ib, Rc. wq ! Operate Format <BR>
<P>
MAXxxx Ra. rq, Rb. rq, Rc. wq <BR>
Ra. rq,# b. ib, Rc. wq ! Operate Format <BR>
<P>
None 
208
<BR>
<A href=#page208>208</A>
<strong><A name=page209> Page 209</A></strong>
<A href=#page210>210</A>
<BR>
Instruction Descriptions <B>4– 153 <BR>
Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>For MINxB8, each byte of Rc is written with the smaller of the corresponding bytes of Ra or <BR>
Rb. The bytes may be interpreted as signed or unsigned values. <BR>
<P>
For MINxW4, each word of Rc is written with the smaller of the corresponding words of Ra or <BR>
Rb. The words may be interpreted as signed or unsigned values. <BR>
<P>
For MAXxB8, each byte of Rc is written with the larger of the corresponding bytes of Ra or <BR>
Rb. The bytes may be interpreted as signed or unsigned values. <BR>
<P>
For MAXxW4, each word of Rc is written with the larger of the corresponding words of Ra or <BR>
Rb. The words may be interpreted as signed or unsigned values. <BR>
<P>
MINUB8 Vector Unsigned Byte Minimum <BR>
MINSB8 Vector Signed Byte Minimum <BR>
MINUW4 Vector Unsigned Word Minimum <BR>
MINSW4 Vector Signed Word Minimum <BR>
MAXUB8 Vector Unsigned Byte Maximum <BR>
MAXSB8 Vector Signed Byte Maximum <BR>
MAXUW4 Vector Unsigned Word Maximum <BR>
MAXSW4 Vector Signed Word Maximum <BR>
<P>
None 
209
<BR>
<A href=#page209>209</A>
<strong><A name=page210> Page 210</A></strong>
<A href=#page211>211</A>
<BR>
<B>4– 154 </B>Alpha Architecture Handbook <BR>
<B>4.13. 2 Pixel Error <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>temp = 0 <BR>
FOR i FROM 0 TO 7 <BR>
IF { Rav&lt; i* 8+ 7: i* 8&gt; GEU Rbv&lt; i* 8+ 7: i* 8&gt;} THEN <BR>
temp </TT>¬ <TT>temp + (Rav&lt; i* 8+ 7: i* 8&gt; -Rbv&lt; i* 8+ 7: i* 8&gt;) <BR>
ELSE <BR>
temp </TT>¬ <TT>temp + (Rbv&lt; i* 8+ 7: i* 8&gt; -Rav&lt; i* 8+ 7: i* 8&gt;) <BR>
END <BR>
Rc </TT>¬ <TT>temp <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Qualifiers: <BR>
Description: <BR>
</B>The absolute value of the difference between each of the bytes in Ra and Rb is calculated. The <BR>
sum of the resulting bytes is written to Rc. <BR>
<P>
PERR Ra. rq, Rb. rq, Rc. wq ! Operate Format <BR>
None <BR>
PERR Pixel Error <BR>
None 
210
<BR>
<A href=#page210>210</A>
<strong><A name=page211> Page 211</A></strong>
<A href=#page212>212</A>
<BR>
Instruction Descriptions <B>4– 155 <BR>
4. 13. 3 Pack Bytes <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>CASE <BR>
PKLB: <BR>
BEGIN <BR>
Rc&lt; 07: 00&gt; </TT>¬ <TT>Rbv&lt; 07: 00&gt; <BR>
Rc&lt; 15: 08&gt; </TT>¬ <TT>Rbv&lt; 39: 32&gt; <BR>
Rc&lt; 63: 16&gt; </TT>¬ <TT>0 <BR>
END <BR>
PKWB: <BR>
BEGIN <BR>
Rc&lt; 07: 00&gt; </TT>¬ <TT>Rbv&lt; 07: 00&gt; <BR>
Rc&lt; 15: 08&gt; </TT>¬ <TT>Rbv&lt; 23: 16&gt; <BR>
Rc&lt; 23: 16&gt; </TT>¬ <TT>Rbv&lt; 39: 32&gt; <BR>
Rc&lt; 31: 24&gt; </TT>¬ <TT>Rbv&lt; 55: 48&gt; <BR>
Rc&lt; 63: 32&gt; </TT>¬ <TT>0 <BR>
END <BR>
ENDCASE <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>For PKLB, the component longwords of Rb are truncated to bytes and written to the lower two <BR>
byte positions of Rc. The upper six bytes of Rc are written with zero. <BR>
<P>
For PKWB, the component words of Rb are truncated to bytes and written to the lower four <BR>
byte positions of Rc. The upper four bytes of Rc are written with zero. <BR>
<P>
PKxB Rb. rq, Rc. wq ! Operate Format <BR>
None <BR>
PKLB Pack Longwords to Bytes <BR>
PKWB Pack Words to Bytes <BR>
<P>
None 
211
<BR>
<A href=#page211>211</A>
<strong><A name=page212> Page 212</A></strong>
<A href=#page213>213</A>
<BR>
<B>4– 156 </B>Alpha Architecture Handbook <BR>
<B>4.13. 4 Unpack Bytes <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>temp = 0 <BR>
CASE <BR>
UNPKBL: <BR>
BEGIN <BR>
temp&lt; 07: 00&gt; = Rbv&lt; 07: 00&gt; <BR>
temp&lt; 39: 32&gt; = Rbv&lt; 15: 08&gt; <BR>
END <BR>
UNPKBW: <BR>
BEGIN <BR>
temp&lt; 07: 00&gt; = Rbv&lt; 07: 00&gt; <BR>
temp&lt; 23: 16&gt; = Rbv&lt; 15: 08&gt; <BR>
temp&lt; 39: 32&gt; = Rbv&lt; 23: 16&gt; <BR>
temp&lt; 55: 48&gt; = Rbv&lt; 31: 24&gt; <BR>
END <BR>
ENDCASE <BR>
Rc </TT>¬ <TT>temp <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
</B><P>
<B>Qualifiers: <BR>
Description: <BR>
</B>For UNPKBL, the lower two component bytes of Rb are zero-extended to longwords. The <BR>
resulting longwords are written to Rc. <BR>
<P>
For UNPKBW, the lower four component bytes of Rb are zero-extended to words. The result-ing <BR>
words are written to Rc. <BR>
<P>
UNPKBx Rb. rq, Rc. wq ! Operate Format <BR>
None <BR>
UNPKBL Unpack Bytes to Longwords <BR>
UNPKBW Unpack Bytes to Words <BR>
<P>
None 
212
<BR>
<A href=#page212>212</A>
<strong><A name=page213> Page 213</A></strong>
<A href=#page214>214</A>
<BR>
System Architecture and Programming Implications <B>5– 1 <BR>
Chapter 5 <BR>
System Architecture and Programming <BR>
Implications <BR>
</B><P>
<B>5. 1 Introduction <BR>
</B>Portions of the Alpha architecture have implications for programming, and the system struc-ture, <BR>
of both uniprocessor and multiprocessor implementations. Architectural implications <BR>
considered in the following sections are: <BR>
<P>
<B>° </B>Physical address space behavior <BR>
<B>° </B>Caches and write buffers <BR>
<B>° </B>Translation buffers and virtual caches <BR>
<B>° </B>Data sharing <BR>
<B>° </B>Read/ write ordering <BR>
<B>° </B>Arithmetic traps <BR>
To meet the requirements of the Alpha architecture, software and hardware implementors need <BR>
to take these issues into consideration. <BR>
<P>
<B>5.2 Physical Address Space Characteristics <BR>
</B>Alpha physical address space is divided into four equal-size regions. The regions are delin-eated <BR>
by the two most significant, implemented, physical address bits. Each region's <BR>
characteristics are distinguished by the coherency, granularity, and width of memory accesses, <BR>
and whether the region exhibits memory-like behavior or non-memory-like behavior. <BR>
<P>
<B>5.2. 1 Coherency of Memory Access <BR>
</B>Alpha implementations must provide a coherent view of memory, in which each write by a <BR>
processor or I/ O device (hereafter, called "processor") becomes visible to all other processors. <BR>
No distinction is made between coherency of "memory space" and "I/ O space." 
213
<BR>
<A href=#page213>213</A>
<strong><A name=page214> Page 214</A></strong>
<A href=#page215>215</A>
<BR>
<P>
<B>5– 2 </B>Alpha Architecture Handbook <BR>
Memory coherency may be provided in different ways for each of the four physical address <BR>
regions. <BR>
<P>
Possible per-region policies include, but are not restricted to: <BR>
<B>° </B>No caching <BR>
No copies are kept of data in a region; all reads and writes access the actual data <BR>
location (memory or I/ O register), but a processor may elide multiple accesses to the <BR>
same data (see <A href="#page215">Section 5.2.3). <BR>
</A>
<P>
<B>° </B>Write-through caching <BR>
Copies are kept of any data in the region; reads may use the copies, but writes update <BR>
the actual data location and either update or invalidate all copies. <BR>
<P>
<B>° </B>Write-back caching <BR>
Copies are kept of any data in the region; reads and writes may use the copies, and <BR>
writes use additional state to determine whether there are other copies to invalidate or <BR>
update. <BR>
<P>
<B>Software/ Hardware Note: <BR>
</B>To produce separate and distinct accesses to a specific location, the location must be a <BR>
region with no caching and a memory barrier instruction must be inserted between <BR>
accesses. See <A href="#page215">Section 5.2.3. <BR>
</A>
<P>
Part of the coherency policy implemented for a given physical address region may include <BR>
restrictions on excess data transfers (performing more accesses to a location than is necessary <BR>
to acquire or change the location's value) or may specify data transfer widths (the granularity <BR>
used to access a location). <BR>
<P>
Independent of coherency policy, a processor may use different hardware or different hard-ware <BR>
resource policies for caching or buffering different physical address regions. <BR>
<P>
<B>5.2. 2 Granularity of Memory Access <BR>
</B>For each region, an implementation must support aligned quadword access and may optionally <BR>
support aligned longword access or byte access. If byte access is supported in a region, aligned <BR>
word access and aligned longword access are also supported. <BR>
<P>
For a quadword access region, accesses to physical memory must be implemented such that <BR>
independent accesses to adjacent aligned quadwords produce the same results regardless of the <BR>
order of execution. Further, an access to an aligned quadword must be done in a single atomic <BR>
operation. <BR>
<P>
For a longword access region, accesses to physical memory must be implemented such that <BR>
independent accesses to adjacent aligned longwords produce the same results regardless of the <BR>
order of execution. Further, an access to an aligned longword must be done in a single atomic <BR>
operation, and an access to an aligned quadword must also be done in a single atomic <BR>
operation. 
214
<BR>
<A href=#page214>214</A>
<strong><A name=page215> Page 215</A></strong>
<A href=#page216>216</A>
<BR>
<P>
System Architecture and Programming Implications <B>5– 3 <BR>
</B>For a byte access region, accesses to physical memory must be implemented such that indepen-dent <BR>
accesses to adjacent bytes or adjacent aligned words produce the same results, regardless <BR>
of the order of execution. Further, an access to a byte, an aligned word, an aligned longword, <BR>
or an aligned quadword must be done in a single atomic operation. <BR>
<P>
In this context, "atomic" means that the following is true if different processors do simulta-neous <BR>
reads and writes of the same data: <BR>
<P>
<B>° </B>The result of any set of writes must be the same as if the writes had occurred sequen-tially in some order, and <BR>
<P>
<B>° </B>Any read that observes the effect of a write on some part of memory must observe the effect of that write (or of a later write or writes) on the entire part of memory that is <BR>
accessed by both the read and the write. <BR>
When a write accesses only part of a given word, longword, or quadword, a read of the entire <BR>
structure may observe the effect of that partial write without observing the effect of an earlier <BR>
write of another byte or bytes to the same structure. See <A href="#page226">Sections 5.6.1.5 </A>
<A href="#page226">and 5. 6.1.6. <BR>
</A>
<P>
<B>5.2. 3 Width of Memory Access <BR>
</B>Subject to the granularity, ordering, and coherency constraints given in Sections <A href="#page213">5. 2. 1, </A>
<A href="#page214">5. 2. 2, <BR>
</A>
and <A href="#page222">5.6, </A>
accesses to physical memory may be freely cached, buffered, and prefetched. <BR>
<P>
A processor may read more physical memory data (such as a full cache block) than is actually <BR>
accessed, writes may trigger reads, and writes may write back more data than is actually <BR>
updated. A processor may elide multiple reads and/ or writes to the same data. <BR>
<P>
<B>5.2. 4 Memory-Like and Non-Memory-Like Behavior <BR>
</B>Memory-like regions obey the following rules: <BR>
<B>° </B>Each page frame in the region either exists in its entirety or does not exist in its entirety; there are no holes within a page frame. <BR>
<P>
<B>° </B>All locations that exist are read/ write. <BR>
<B>° </B>A write to a location followed by a read from that location returns precisely the bits written; all bits act as memory. <BR>
<P>
<B>° </B>A write to one location does not change any other location. <BR>
<B>° </B>Reads have no side effects. <BR>
<B>° </B>Longword access granularity is provided, and if the byte/ word extension is imple-mented, byte access granularity is provided. <BR>
<P>
<B>° </B>Instruction-fetch is supported. <BR>
<B>° </B>Load-locked and store-conditional are supported. <BR>
Non-memory-like regions may have much more arbitrary behavior: <BR>
<B>° </B>Unimplemented locations or bits may exist anywhere. <BR>
<B>° </B>Some locations or bits may be read-only and others write-only. 
215
<BR>
<A href=#page215>215</A>
<strong><A name=page216> Page 216</A></strong>
<A href=#page217>217</A>
<BR>
<B>5– 4 </B>Alpha Architecture Handbook <BR>
<B>° </B>Address ranges may overlap, such that a write to one location changes the bits read from a different location. <BR>
<B>° </B>Reads may have side effects, although this is strongly discouraged. <BR>
<B>° </B>Longword granularity need not be supported and, even if the byte/ word extension is implemented, byte access granularity need not be implemented. <BR>
<P>
<B>° </B>Instruction-fetch need not be supported. <BR>
<B>° </B>Load-locked and store-conditional need not be supported. <BR>
<P>
<B>Hardware/ Software Coordination Note: <BR>
</B>The details of such behavior are outside the scope of the Alpha architecture. Specific <BR>
processor and I/ O device implementations may choose and document whatever behavior <BR>
they need. It is the responsibility of system designers to impose enough consistency to <BR>
allow processors successfully to access matching non-memory devices in a coherent way. <BR>
<P>
<B>5. 3 Translation Buffers and Virtual Caches <BR>
</B>A system may choose to include a virtual instruction cache (virtual I-cache) or a virtual data <BR>
cache (virtual D-cache). A system may also choose to include either a combined data and <BR>
instruction translation buffer (TB) or separate data and instruction TBs (DTB and ITB). The <BR>
contents of these caches and/ or translation buffers may become invalid, depending on what <BR>
operating system activity is being performed. <BR>
<P>
Whenever a non-software field of a valid page table entry (PTE) is modified, copies of that <BR>
PTE must be made coherent. PALcode mechanisms are available to clear all TBs, both DTB <BR>
and ITB entries for a given VA, either DTB or ITB entries for a given VA, or all entries with <BR>
the address space match (ASM) bit clear. Virtual D-cache entries are made coherent whenever <BR>
the corresponding DTB entry is requested to be cleared by any of the appropriate PALcode <BR>
mechanisms. Virtual I-cache entries can be made coherent via the IMB instruction. <BR>
<P>
If a processor implements address space numbers (ASNs), and the old PTE has the Address <BR>
Space Match (ASM) bit clear (ASNs in use) and the Valid bit set, then entries can also effec-tively <BR>
be made coherent by assigning a new, unused ASN to the currently running process and <BR>
not reusing the previous ASN before calling the appropriate PALcode routine to invalidate the <BR>
translation buffer (TB). <BR>
<P>
In a multiprocessor environment, making the TBs and/ or caches coherent on only one proces-sor <BR>
is not always sufficient. An operating system must arrange to perform the above actions on <BR>
each processor that could possibly have copies of the PTE or data for any affected page. <BR>
<P>
<B>5. 4 Caches and Write Buffers <BR>
</B>A hardware implementation may include mechanisms to reduce memory access time by mak-ing <BR>
local copies of recently used memory contents (or those expected to be used) or by <BR>
buffering writes to complete at a later time. Caches and write buffers are examples of these <BR>
mechanisms. They must be implemented so that their existence is transparent to software <BR>
(except for timing, error reporting/ control/ recovery, and modification to the I-stream). 
216
<BR>
<A href=#page216>216</A>
<strong><A name=page217> Page 217</A></strong>
<A href=#page218>218</A>
<BR>
<P>
System Architecture and Programming Implications <B>5– 5 <BR>
</B>The following requirements must be met by all cache/ write-buffer implementations. All pro-cessors <BR>
must provide a coherent view of memory. <BR>
<P>
<B>° </B>Write buffers may be used to delay and aggregate writes. From the viewpoint of another processor, buffered writes appear not to have happened yet. (Write buffers must not <BR>
<P>
delay writes indefinitely. <A href="#page229">See Section 5.6.1.9.) <BR>
</A>
<B>° </B>Write-back caches must be able to detect a later write from another processor and inval-idate or update the cache contents. <BR>
<P>
<B>° </B>A processor must guarantee that a data store to a location followed by a data load from the same location reads the updated value. <BR>
<B>° </B>Cache prefetching is allowed, but virtual caches must not prefetch from invalid pages. See Sections <A href="#page224">5.6.1. 3, </A>
<A href="#page234">5.6.4.3, </A>
<A href="#page235">and 5.6.4.4. <BR>
</A>
<B>° </B>A processor must guarantee that all of its previous writes are visible to all other proces-sors before a HALT instruction completes. A processor must guarantee that its caches <BR>
are coherent with the rest of the system before continuing from a HALT. <BR>
<B>° </B>If battery backup is supplied, a processor must guarantee that the memory system remains coherent across a powerfail/ recovery sequence. Data that was written by the <BR>
<P>
processor before the powerfail may not be lost, and any caches must be in a valid state <BR>
before (and if) normal instruction processing is continued after power is restored. <BR>
<P>
<B>° </B>Virtual instruction caches are not required to notice modifications of the virtual I-stream (they need not be coherent with the rest of memory). Software that creates or <BR>
<P>
modifies the instruction stream must execute a CALL_ PAL IMB before trying to exe-cute <BR>
the new instructions. <BR>
<P>
In this context, to "modify the virtual I-stream" means either: <BR>
– any Store to the same physical address that is subsequently fetched as an instruction <BR>
by some corresponding (virtual address, ASN) pair, or <BR>
<P>
– any change to the virtual-to-physical address mapping so that different values are <BR>
fetched. <BR>
<P>
For example, if two different virtual addresses, VA1 and VA2, map to the same page <BR>
frame, a store to VA1 modifies the virtual I-stream fetched by VA2. <BR>
<P>
However, the following sequence does not modify the virtual I-stream (this might <BR>
happen in soft page faults). <BR>
<P>
1. Change the mapping of an I-stream page from valid to invalid. <BR>
2. Copy the corresponding page frame to a new page frame. <BR>
3. Change the original mapping to be valid and point to the new page frame. <BR>
<B>° </B>Physical instruction caches are not required to notice modifications of the physical I-stream (they need not be coherent with the rest of memory), except for certain paging <BR>
<P>
activity. (See <A href="#page235">Section 5.6.4.4.) </A>
Software that creates or modifies the instruction stream <BR>
must execute a CALL_ PAL IMB before trying to execute the new instructions. <BR>
<P>
In this context, to "modify the physical I-stream" means any Store to the same physical <BR>
address that is subsequently fetched as an instruction. 
217
<BR>
<A href=#page217>217</A>
<strong><A name=page218> Page 218</A></strong>
<A href=#page219>219</A>
<BR>
<P>
<B>5– 6 </B>Alpha Architecture Handbook <BR>
<B>5.5 Data Sharing <BR>
</B>In a multiprocessor environment, writes to shared data must be synchronized by the <BR>
programmer. <BR>
<P>
<B>5.5. 1 Atomic Change of a Single Datum <BR>
</B>The ordinary STL and STQ instructions can be used to perform an atomic change of a shared <BR>
aligned longword or quadword. (" Change" means that the new value is not a function of the old <BR>
value.) In particular, an ordinary STL or STQ instruction can be used to change a variable that <BR>
could be simultaneously accessed via an LDx_ L/ STx_ C sequence. <BR>
<P>
<B>5.5. 2 Atomic Update of a Single Datum <BR>
</B>The load-locked/ store-conditional instructions may be used to perform an atomic update of a <BR>
shared aligned longword or quadword. (" Update" means that the new value is a function of the <BR>
old value.) <BR>
<P>
The following sequence performs a read-modify-write operation on location <I>x. </I>Only regis-ter-<BR>
to-register operate instructions and branch fall-throughs may occur in the sequence: <BR>
<P>
<TT>try_ again: <BR>
LDQ_ L R1, x <BR>
&lt;modify R1&gt; <BR>
STQ_ C R1, x <BR>
BEQ R1, no_ store <BR>
: <BR>
no_ store: <BR>
&lt;code to check for excessive iterations&gt; <BR>
BR try_ again <BR>
</TT><P>
If this sequence runs with no exceptions or interrupts, and no other processor writes to loca-tion <BR>
<I>x </I>(more precisely, the locked range including <I>x) </I>between the LDQ_ L and STQ_ C <BR>
instructions, then the STQ_ C shown in the example stores the modified value in <I>x </I>and sets R1 <BR>
to 1. If, however, the sequence encounters exceptions or interrupts that eventually continue the <BR>
sequence, or another processor writes to <I>x, </I>then the STQ_ C does not store and sets R1 to 0. In <BR>
this case, the sequence is repeated by the branches to no_ store and try_ again. This repetition <BR>
continues until the reasons for exceptions or interrupts are removed and no interfering store is <BR>
encountered. <BR>
<P>
To be useful, the sequence must be constructed so that it can be replayed an arbitrary number <BR>
of times, giving the same result values each time. A sufficient (but not necessary) condition is <BR>
that, within the sequence, the set of operand destinations and the set of operand sources are <BR>
disjoint. <BR>
<P>
<B>Note: <BR>
</B>A sufficiently long instruction sequence between LDx_ L and STx_ C will never complete, <BR>
because periodic timer interrupts will always occur before the sequence completes. The <BR>
rules in <A href="#page290">Section A. 5 </A>
describe sequences that will eventually complete in <I>all </I>Alpha <BR>
implementations. 
218
<BR>
<A href=#page218>218</A>
<strong><A name=page219> Page 219</A></strong>
<A href=#page220>220</A>
<BR>
System Architecture and Programming Implications <B>5– 7 <BR>
</B>This load-locked/ store-conditional paradigm may be used whenever an atomic update of a <BR>
shared aligned quadword is desired, including getting the effect of atomic byte writes. <BR>
<P>
<B>5.5. 3 Atomic Update of Data Structures <BR>
</B>Before accessing shared writable data structures (those that are not a single aligned longword <BR>
or quadword), the programmer can acquire control of the data structure by using an atomic <BR>
update to set a software lock variable. Such a software lock can be cleared with an ordinary <BR>
store instruction. <BR>
<P>
A software-critical section, therefore, may look like the sequence: <BR>
<TT>stq_ c_ loop: <BR>
spin_ loop: <BR>
LDQ R1, lock_ variable ; This optional spin-loop code <BR>
BLBS R1, already_ set ; should be used unless the <BR>
; lock is known to be low-contention. <BR>
LDQ_ L R1, lock_ variable ; \ <BR>
BLBS R1, already_ set ; \ <BR>
OR R1,# 1, R2 ; &gt; Set lock bit <BR>
STQ_ C R2, lock_ variable ; / <BR>
BEQ R2, stq_ c_ fail ; / <BR>
</TT><P>
<TT>MB <BR>
&lt;critical section: updates various data structures&gt; <BR>
MB ; Second MB <BR>
STQ R31, lock_ variable ; Clear lock bit <BR>
: <BR>
: <BR>
already_ set: <BR>
&lt;code to block or reschedule or test for too many iterations&gt; <BR>
BR spin_ loop <BR>
stq_ c_ fail: <BR>
&lt;code to test for too many iterations&gt; <BR>
BR stq_ c_ loop <BR>
</TT><P>
This code has a number of subtleties: <BR>
<B>° </B>If the lock_ variable is already set, the spin loop is done without doing any stores. This avoidance of stores improves memory subsystem performance and avoids the deadlock <BR>
<P>
described below. The loop uses an ordinary load. This code sequence is preferred unless <BR>
the lock is known to be low-contention, because the sequence increases the probability <BR>
that the LDQ_ L hits in the cache and the LDQ_ L/ STQ_ C sequence complete quickly <BR>
and successfully. <BR>
<P>
<B>° </B>If the lock_ variable is actually being changed from 0 to 1, and the STQ_ C fails (due to an interrupt, or because another processor simultaneously changed lock_ variable), the <BR>
<P>
entire process starts over by reading the lock_ variable again. <BR>
<B>° </B>Only the fall-through path of the BLBS instructions does a STx_ C; some implementa-tions may not allow a successful STx_ C after a branch-taken. <BR>
<P>
<B>° </B>Only register-to-register operate instructions are used to do the modify. 
219
<BR>
<A href=#page219>219</A>
<strong><A name=page220> Page 220</A></strong>
<A href=#page221>221</A>
<BR>
<P>
<B>5– 8 </B>Alpha Architecture Handbook <BR>
<B>° </B>Both conditional branches are forward branches, so they are properly predicted not to be taken (to match the common case of no contention for the lock). <BR>
<B>° </B>The OR writes its result to a second register; this allows the OR and the BLBS to be interchanged if that would give a faster instruction schedule. <BR>
<B>° </B>Other operate instructions (from the critical section) may be scheduled into the LDQ_ L.. STQ_ C sequence, so long as they do not fault or trap and they give correct <BR>
results if repeated; other memory or operate instructions may be scheduled between the <BR>
STQ_ C and BEQ. <BR>
<P>
<B>° </B>The memory barrier instructions are discussed in <A href="#page221">Section 5. 5.4. </A>
It is correct to substitute WMB for the second MB only if: <BR>
<P>
– All data locations that are read or written in the critical section are accessed only <BR>
after acquiring a software lock by using lock_ variable (and before releasing the <BR>
software lock). <BR>
<P>
– For each read <I>u </I>of shared data in the critical section, there is a write <I>v </I>such that: <BR>
1. <I>v </I>is BEFORE the WMB <BR>
2. <I>v </I>follows <I>u </I>in processor issue sequence <A href="#page224">(see Section 5.6.1.1) <BR>
</A>
3. <I>v </I>either depends on <I>u </I>(see <A href="#page227">Section 5.6.1.7) </A>
or overlaps <I>u </I>(see <A href="#page222">Section 5.6. 1), </A>
or both. <BR>
<P>
– Both lock_ variable and all the shared data are in memory-like regions (or <BR>
lock_ variable and all the shared data are in non-memory-like regions). If the <BR>
lock_ variable is in a non-memory-like region, the atomic lock protocol must use <BR>
some implementation-specific hardware support. <BR>
<P>
Generally, the substitution of a WMB for the second MB increases performance. <BR>
<B>° </B>An ordinary STQ instruction is used to clear the lock_ variable. <BR>
It would be a performance mistake to spin-wait by repeating the full LDQ_ L.. STQ_ C sequence <BR>
(to move the BLBS after the BEQ) because that sequence may repeatedly change the software <BR>
lock_ variable from "locked" to "locked," with each write causing extra access delays in all <BR>
other caches that contain the lock_ variable. In the extreme, spin-waits that contain writes may <BR>
deadlock as follows: <BR>
<P>
If, when one processor spins with writes, another processor is modifying (not changing) <BR>
the lock_ variable, then the writes on the first processor may cause the STx_ C of the <BR>
modify on the second processor always to fail. <BR>
<P>
This deadlock situation is avoided by: <BR>
<B>° </B>Having only one processor execute a store (no STx_ C), or <BR>
<B>° </B>Having no write in the spin loop, or <BR>
<B>° </B>Doing a write <I>only </I>if the shared variable actually changes state (1 ® 1 does not change state). 
220
<BR>
<A href=#page220>220</A>
<strong><A name=page221> Page 221</A></strong>
<A href=#page222>222</A>
<BR>
<P>
System Architecture and Programming Implications <B>5– 9 <BR>
5.5. 4 Ordering Considerations for Shared Data Structures <BR>
</B>A critical section sequence, such as shown <A href="#page219">in Section 5.5.3, </A>
is conceptually only three steps: <BR>
1. Acquire software lock <BR>
2. Critical section — read/ write shared data <BR>
3. Clear software lock <BR>
In the absence of explicit instructions to the contrary, the Alpha architecture allows reads and <BR>
writes to be reordered. While this may allow more implementation speed and overlap, it can <BR>
also create undesired side effects on shared data structures. Normally, the critical section just <BR>
described would have two instructions added to it: <BR>
<P>
<TT>&lt;acquire software lock&gt; <BR>
MB (memory barrier #1) <BR>
&lt;critical section </TT>– <TT>read/ write shared data&gt; <BR>
MB (memory barrier #2) <BR>
&lt;clear software lock&gt; <BR>
&lt;endcode_ example&gt; <BR>
</TT><P>
The first memory barrier prevents any reads (from within the critical section) from being <BR>
prefetched before the software lock is acquired; such prefetched reads would potentially con-tain <BR>
stale data. <BR>
<P>
The second memory barrier prevents any writes and reads in the critical section being delayed <BR>
past the clearing of the software lock. Such delayed accesses could interact with the next user <BR>
of the shared data, defeating the purpose of the software lock entirely. It is correct to substitute <BR>
WMB for the second MB only if: <BR>
<P>
1. All data locations that are read or written in the critical section are accessed only after <BR>
acquiring a software lock by using lock_ variable (and before releasing the software <BR>
lock). <BR>
<P>
2. For each read <I>u </I>of shared data in the critical section, there is a write <I>v </I>such that: <BR>
a. <I>v </I>is BEFORE the WMB <BR>
b. <I>v </I>follows <I>u </I>in processor issue sequence <A href="#page224">(see Section 5.6. 1.1) <BR>
</A>
c. <I>v </I>either depends on <I>u <A href="#page227">(see Section 5.6.1.7) </A>
or overlaps <I>u <A href="#page222">(see Section 5.6.1), </A>
or both. <BR>
3. Both lock_ variable and all the shared data are in memory-like regions (or lock_ variable and all the shared data are in non-memory-like regions). If the lock_ variable is in a <BR>
<P>
non-memory-like region, the atomic lock protocol must use some implementation-spe-cific hardware support. <BR>
<P>
Generally, the substitution of a WMB for the second MB increases performance. <BR>
<B>Software Note: <BR>
</B>In the VAX architecture, many instructions provide noninterruptable read-modify-write <BR>
sequences to memory variables. Most programmers never regard data sharing as an issue. <BR>
<P>
In the Alpha architecture, programmers must pay more attention to synchronizing access to <BR>
shared data; for example, to AST routines. In the VAX architecture, a programmer can use 
221
<BR>
<A href=#page221>221</A>
<strong><A name=page222> Page 222</A></strong>
<A href=#page223>223</A>
<BR>
<B>5– 10 </B>Alpha Architecture Handbook <BR>
an ADDL2 to update a variable that is shared between a "MAIN" routine and an AST <BR>
routine, if running on a single processor. In the Alpha architecture, a programmer must <BR>
deal with AST shared data by using multiprocessor shared data sequences. <BR>
<P>
<B>5.6 Read/ Write Ordering <BR>
</B>This section applies to programs that run on multiple processors or on one or more processors <BR>
that are interacting with DMA I/ O devices. To a program running on a single processor and not <BR>
interacting with DMA I/ O devices, all memory accesses appear to happen in the order speci-fied <BR>
by the programmer. This section deals with predictable read/ write ordering across multiple <BR>
processors and/ or DMA I/ O devices. <BR>
<P>
The order of reads and writes done in an Alpha implementation may differ from that specified <BR>
by the programmer. <BR>
<P>
For any two memory accesses A and B, either A must occur before B in all Alpha implementa-tions, <BR>
B must occur before A, or they are UNORDERED. In the last case, software cannot <BR>
depend upon one occurring first: the order may vary from implementation to implementation, <BR>
and even from run to run or moment to moment on a single implementation. <BR>
<P>
If two accesses cannot be shown to be ordered by the rules given, they are UNORDERED and <BR>
implementations are free to do them in any order that is convenient. Implementations may take <BR>
advantage of this freedom to deliver substantially higher performance. <BR>
<P>
The discussion that follows first defines the architectural issue sequence of memory accesses <BR>
on a single processor, then defines the (partial) ordering on this issue sequence that <I>all </I>Alpha <BR>
implementations are required to maintain. <BR>
<P>
The individual issue sequences on multiple processors are merged into access sequences at <BR>
each shared memory location. The discussion defines the (partial) ordering on the individual <BR>
access sequences that <I>all </I>Alpha implementations are required to maintain. <BR>
<P>
The net result is that for any code that executes on multiple processors, one can determine <BR>
which memory accesses are required to occur before others on <I>all </I>Alpha implementations and <BR>
hence can write useful shared-variable software. <BR>
<P>
Software writers can force one access to occur before another by inserting a memory barrier <BR>
instruction (MB, WMB, or CALL_ PAL IMB) between the accesses. <BR>
<P>
<B>5.6. 1 Alpha Shared Memory Model <BR>
</B>An Alpha system consists of a collection of processors, I/ O devices (and possibly a bridge to <BR>
connect remote I/ O devices), and shared memories that are accessible by all processors. <BR>
<P>
<B>Note: <BR>
</B>An example of an unshared location is a physical address in I/ O space that refers to a CSR <BR>
that is local to a processor and not accessible by other processors. <BR>
<P>
A processor is an Alpha CPU. 
222
<BR>
<A href=#page222>222</A>
<strong><A name=page223> Page 223</A></strong>
<A href=#page224>224</A>
<BR>
<P>
System Architecture and Programming Implications <B>5– 11 <BR>
</B>In most systems, DMA I/ O devices or other agents can read or write shared memory locations. <BR>
The order of accesses by those agents is not completely specified in this document. It is possi-ble <BR>
in some systems for read accesses by I/ O devices or other agents to give results indicating <BR>
some reordering of accesses. However, there are guarantees that apply in all systems. See <A href="#page239">Sec-tion <BR>
</A>
<A href="#page239">5.6.4.7. <BR>
</A>
<P>
A shared memory is the primary storage place for one or more locations. <BR>
A location is a byte, specified by its physical address. Multiple virtual addresses may map to <BR>
the same physical address. Ordering considerations are based only on the physical address. <BR>
This definition of location specifically includes locations and registers in memory mapped I/ O <BR>
devices and bridges to remote I/ O (for example, Mailbox Pointer Registers, or MBPRs). <BR>
<P>
<B>Implementation Note: <BR>
</B>An implementation may allow a location to have multiple physical addresses, but the rules <BR>
for accesses via mixtures of the addresses are implementation-specific and outside the <BR>
scope of this section. Accesses via exactly one of the physical addresses follow the rules <BR>
described next. <BR>
<P>
Each processor may generate accesses to shared memory locations. There are six types of <BR>
accesses: <BR>
<P>
1. Instruction fetch by processor <I>i </I>to location <I>x, </I>returning value <I>a, </I>denoted Pi: I&lt; 4&gt;( x, a). <BR>
2. Data read (including load-locked) by processor <I>i </I>to location <I>x, </I>returning value <I>a, </I>denoted Pi: R&lt; size&gt;( x, a). <BR>
<P>
3. Data write (including successful store-conditional) by processor <I>i </I>to location <I>x, </I>storing value <I>a, </I>denoted Pi: W&lt; size&gt;( x, a). <BR>
4. Memory barrier issued by processor <I>i, </I>denoted Pi: MB. <BR>
5. Write memory barrier issued by processor <I>i, </I>denoted Pi: WMB. <BR>
6. I-stream memory barrier issued by processor <I>i, </I>denoted Pi: IMB. <BR>
The first access type is also called an I-stream access or I-fetch. The next two are also called <BR>
D-stream accesses. The first three types are collectively called read/ write accesses, denoted <BR>
Pi: Op&lt; m&gt;( x, a), where <I>m </I>is the size of the access in bytes, <I>x </I>is the (physical) address of the <BR>
access, and <I>a </I>is a value representable in <I>m </I>bytes; for any <I>k </I>in the range 0.. m– 1, byte <I>k </I>of value <BR>
<I>a </I>(where byte 0 is the low-order byte) is the value written to or read from location x+ k by the <BR>
access. This relationship reflects little-endian addressing; big-endian addressing representation <BR>
is as described in Chapter 2. <BR>
<P>
The last three types collectively are called barriers or memory barriers. <BR>
The size of a read/ write access is 8 for a quadword access, 4 for a longword access (including <BR>
all instruction fetches), 2 for a word access, or 1 for a byte access. All read/ write accesses in <BR>
this chapter are naturally aligned. That is, they have the form Pi: Op&lt; m&gt;( x, a), where the <BR>
address <I>x </I>is divisible by size <I>m. <BR>
</I><P>
The word "access" is also used as a verb; a read/ write access Pi: Op&lt; m&gt;( x, a) accesses byte <I>z </I>if <BR>
x £ z &lt; x+ m. Two read/ write accesses Op1&lt; m&gt;( x, a) and Op2&lt; n&gt;( y, b) are defined to overlap if 
223
<BR>
<A href=#page223>223</A>
<strong><A name=page224> Page 224</A></strong>
<A href=#page225>225</A>
<BR>
<P>
<B>5– 12 </B>Alpha Architecture Handbook <BR>
there is at least one byte that is accessed by both, that is, if max( x, y) &lt; min( x+ m, y+ n). <BR>
<B>5.6.1.1 Architectural Definition of Processor Issue Sequence <BR>
</B>The issue sequence for a processor is architecturally defined with respect to a hypothetical sim-ple <BR>
implementation that contains one processor and a single shared memory, with no caches or <BR>
buffers. This is the instruction execution model: <BR>
<P>
1. I-fetch: An Alpha instruction is fetched from memory. <BR>
2. Read/ Write: That instruction is executed and runs to completion, including a single data read from memory for a Load instruction or a single data write to memory for a Store <BR>
<P>
instruction. <BR>
3. Update: The PC for the processor is updated. <BR>
4. Loop: Repeat the above sequence indefinitely. <BR>
If the instruction fetch step gets a memory management fault, the I-fetch is not done and the <BR>
PC is updated to point to a PALcode fault handler. If the read/ write step gets a memory man-agement <BR>
fault, the read/ write is not done and the PC is updated to point to a PALcode fault <BR>
handler. <BR>
<P>
<B>5.6.1.2 Definition of Before and After <BR>
</B>The ordering relation BEFORE (Ü ) is a partial order on memory accesses. It is further defined <BR>
in Sections <A href="#page224">5.6.1.3 </A>
<A href="#page229">through 5.6.1.9. <BR>
</A>
<P>
The ordering relation BEFORE (Ü ), being a partial order, is acyclic. <BR>
The BEFORE order cannot be observed directly, nor fully predicted before an actual execu-tion, <BR>
nor reproduced exactly from one execution to another. Nonetheless, some useful ordering <BR>
properties must hold in all Alpha implementations. <BR>
<P>
If u Ü v, then <I>v </I>is said to be AFTER <I>u. <BR>
</I><B>5.6.1.3 Definition of Processor Issue Constraints <BR>
</B>Processor issue constraints are imposed on the processor issue sequence defined in <A href="#page224">Section <BR>
</A>
<A href="#page224">5.6.1.1, </A>
as shown in <A href="#page225">Table 5– 1: 
224
<BR>
<A href=#page224>224</A>
<strong><A name=page225> Page 225</A></strong>
<A href=#page226>226</A>
<BR>
<P>
</A>
System Architecture and Programming Implications <B>5– 13 <BR>
</B>Where "overlap" denotes the condition max( x, y) &lt; min( x+ m, y+ n). <BR>
For two accesses <I>u </I>and <I>v </I>issued by processor Pi, if <I>u </I>precedes <I>v </I>by processor issue constraint, <BR>
then <I>u </I>precedes <I>v </I>in BEFORE order. <I>u </I>and <I>v </I>on Pi are ordered by processor issue constraint if <BR>
any of the following applies: <BR>
<P>
1. The entry in <A href="#page225">Table 5– 1 </A>
indicated by the access type of <I>u </I>(1st) and <I>v </I>(2nd) indicates the <BR>
accesses are ordered. <BR>
<P>
2. <I>u </I>and <I>v </I>are both writes to memory-like regions and there is a WMB between <I>u </I>and <I>v </I>in processor issue sequence. <BR>
<P>
3. <I>u </I>and <I>v </I>are both writes to non-memory-like regions and there is a WMB between <I>u </I>and <I>v </I>in processor issue sequence. <BR>
4. <I>u </I>is a TB fill that updates a PTE, for example, a PTE read in order to satisfy a TB miss, and <I>v </I>is an I-or D-stream access using that PTE (see <A href="#page234">Sections 5.6.4.3 </A>
<A href="#page235">and 5.6.4. </A>
4). <BR>
In <A href="#page225">Table 5– 1, </A>
<I>1st </I>and <I>2nd </I>refer to the ordering of accesses in the processor issue sequence. <BR>
Note that <A href="#page225">Table 5– 1 </A>
imposes no direct constraint on the ordering relationship between non-overlapping <BR>
read/ write accesses, though there may be indirect constraints due to the transitivity <BR>
of BEFORE (Ü ). Conditions 2 through 4, above, impose ordering constraints on some pairs of <BR>
nonoverlapping read/ write accesses. <BR>
<P>
<A href="#page225">Table 5– 1 </A>
permits a read access Pi: R&lt; n&gt;( y, b) to be ordered BEFORE an overlapping write <BR>
access Pi: W&lt; m&gt;( x, a) that precedes the read access in processor issue order. This asymmetry <BR>
for reads allows reads to be satisfied by using data from an earlier write in processor issue <BR>
sequence by the same processor (for example, by hitting in a write buffer) before the write <BR>
completes. The write access remains "visible" to the read access; "visibility" is described in <BR>
Sections <A href="#page226">5.6.1.5 </A>
and <A href="#page226">5.6. 1.6 </A>
and illustrated in Litmus Test 11 <A href="#page233">in Section 5.6. 2.11. <BR>
</A>
<P>
An I-fetch Pi: I&lt; 4&gt;( y, b) may also be ordered BEFORE an overlapping write Pi: W&lt; m&gt;( x, a) that <BR>
precedes it in processor issue sequence. In that case, the write may, but need not, be visible to <BR>
the I-fetch. This asymmetry in <A href="#page225">Table 5– 1 </A>
allows writes to the I-stream to be incoherent until a <BR>
CALL_ PAL IMB is executed. <BR>
<P>
Implementations are free to perform memory accesses from a single processor in any sequence <BR>
that is consistent with processor issue constraints. <BR>
<P>
<B>Table 5– 1: Processor Issue Constraints <BR>
1st¯ 2nd </B>® <B>Pi: I&lt; n= 4&gt;( y, b) Pi: R&lt; n&gt;( y, b) Pi: W&lt; n&gt;( y, b) Pi: MB Pi: IMB <BR>
</B>Pi: I&lt; m= 4&gt;( x, a) Ü if overlap Ü if overlap Ü Ü <BR>
Pi: R&lt; m&gt;( x, a) Ü if overlap Ü if overlap Ü Ü <BR>
Pi: W&lt; m&gt;( x, a) Ü if overlap Ü Ü <BR>
Pi: MB Ü ÜÜÜ <BR>
Pi: IMB Ü ÜÜ ÜÜ 
225
<BR>
<A href=#page225>225</A>
<strong><A name=page226> Page 226</A></strong>
<A href=#page227>227</A>
<BR>
<B>5– 14 </B>Alpha Architecture Handbook <BR>
<B>5.6.1.4 Definition of Location Access Constraints <BR>
</B>Location access constraints are imposed on overlapping read/ write accesses. If <I>u </I>and <I>v </I>are <BR>
overlapping read/ write accesses, at least one of which is a write, then <I>u </I>and <I>v </I>must be compara-ble <BR>
in the BEFORE (Ü ) ordering, that is, either u Ü v or v Ü u. <BR>
<P>
There is no direct requirement that nonoverlapping accesses be comparable in the BEFORE <BR>
(Ü ) ordering. <BR>
<P>
All writes accessing any given byte are totally ordered, and any read or I-fetch accessing a <BR>
given byte is ordered with respect to all writes accessing that byte. <BR>
<P>
<B>5.6.1.5 Definition of Visibility <BR>
</B>If <I>u </I>is a write access Pi: W&lt; m&gt;( x, a) and <I>v </I>is an overlapping read access Pj: R&lt; n&gt;( y, b), <I>u </I>is visi-ble <BR>
to <I>v </I>only if: <BR>
<P>
<I>u </I>Ü <I>v, </I>or <BR>
<I>u </I>precedes <I>v </I>in processor issue sequence (possible only if Pi= Pj). <BR>
If <I>u </I>is a write access Pi: W&lt; m&gt;( x, a) and <I>v </I>is an overlapping instruction fetch Pj: I&lt; 4&gt;( y, b), <BR>
there are the following rules for visibility: <BR>
<P>
1. If <I>u </I>Ü <I>v, </I>then <I>u </I>is visible to <I>v. <BR>
</I>2. If <I>u </I>precedes <I>v </I>in processor issue sequence, then: <BR>
a. If there is a write <I>w </I>such that: <BR>
<I>u </I>overlaps <I>w </I>and precedes <I>w </I>in processor issue sequence, and <BR>
<I>w </I>is visible to <I>v, <BR>
</I><P>
then <I>u </I>is visible to <I>v. <BR>
</I>b. If there is an instruction fetch <I>w </I>such that: <BR>
<I>u </I>is visible to <I>w, </I>and <BR>
<I>w </I>overlaps <I>v </I>and precedes <I>v </I>in processor issue sequence, <BR>
<P>
then <I>u </I>is visible to <I>v. <BR>
</I>3. If <I>u </I>does not precede <I>v </I>in either processor issue sequence or BEFORE order, then <I>u </I>is not visible to <I>v. <BR>
</I><P>
Note that the rules of visibility for reads and instruction fetches are slightly different. If a write <BR>
<I>u </I>precedes an overlapping instruction fetch <I>v </I>in processor issue sequence, but <I>u </I>is not <BR>
BEFORE <I>v, </I>then <I>u </I>may or may not be visible to <I>v. <BR>
</I><P>
<B>5.6.1.6 Definition of Storage <BR>
</B>The property of storage applies only to memory-like regions. <BR>
<P>
The value read from any byte by a read access or instruction fetch <I>v, </I>is the value written by the <BR>
latest (in BEFORE order) write <I>u </I>to that byte that is visible to <I>v. </I>More formally: <BR>
<P>
If <I>u </I>is Pi: W&lt; m&gt;( x, a), and <I>v </I>is either Pj: I&lt; 4&gt;( y, b) or Pj: R&lt; n&gt;( y, b), and z is a byte accessed <BR>
by both <I>u </I>and <I>v, </I>and <I>u </I>is visible to <I>v; </I>and there is no write that is AFTER <I>u, </I>is visible to <I>v, </I>
226
<BR>
<A href=#page226>226</A>
<strong><A name=page227> Page 227</A></strong>
<A href=#page228>228</A>
<BR>
<P>
System Architecture and Programming Implications <B>5– 15 <BR>
</B>and accesses byte z; then the value of byte z read by <I>v </I>is exactly the value written by <I>u. </I>In <BR>
this situation, <I>u </I>is a source of <I>v. <BR>
</I><P>
The only way to communicate information between different processors is for one to write a <BR>
shared location and the other to read the shared location and receive the newly written value. <BR>
(In this context, the sending of an interrupt from processor Pi to Pj is modeled as Pi writing to a <BR>
location INTij, and Pj reading from INTij.) <BR>
<P>
<B>5.6.1.7 Definition of Dependence Constraint <BR>
</B>The depends relation (DP) is defined as follows. Given <I>u </I>and <I>v </I>issued by processor Pi, where <I>u <BR>
</I>is a read or an instruction fetch and <I>v </I>is a write, <I>u </I>precedes <I>v </I>in DP order (written <I>u </I>DP <I>v, </I>that <BR>
is, <I>v </I>depends on <I>u) </I>in either of the following situations: <BR>
<P>
<B>° </B><I>u </I>determines the execution of <I>v, </I>the location accessed by <I>v, </I>or the value written by <I>v. <BR>
</I><B>° </B><I>u </I>determines the execution or address or value of another memory access <I>z </I>that pre-cedes <I>v </I>or might precede <I>v </I>(that is, would precede <I>v </I>in some execution path depending <BR>
<P>
on the value read by <I>u) </I>by processor issue constraint <A href="#page224">(see Section 5.6.1.3). <BR>
</A>
Note that the DP relation does not directly impose a BEFORE (Ü) ordering between accesses <BR>
<I>u </I>and <I>v. <BR>
</I><P>
The dependence constraint requires that the union of the DP relation and the "is a source of" <BR>
relation (see <A href="#page226">Section 5.6.1.6) </A>
be acyclic. That is, there must not exist reads and/ or I-fetches R1, <BR>
…, Rn, and writes W1, …, Wn, such that: <BR>
<P>
1. n ³ 1, <BR>
2. For each <I>i, </I>1 £ <I>i </I>£ <I>n, </I>Ri DP Wi, <BR>
3. For each <I>i, </I>1 £ i &lt; n, Wi is a source of Ri + 1, and <BR>
4. Wn is a source of R1. <BR>
That constraint eliminates the possibility of "causal loops." A simple example of a "causal <BR>
loop" is when the execution of a write on Pi depends on the execution of a write on Pj and vice <BR>
versa, creating a circular dependence chain. The following simple example of a "causal loop" <BR>
is written in the style of the litmus tests <A href="#page229">in Section 5.6.2, </A>
where initially <I>x </I>and <I>y </I>are 1: <BR>
<P>
Processor Pi executes: <BR>
<TT>LDQ R1, x <BR>
STQ R1, y <BR>
</TT><P>
Processor Pj executes: <BR>
<TT>LDQ R1, y <BR>
STQ R1, x </TT>
227
<BR>
<A href=#page227>227</A>
<strong><A name=page228> Page 228</A></strong>
<A href=#page229>229</A>
<BR>
<P>
<B>5– 16 </B>Alpha Architecture Handbook <BR>
Representing those code sequences in the style of the litmus tests in <A href="#page229">Section 5.6. 2, </A>
it is impos-sible <BR>
for the following sequence to result: <BR>
<P>
<B>Analysis: <BR>
</B><P>
Given the initial condition x, y = 1, the access sequence above would also be impossible if the <BR>
code were: <BR>
<P>
Processor Pi's program: <BR>
<TT>LDQ R1, x <BR>
BNE R1, done <BR>
STQ R31, y <BR>
done: <BR>
</TT><P>
Processor Pj's program: <BR>
<TT>LDQ R1, y <BR>
BNE R1, done <BR>
STQ R31, x <BR>
done: <BR>
</TT><P>
<B>5.6.1.8 Definition of Load-Locked and Store-Conditional <BR>
</B>The property of load-locked and store-conditional applies only to memory-like regions. <BR>
<P>
For each successful store-conditional <I>v, </I>there exists a load-locked <I>u </I>such that the following are <BR>
true: <BR>
<P>
1. <I>u </I>precedes <I>v </I>in the processor issue sequence. <BR>
2. There is no load-locked or store-conditional between <I>u </I>and <I>v </I>in the processor issue sequence. <BR>
<P>
3. If <I>u </I>and <I>v </I>access within the same naturally aligned 16-byte physical and virtual block in memory, then for every write <I>w </I>by a different processor that accesses within <I>u's </I>lock <BR>
range (where <I>w </I>is either a store or a successful store conditional), it must be true that <I>w <BR>
</I>Ü u or <I>v </I>Ü <I>w. <BR>
</I><P>
<I>u's </I>lock range contains the region of physical memory that <I>u </I>accesses. See Sections 4.2.4 and <BR>
4.2.5, which define the lock range and conditions for success or failure of a store conditional. <BR>
<P>
<B>Pi Pj <BR>
</B>[U1] Pi: R&lt; 8&gt;( x, 0) [V1] Pj: R&lt; 8&gt;( y, 0) <BR>
[U2] Pi: W&lt; 8&gt;( y, 0) [V2] Pj: W&lt; 8&gt;( x, 0) <BR>
<P>
&lt;1&gt; By the definitions of storage and visibility, U2 is the source of V1, and V2 is the <BR>
source of U1. <BR>
<P>
&lt;2&gt; By the definition of DP and examination of the code, U1 DP U2, and V1 DP V2. <BR>
&lt;3&gt; Thus, U1 DP U2, U2 is the source of V1, V1 DP V2, and V2 is the source of U1. <BR>
This circular chain is forbidden by the dependence constraint. 
228
<BR>
<A href=#page228>228</A>
<strong><A name=page229> Page 229</A></strong>
<A href=#page230>230</A>
<BR>
<P>
System Architecture and Programming Implications <B>5– 17 <BR>
5.6.1.9 Timeliness <BR>
</B>Even in the absence of a barrier after the write, no write by a processor may be delayed indefi-nitely <BR>
in the BEFORE ordering. <BR>
<P>
<B>5.6. 2 Litmus Tests <BR>
</B>Many issues about writing and reading shared data can be cast into questions about whether a <BR>
write is before or after a read. These questions can be answered by rigorously checking <BR>
whether any ordering satisfies the rules in <A href="#page224">Sections 5.6. 1.3 </A>
<A href="#page228">through 5.6.1.8. <BR>
</A>
<P>
In litmus tests 1– 9 below, all initial quadword memory locations contain 1. In all these litmus <BR>
tests, it is assumed that initializations are performed by a write or writes that are BEFORE all <BR>
the explicitly listed accesses, that all relevant writes other than the initializations are explicitly <BR>
shown, and that all accesses shown are to memory-like regions (so the definition of storage <BR>
applies). <BR>
<P>
<B>5.6.2.1 Litmus Test 1 (Impossible Sequence) <BR>
</B>Initially, location <I>x </I>contains 1: <BR>
<P>
<B>Analysis: <BR>
</B><P>
Thus, once a processor reads a new value from a location, it must never see an old value – time <BR>
must not go backward. V2 must read 2. <BR>
<P>
<B>Pi Pj <BR>
</B>[U1] Pi: W&lt; 8&gt;( x, 2) [V1] Pj: R&lt; 8&gt;( x, 2) <BR>
[V2] Pj: R&lt; 8&gt;( x, 1) <BR>
<P>
&lt;1&gt; By the definition of storage <A href="#page226">(Section 5.6. 1.6), </A>
V1 reading 2 implies that U1 is visible <BR>
to V1. <BR>
<P>
&lt;2&gt; By the rules for visibility <A href="#page226">(Section 5.6.1.5), </A>
U1 being visible to V1, but being issued <BR>
by a different processor, implies that U1 Ü </A>
V1. <BR>
<P>
&lt;3&gt; By the processor issue constraints <A href="#page224">(Section 5.6.1.3), </A>
V1 Ü V2. <BR>
&lt;4&gt; By the transitivity of the partial order Ü, it follows from &lt;2&gt; and &lt;3&gt; that U1 Ü <BR>
V2. <BR>
<P>
&lt;5&gt; By the rules for visibility, it follows from U1 Ü V2 that U1 is visible to V2. <BR>
&lt;6&gt; Since U1 is AFTER the initialization of <I>x, </I>U1 is the latest (in the Ü ordering) write <BR>
to <I>x </I>that is visible to V1. <BR>
<P>
&lt;7&gt; By the definition of storage, it follows that V2 should read the value written by U1, <BR>
in contradiction to the stated result. 
229
<BR>
<A href=#page229>229</A>
<strong><A name=page230> Page 230</A></strong>
<A href=#page231>231</A>
<BR>
<B>5– 18 </B>Alpha Architecture Handbook <BR>
<B>5.6.2.2 Litmus Test 2 (Impossible Sequence) <BR>
</B>Initially, location <I>x </I>contains 1: <BR>
<P>
<B>Analysis: <BR>
</B><P>
Thus, once processor Pj reads a new value written by U1, any other writes that must precede <BR>
the read must also precede U1. V3 must read 2. <BR>
<P>
<B>5.6.2.3 Litmus Test 3 (Impossible Sequence) <BR>
</B>Initially, location <I>x </I>contains 1: <BR>
<P>
<B>Analysis: <BR>
</B><P>
Again, time cannot go backwards. If V1 is ordered before U1, then processor Pk cannot read <BR>
first the later value 3 and then the earlier value 2. Alternatively, if V1 is ordered before U1, U2 <BR>
must read 2. <BR>
<P>
<B>Pi Pj <BR>
</B>[U1] Pi: W&lt; 8&gt;( x, 2) [V1] Pj: W&lt; 8&gt;( x, 3) <BR>
[V2] Pj: R&lt; 8&gt;( x, 2) <BR>
[V3] Pj: R&lt; 8&gt;( x, 3) <BR>
<P>
&lt;1&gt; Since V1 precedes V2 in processor issue sequence, V1 is visible to V2. <BR>
&lt;2&gt; V2 reading 2 implies U1 is the latest (in Ü order) write to <I>x </I>visible to V2. <BR>
&lt;3&gt; From &lt;1&gt; and &lt;2&gt;, V1 Ü U1. <BR>
&lt;4&gt; Since U1 is visible to V2, and they are issued by different processors, U1 Ü V2. <BR>
&lt;5&gt; By the processor issue constraints, V2 Ü V3. <BR>
&lt;6&gt; From &lt;4&gt; and &lt;5&gt;, U1 Ü V3. <BR>
&lt;7&gt; From &lt;6&gt; and the visibility rules, U1 is visible to V3. <BR>
&lt;8&gt; Since both V1 and the initialization of <I>x </I>are BEFORE U1, U1 is the latest write to <I>x <BR>
</I>that is visible to V3. <BR>
<P>
&lt;9&gt; By the definition of storage, it follows that V3 should read the value written by U1, <BR>
in contradiction to the stated result. <BR>
<P>
<B>Pi Pj Pk <BR>
</B>[U1] Pi: W&lt; 8&gt;( x, 2) [V1] Pj: W&lt; 8&gt;( x, 3) [W1] Pk: R&lt; 8&gt;( x, 3) <BR>
[U2] Pi: R&lt; 8&gt;( x, 3) [W2] Pk: R&lt; 8&gt;( x, 2) <BR>
<P>
&lt;1&gt; U2 reading 3 implies V1 is the latest write to <I>x </I>visible to U2, therefore U1 Ü V1. <BR>
&lt;2&gt; W1 reading 3 implies V1 is visible to W1, so V1 Ü W1 Ü W, therefore V1 is also <BR>
visible to W2. <BR>
<P>
&lt;3&gt; W2 reading 2 implies U1 is the latest write to <I>x </I>visible to W2, therefore V1 Ü U1. <BR>
&lt;4&gt; From &lt;1&gt; and &lt;3&gt;, U1 Ü V1 Ü U1. 
230
<BR>
<A href=#page230>230</A>
<strong><A name=page231> Page 231</A></strong>
<A href=#page232>232</A>
<BR>
System Architecture and Programming Implications <B>5– 19 <BR>
5.6.2.4 Litmus Test 4 (Sequence Okay) <BR>
</B>Initially, locations <I>x </I>and <I>y </I>contain 1: <BR>
<P>
<B>Analysis: <BR>
</B>There are no conflicts in the sequence. There are no violations of the definition of BEFORE. <BR>
<B>5.6.2.5 Litmus Test 5 (Sequence Okay) <BR>
</B>Initially, locations <I>x </I>and <I>y </I>contain 1: <BR>
<P>
<B>Analysis: <BR>
</B>There is U2 Ü V1 Ü V2 Ü V3 Ü U1. There are no conflicts in this sequence. There are no <BR>
violations of the definition of BEFORE. <BR>
<P>
<B>5.6.2.6 Litmus Test 6 (Sequence Okay) <BR>
</B>Initially, locations <I>x </I>and <I>y </I>contain 1: <BR>
<P>
<B>Analysis: <BR>
</B><P>
<B>Pi Pj <BR>
</B>[U1] Pi: W&lt; 8&gt;( x, 2) [V1] Pj: R&lt; 8&gt;( y, 2) <BR>
[U2] Pi: W&lt; 8&gt;( y, 2) [V2] Pj: R&lt; 8&gt;( x, 1) <BR>
<P>
&lt;1&gt; V1 reading 2 implies U2 Ü V1, by storage and visibility. <BR>
&lt;2&gt; Since V2 does not read 2, there cannot be U1 Ü V2. <BR>
&lt;3&gt; By the access order constraints, it follows from &lt;2&gt; that V2 Ü U1. <BR>
<P>
<B>Pi Pj <BR>
</B>[U1] Pi: W&lt; 8&gt;( x, 2) [V1] Pj: R&lt; 8&gt;( y, 2) <BR>
[V2] Pj: MB <BR>
[U2] Pi: W&lt; 8&gt;( y, 2) [V3] Pj: R&lt; 8&gt;( x, 1) <BR>
<P>
&lt;1&gt; V1 reading 2 implies U2 Ü V1, by storage and visibility. <BR>
&lt;2&gt; V1 Ü V2 Ü V3, by processor issue constraints. <BR>
&lt;3&gt; V3 reading 1 implies V3 Ü U1, by storage and visibility. <BR>
<P>
<B>Pi Pj <BR>
</B>[U1] Pi: W&lt; 8&gt;( x, 2) [V1] Pj: R&lt; 8&gt;( y, 2) <BR>
[U2] Pi: MB <BR>
[U3] Pi: W&lt; 8&gt;( y, 2) [V2] Pj: R&lt; 8&gt;( x, 1) <BR>
<P>
&lt;1&gt; U1 Ü U2 Ü U3, by processor issue constraints. <BR>
&lt;2&gt; V1 reading 2 implies U3 Ü V1, by storage and visibility. <BR>
&lt;3&gt; V2 reading 1 implies V2 Ü U1, by storage and visibility. 
231
<BR>
<A href=#page231>231</A>
<strong><A name=page232> Page 232</A></strong>
<A href=#page233>233</A>
<BR>
<B>5– 20 </B>Alpha Architecture Handbook <BR>
There is V2 Ü U1 Ü U2 Ü U3 Ü V1. There are no conflicts in this sequence. There are no <BR>
violations of the definition of BEFORE. <BR>
<P>
In litmus tests 4, 5, and 6, writes to two different locations <I>x </I>and <I>y </I>are observed (by another <BR>
processor) to occur in the opposite order than that in which they were performed. An update to <BR>
<I>y </I>propagates quickly to Pj, but the update to <I>x </I>is delayed, and Pi and Pj do not both have MBs. <BR>
<P>
<B>5.6.2.7 Litmus Test 7 (Impossible Sequence) <BR>
</B>Initially, locations <I>x </I>and <I>y </I>contain 1: <BR>
<P>
<B>Analysis: <BR>
</B><P>
Both &lt;1&gt; and &lt;5&gt; cannot be true, so if V1 reads 2, then V3 must also read 2. <BR>
If both <I>x </I>and <I>y </I>are in memory-like regions, the sequence remains impossible if U2 is changed <BR>
to a WMB. Similarly, if both <I>x </I>and <I>y </I>are in non-memory-like regions, the sequence remains <BR>
impossible if U2 is changed to a WMB. <BR>
<P>
<B>5.6.2.8 Litmus Test 8 (Impossible Sequence) <BR>
</B>Initially, locations <I>x </I>and <I>y </I>contain 1: <BR>
<P>
<B>Analysis: <BR>
</B><P>
Both &lt;1&gt; and &lt;5&gt; cannot be true, so if U3 reads 1, then V3 must read 2, and vice versa. <BR>
<P>
<B>Pi Pj <BR>
</B>[U1] Pi: W&lt; 8&gt;( x, 2) [V1] Pj: R&lt; 8&gt;( y, 2) <BR>
[U2] Pi: MB [V2] Pj: MB <BR>
[U3] Pi: W&lt; 8&gt;( y, 2) [V3] Pj: R&lt; 8&gt;( x, 1) <BR>
<P>
&lt;1&gt; V3 reading 1 implies V3 Ü U1, by storage and visibility. <BR>
&lt;2&gt; V1 reading 2 implies U3 Ü V1, by storage and visibility. <BR>
&lt;3&gt; U1 Ü U2 Ü U3, by processor issue constraints. <BR>
&lt;4&gt; V1 Ü V2 Ü V3, by processor issue constraints. <BR>
&lt;5&gt; By &lt;2&gt;, &lt;3&gt;, and &lt;4&gt;, U1 Ü U2 Ü U3 Ü V1 Ü V2 Ü V3. <BR>
<P>
<B>Pi Pj <BR>
</B>[U1] Pi: W&lt; 8&gt;( x, 2) [V1] Pj: W&lt; 8&gt;( y, 2) <BR>
[U2] Pi: MB [V2] Pj: MB <BR>
[U3] Pi: R&lt; 8&gt;( y, 1) [V3] Pj: R&lt; 8&gt;( x, 1) <BR>
<P>
&lt;1&gt; V3 reading 1 implies V3 Ü U1, by storage and visibility. <BR>
&lt;2&gt; U3 reading 1 implies U3 Ü V1, by storage and visibility. <BR>
&lt;3&gt; U1 Ü U2 Ü U3, by processor issue constraints. <BR>
&lt;4&gt; V1 Ü V2 Ü V3, by processor issue constraints. <BR>
&lt;5&gt; By &lt;2&gt;, &lt;3&gt;, and &lt;4&gt;, U1 Ü U2 Ü U3 Ü V1 Ü V2 Ü V3. 
232
<BR>
<A href=#page232>232</A>
<strong><A name=page233> Page 233</A></strong>
<A href=#page234>234</A>
<BR>
System Architecture and Programming Implications <B>5– 21 <BR>
5.6.2.9 Litmus Test 9 (Impossible Sequence) <BR>
</B>Initially, location <I>x </I>contains 1: <BR>
<P>
<B>Analysis: <BR>
</B>Both &lt;1&gt; and &lt;2&gt; cannot be true. Time cannot go backwards. If V3 reads 2, then U3 must read <BR>
2. Alternatively, if U3 reads 3, then V3 must read 3. <BR>
<P>
<B>5.6.2.10 Litmus Test 10 (Sequence Okay) <BR>
</B>For an aligned quadword location, <I>x, </I>initially 100000001 16 : <BR>
<P>
<B>Analysis: <BR>
</B><P>
There is no ordering cycle, so the sequence is permitted. <BR>
<B>5.6.2.11 Litmus Test 11 (Impossible Sequence) <BR>
</B>For an aligned quadword location, <I>x, </I>initially 100000001 16 : <BR>
<P>
<B>Analysis: <BR>
</B>Both &lt;1&gt; and &lt;2&gt; cannot be true. <BR>
<P>
<B>Pi Pj <BR>
</B>[U1] Pi: W&lt; 8&gt;( x, 2) [V1] Pj: W&lt; 8&gt;( x, 3) <BR>
[U2] Pi: R&lt; 8&gt;( x, 2) [V2] Pj: R&lt; 8&gt;( x, 3) <BR>
[U3] Pi: R&lt; 8&gt;( x, 3) [V3] Pj: R&lt; 8&gt;( x, 2) <BR>
<P>
&lt;1&gt; V3 reading 2 implies U1 is the latest write to <I>x </I>visible to V3, therefore V1 Ü U1. <BR>
&lt;2&gt; U3 reading 3 implies V1 is the latest write to <I>x </I>visible to U3, therefore U1 Ü V1. <BR>
<P>
<B>Pi Pj <BR>
</B>[U1] Pi: W&lt; 4&gt;( x, 2) [V1] Pj: W&lt; 4&gt;( x+ 4,2) <BR>
[U2] Pi: R&lt; 8&gt;( x, 100000002 16 ) [V2] Pj: R&lt; 8&gt;( x, 200000001 16 ) <BR>
<P>
&lt;1&gt; Since U2 reads 1 from x+ 4, V1 is not visible to U2. Thus U2 Ü V1. <BR>
&lt;2&gt; Similarly, V2 Ü U1. <BR>
&lt;3&gt; U1 is visible to U2, but since they are issued by the same processor, it is not neces-sarily <BR>
the case that U1 Ü U2. <BR>
<P>
&lt;4&gt; Similarly, it is not necessarily the case that V1 Ü V2. <BR>
<P>
<B>Pi Pj <BR>
</B>[U1] Pi: W&lt; 4&gt;( x, 2) [V1] Pj: R&lt; 8&gt;( x, 200000001 16 ) <BR>
[U2] Pi: MB or WMB <BR>
[U3] Pi: W&lt; 4&gt;( x+ 4,2) <BR>
<P>
&lt;1&gt; V1 reading 200000001 16 implies U3 Ü V1 Ü U1 by storage and visibility. <BR>
&lt;2&gt; U1 Ü U2 Ü U3, by processor issue constraints. 
233
<BR>
<A href=#page233>233</A>
<strong><A name=page234> Page 234</A></strong>
<A href=#page235>235</A>
<BR>
<P>
<B>5– 22 </B>Alpha Architecture Handbook <BR>
<B>5. 6. 3 Implied Barriers <BR>
</B>There are no implied barriers in Alpha. If an implied barrier is needed for functionally correct <BR>
access to shared data, it must be written as an explicit instruction. (Software must explicitly <BR>
include any needed MB, WMB, or CALL_ PAL IMB instructions.) <BR>
<P>
Alpha transitions such as the following have no built-in implied memory barriers: <BR>
<B>° </B>Entry to PALcode <BR>
<B>° </B>Sending and receiving interrupts <BR>
<B>° </B>Returning from exceptions, interrupts, or machine checks <BR>
<B>° </B>Swapping context <BR>
<B>° </B>Invalidating the Translation Buffer (TB) <BR>
Depending on implementation choices for maintaining cache coherency, some PALcode/ cache <BR>
implementations may have an implied CALL_ PAL IMB in the I-stream TB fill routine, but <BR>
this is transparent to the non-PALcode programmer. <BR>
<P>
<B>5.6. 4 Implications for Software <BR>
</B>Software must explicitly include MB, WMB, or CALL_ PAL IMB instructions according to the <BR>
following circumstances. <BR>
<P>
<B>5.6.4.1 Single Processor Data Stream <BR>
</B>No barriers are ever needed. A read to physical address <I>x </I>will always return the value written <BR>
by the immediately preceding write to <I>x </I>in the processor issue sequence. <BR>
<P>
<B>5.6.4.2 Single Processor Instruction Stream <BR>
</B>An I-fetch from virtual or physical address <I>x </I>does not necessarily return the value written by <BR>
the immediately preceding write to <I>x </I>in the issue sequence. To make the I-fetch reliably get the <BR>
newly written instruction, a CALL_ PAL IMB is needed between the write and the I-fetch. <BR>
<P>
<B>5.6.4.3 Multiprocessor Data Stream (Including Single Processor with DMA I/ O) <BR>
</B>Generally, the only way to reliably communicate shared data is to write the shared data on one <BR>
processor or DMA I/ O device, execute an MB (or the logical equivalent 1 if it is a DMA I/ O <BR>
device), then write a flag (equivalently, send an interrupt) signaling the other processor that the <BR>
shared data is ready. Each receiving processor must read the new flag (equivalently, receive the <BR>
interrupt), execute an MB, then read or update the shared data. In the special case in which data <BR>
<P>
1 In this context, the logical equivalent of an MB for a DMA device is whatever is necessary under the <BR>
applicable I/ O subsystem architecture to ensure that preceding writes will be BEFORE <A href="#page224">(see Section <BR>
</A>
<A href="#page224">5.6.1.2) </A>
the subsequent write of a flag or transmission of an interrupt. Not all I/ O devices behave <BR>
exactly as required by the Alpha architecture. To interoperate properly with those devices, some spe-cial <BR>
action might be required by the program executing on the CPU. For example, PCI bus devices <BR>
require that after the CPU has received an interrupt, the CPU must read a CSR location on the PCI <BR>
device, execute an MB, then read or update the shared data. From the perspective of the Alpha archi-tecture, <BR>
this CSR read can be regarded as a necessary assist to help the DMA I/ O device complete its <BR>
logical equivalent of an MB. 
234
<BR>
<A href=#page234>234</A>
<strong><A name=page235> Page 235</A></strong>
<A href=#page236>236</A>
<BR>
<P>
System Architecture and Programming Implications <B>5– 23 <BR>
</B>is communicated through just one location in memory, memory barriers are not necessary. <BR>
<B>Software Note: <BR>
</B>Note that this section does not describe how to reliably communicate data from a processor <BR>
to a DMA device. <A href="#page239">See Section 5. 6.4.7. <BR>
</A>
<P>
Leaving out the first MB removes the assurance that the shared data is written before the flag is <BR>
written. <BR>
<P>
Leaving out the second MB removes the assurance that the shared data is read or updated only <BR>
after the flag is seen to change; in this case, an early read could see an old value, and an early <BR>
update could be overwritten. <BR>
<P>
This implies that after a DMA I/ O device has written some data to memory (such as paging in <BR>
a page from disk), the DMA device must logically execute an MB 1 before posting a comple-tion <BR>
interrupt, and the interrupt handler software must execute an MB before the data is <BR>
guaranteed to be visible to the interrupted processor. Other processors must also execute MBs <BR>
before they are guaranteed to see the new data. <BR>
<P>
An important special case occurs when a write is done (perhaps by an I/ O device) to some <BR>
physical page frame, then an MB is executed, and then a previously invalid PTE is changed to <BR>
be a valid mapping of the physical page frame that was just written. In this case, all processors <BR>
that access virtual memory by using the newly valid PTE must guarantee to deliver the newly <BR>
written data after the TB miss, for both I-stream and D-stream accesses. <BR>
<P>
<B>5.6.4.4 Multiprocessor Instruction Stream (Including Single Processor with DMA I/ O) <BR>
</B>The only way to update the I-stream reliably is to write the shared I-stream on one processor or <BR>
DMA I/ O device, then execute a CALL_ PAL IMB (or an MB if the processor is not going to <BR>
execute the new I-stream, or the logical equivalent of an MB if it is a DMA I/ O device), then <BR>
write a flag (equivalently, send an interrupt) signaling the other processor that the shared <BR>
I-stream is ready. Each receiving processor must read the new flag (equivalently, receive the <BR>
interrupt), execute a CALL_ PAL IMB, then fetch the shared I-stream. <BR>
<P>
<B>Software Note: <BR>
</B>Note that this section does not describe how to reliably communicate I-stream from a <BR>
processor to a DMA device. <A href="#page239">See Section 5.6.4.7. <BR>
</A>
<P>
Leaving out the first CALL_ PAL IMB (or MB) removes the assurance that the shared I-stream <BR>
is written before the flag. <BR>
<P>
Leaving out the second CALL_ PAL IMB removes the assurance that the shared I-stream is <BR>
read only <I>after </I>the flag is seen to change; in this case, an early read could see an old value. <BR>
<P>
1 See Footnote 1 on page 5-22. 
235
<BR>
<A href=#page235>235</A>
<strong><A name=page236> Page 236</A></strong>
<A href=#page237>237</A>
<BR>
<P>
<B>5– 24 </B>Alpha Architecture Handbook <BR>
This implies that after a DMA I/ O device has written some I-stream to memory (such as pag-ing <BR>
in a page from disk), the DMA device must logically execute an MB 1 before posting a <BR>
completion interrupt, and the interrupt handler software must execute a CALL_ PAL IMB <BR>
before the I-stream is guaranteed to be visible to the interrupted processor. Other processors <BR>
must also execute CALL_ PAL IMB instructions before they are guaranteed to see the new <BR>
I-stream. <BR>
<P>
An important special case occurs under the following circumstances: <BR>
1. A write (perhaps by an I/ O device) is done to some physical page frame. <BR>
2. A CALL_ PAL IMB (or MB) is executed. <BR>
3. A previously invalid PTE is changed to be a valid mapping of the physical page frame that was written in step 1. <BR>
<P>
In this case, all processors that access virtual memory by using the newly valid PTE must guar-antee <BR>
to deliver the newly written I-stream after the TB miss. <BR>
<P>
<B>5.6.4.5 Multiprocessor Context Switch <BR>
</B>If a process migrates from executing on one processor to executing on another, the context <BR>
switch operating system code must include a number of barriers. <BR>
<P>
A process migrates by having its context stored into memory, then eventually having that con-text <BR>
reloaded on another processor. In between, some shared mechanism must be used to <BR>
communicate that the context saved in memory by the first processor is available to the second <BR>
processor. This could be done by using an interrupt, by using a flag bit associated with the <BR>
saved context, or by using a shared-memory multiprocessor data structure, as follows: <BR>
<P>
1 See Footnote 1 on <A href="#page234">page 5-22. <BR>
</A>
<B>First Processor Second Processor <BR>
</B>: <BR>
Save state of current process. <BR>
MB [1] <BR>
Pass ownership of process con-text <BR>
data structure memory. Þ Pick up ownership of process context data <BR>
structure memory. <BR>
<P>
MB [2] <BR>
Restore state of new process context data struc-ture <BR>
memory. <BR>
<P>
Make I-stream coherent [3]. <BR>
Make TB coherent [4]. <BR>
: <BR>
Execute code for new process that accesses <BR>
memory that is not common to all processes. 
236
<BR>
<A href=#page236>236</A>
<strong><A name=page237> Page 237</A></strong>
<A href=#page238>238</A>
<BR>
<P>
System Architecture and Programming Implications <B>5– 25 <BR>
</B>MB [1] ensures that the writes done to save the state of the current process happen before <BR>
the ownership is passed. <BR>
<P>
MB [2] ensures that the reads done to load the state of the new process happen after the <BR>
ownership is picked up and hence are reliably the values written by the processor saving <BR>
the old state. Leaving this MB out makes the code fail if an old value of the context <BR>
remains in the second processor's cache and invalidates from the writes done on the first <BR>
processor are not delivered soon enough. <BR>
<P>
The TB on the second processor must be made coherent with any write to the page tables <BR>
that may have occurred on the first processor just before the save of the process state. This <BR>
must be done with a series of TB invalidate instructions to remove any nonglobal page <BR>
mapping for this process, or by assigning an ASN that is unused on the second processor to <BR>
the process. One of these actions must occur sometime before starting execution of the <BR>
code for the new process that accesses memory (instruction or data) that is not common to <BR>
all processes. A common method is to assign a new ASN after gaining ownership of the <BR>
new process and before loading its context, which includes its ASN. <BR>
<P>
The D-cache on the second processor must be made coherent with any write to the <BR>
D-stream that may have occurred on the first processor just before the save of process <BR>
state. This is ensured by MB [2] and does not require any additional instructions. <BR>
<P>
The I-cache on the second processor must be made coherent with any write to the I-stream <BR>
that may have occurred on the first processor just before the save of process state. This can <BR>
be done with a CALL_ PAL IMB sometime before the execution of any code that is not <BR>
common to all processes, More commonly, this can be done by forcing a TB miss (via the <BR>
new ASN or via TB invalidate instructions) and using the TB-fill rule (see <A href="#page234">Section 5.6. 4.3). <BR>
</A>
This latter approach does not require any additional instruction. <BR>
<P>
Combining all these considerations gives the following, where, on a single processor, there is <BR>
no need for the barriers: 
237
<BR>
<A href=#page237>237</A>
<strong><A name=page238> Page 238</A></strong>
<A href=#page239>239</A>
<BR>
<P>
<B>5– 26 </B>Alpha Architecture Handbook <BR>
<B>5.6.4.6 Multiprocessor Send/ Receive Interrupt <BR>
</B>If one processor writes some shared data, then sends an interrupt to a second processor, and <BR>
that processor receives the interrupt, then accesses the shared data, the sequence from <A href="#page234">Section <BR>
</A>
<A href="#page234">5.6.4.3 </A>
must be used: <BR>
<P>
<B>First Processor Second Processor <BR>
</B>: <BR>
Pick up ownership of process con-text <BR>
data structure memory. <BR>
<P>
MB <BR>
Assign new ASN or invalidate <BR>
TBs. <BR>
<P>
Save state of current process. <BR>
Restore state of new process. <BR>
MB <BR>
Pass ownership of process context <BR>
data structure memory. <BR>
: <BR>
Þ : Pickup ownership of new process context data structure memory. <BR>
<P>
:MB <BR>
Assign new ASN or invalidate TBs. <BR>
Save state of current process. <BR>
Restore state of new process. <BR>
MB <BR>
Pass ownership of old process context data <BR>
structure memory. <BR>
<P>
: <BR>
Execute code for new process that accesses <BR>
memory that is not common to all processes. 
238
<BR>
<A href=#page238>238</A>
<strong><A name=page239> Page 239</A></strong>
<A href=#page240>240</A>
<BR>
<P>
System Architecture and Programming Implications <B>5– 27 <BR>
</B>Leaving out the MB at the beginning of the interrupt-receipt routine causes the code to fail if <BR>
an old value of the context remains in the second processor's cache, and invalidates from the <BR>
writes done on the first processor are not delivered soon enough. <BR>
<P>
<B>5.6.4.7 Implications for Memory Mapped I/ O <BR>
</B>Sections <A href="#page234">5.6.4. 3 </A>
and <A href="#page235">5.6. 4.4 </A>
describe methods for communicating data from a processor or <BR>
DMA I/ O device to another processor that work reliably in all Alpha systems. Special consid-erations <BR>
apply to the communication of data or I-stream from a processor to a DMA I/ O <BR>
device. These considerations arise from the use of bridges to connect to I/ O buses with devices <BR>
that are accessible by memory accesses to non-memory-like regions of physical memory. <BR>
<P>
The following communication method works in all Alpha systems. <BR>
To reliably communicate shared data from a processor to an I/ O device: <BR>
1. Write the shared data to a memory-like physical memory region on the processor. <BR>
2. Execute an MB instruction. <BR>
3. Write a flag (equivalently, send an interrupt or write a register location implemented in the I/ O device). <BR>
<P>
The receiving I/ O device must: <BR>
1. Read the flag (equivalently, detect the interrupt or detect the write to the register loca-tion <BR>
implemented in the I/ O device). <BR>
<P>
2. Execute the equivalent of an MB 1 <BR>
3. Read the shared data. <BR>
As shown in <A href="#page234">Section 5. 6. 4. 3, </A>
leaving out the memory barrier removes the assurance that the <BR>
shared data is written before the flag is. Unlike the case in <A href="#page234">Section 5. 6. 4. 3, </A>
writing the shared <BR>
data to a non-memory-like physical memory region removes the assurance that the I/ O device <BR>
<P>
<B>First Processor Second Processor <BR>
</B>: <BR>
Write data <BR>
MB <BR>
Send interrupt Þ Receive interrupt <BR>
MB <BR>
Access data <BR>
: <BR>
<P>
1 In this context, the logical equivalent of an MB for a DMA device is whatever is necessary under the <BR>
applicable I/ O subsystem architecture to ensure that preceding writes will be BEFORE <A href="#page224">(see Section <BR>
</A>
<A href="#page224">5.6.1.2) </A>
the subsequent reads of shared data. Typically, this action is defined to be present between <BR>
every read and write access done by the I/ O device, according to the applicable I/ O subsystem archi-tecture. 
239
<BR>
<A href=#page239>239</A>
<strong><A name=page240> Page 240</A></strong>
<A href=#page241>241</A>
<BR>
<B>5– 28 </B>Alpha Architecture Handbook <BR>
will detect the writes of the shared data before detecting the flag write, interrupt, or device reg-ister <BR>
write. <BR>
<P>
This implies that after a processor has prepared a data buffer to be read from memory by a <BR>
DMA I/ O device (such as writing a buffer to disk), the processor must execute an MB before <BR>
starting the I/ O. The I/ O device, after receiving the start signal, must logically execute an MB <BR>
before reading the data buffer, and the buffer must be located in a memory-like physical mem-ory <BR>
region. <BR>
<P>
There are methods of communicating data that may work in some systems but are not guaran-teed <BR>
in all systems. Two notable examples are: <BR>
<P>
1. If an Alpha processor writes a location implemented in a component located on an I/ O <BR>
bus in the system, then executes a memory barrier, then writes a flag in some memory <BR>
location (in a memory-like or non-memory-like region), a device on the I/ O bus may be <BR>
able to detect (via read access) the result of the flag in memory write and the write of <BR>
the location on the I/ O bus out of order (that is, in a different order than the order in <BR>
which the Alpha processor wrote those locations). <BR>
<P>
2. If an Alpha processor writes a location that is a control register within an I/ O device, then executes a memory barrier, then writes a location in memory (in a memory-like or <BR>
<P>
non-memory-like region), the I/ O device may be able to detect (via read access) the result of the memory write before receiving and responding to the write of its own con-trol <BR>
register. <BR>
In almost every case, a mechanism that ensures the completion of writes to control register <BR>
locations within I/ O devices is provided. The normal and strongly recommended mechanism is <BR>
to read a location after writing it, which guarantees that the write is complete. In any case, all <BR>
systems that use a particular I/ O device should provide the same mechanism for that device. <BR>
<P>
<B>5.6.4.8 Multiple Processors Writing to a Single I/ O Device <BR>
</B>Generally, for multiple processors to cooperate in writing to a single I/ O device, the first pro-cessor <BR>
must write to the device, execute an MB, then notify other processors. Another <BR>
processor that intends to write the same I/ O device after the first processor must receive the <BR>
notification, execute an MB, and then write to the I/ O device. For example: <BR>
<P>
<B>First Processor Second Processor <BR>
</B>: <BR>
Write CSR_ A <BR>
MB <BR>
Write flag (in memory) Þ Read flag (in memory) <BR>
MB <BR>
Write CSR_ B <BR>
: 
240
<BR>
<A href=#page240>240</A>
<strong><A name=page241> Page 241</A></strong>
<A href=#page242>242</A>
<BR>
<P>
System Architecture and Programming Implications <B>5– 29 <BR>
</B>The MB on the first processor guarantees that the write to CSR_ A precedes the write to flag in <BR>
memory, as perceived on other processors. (The MB does not guarantee that the write to <BR>
CSR_ A has completed. See <A href="#page239">Section 5.6. 4. 7 </A>
for a discussion of how a processor can guarantee <BR>
that a write to an I/ O device has completed at that device.) The MB on the second processor <BR>
guarantees that the write to CSR_ B will reach the I/ O device after the write to CSR_ A. <BR>
<P>
<B>5.6. 5 Implications for Hardware <BR>
</B>The coherency point for physical address <I>x </I>is the place in the memory subsystem at which <BR>
accesses to <I>x </I>are ordered. It may be at a main memory board, or at a cache containing <I>x </I>exclu-sively, <BR>
or at the point of winning a common bus arbitration. <BR>
<P>
The coherency point for <I>x </I>may move with time, as exclusive access to <I>x </I>migrates between <BR>
main memory and various caches. <BR>
<P>
MB and CALL_ PAL IMB force all preceding writes to at least reach their respective coher-ency <BR>
points. This does not mean that main-memory writes have been done, just that the <I>order <BR>
</I>of the eventual writes is committed. For example, on the XMI with retry, this means getting the <BR>
writes acknowledged as received with good parity at the inputs to memory board queues; the <BR>
actual RAM write happens later. <BR>
<P>
MB and CALL_ PAL IMB also force all queued cache invalidates to be delivered to the local <BR>
caches before starting any subsequent reads (that may otherwise cache hit on stale data) or <BR>
writes (that may otherwise write the cache, only to have the write effectively overwritten by a <BR>
late-delivered invalidate). <BR>
<P>
WMB ensures that the final order of writes to memory-like regions is committed and that the <BR>
final order of writes to non-memory-like regions is committed. This does not imply that the <BR>
final order of writes to memory-like regions relative to writes to non-memory-like regions is <BR>
committed. It also prevents writes that precede the WMB from merging with writes that fol-low <BR>
the WMB. For example, an implementation with a write buffer might implement WMB by <BR>
closing all valid write buffer entries from further merging and then drain the write buffer <BR>
entries in order. <BR>
<P>
Implementations may allow reads of <I>x </I>to hit (by physical address) on pending writes in a write <BR>
buffer, even before the writes to <I>x </I>reach the coherency point for <I>x. </I>If this is done, it is still true <BR>
that no earlier value of <I>x </I>may subsequently be delivered to the processor that took the hit on the <BR>
write buffer value. <BR>
<P>
Virtual data caches are allowed to deliver data before doing address translation, but only if <BR>
there cannot be a pending write under a synonym virtual address. Lack of a write-buffer match <BR>
on untranslated address bits is sufficient to guarantee this. <BR>
<P>
Virtual data caches must invalidate or otherwise become coherent with the new value when-ever <BR>
a PALcode routine is executed that affects the validity, fault behavior, protection <BR>
behavior, or virtual-to-physical mapping specified for one or more pages. Becoming coherent <BR>
can be delayed until the next subsequent MB instruction or TB fill (using the new mapping) if <BR>
the implementation of the PALcode routine always forces a subsequent TB fill. 
241
<BR>
<A href=#page241>241</A>
<strong><A name=page242> Page 242</A></strong>
<A href=#page243>243</A>
<BR>
<B>5– 30 </B>Alpha Architecture Handbook <BR>
<B>5. 7 Arithmetic Traps <BR>
</B>Alpha implementations are allowed to execute multiple instructions concurrently and to for-ward <BR>
results from one instruction to another. Thus, when an arithmetic trap is detected, the PC <BR>
may have advanced an arbitrarily large number of instructions past the instruction T (calculat-ing <BR>
result R) whose execution triggered the trap. <BR>
<P>
When the trap is detected, any or all of these subsequent instructions may run to completion <BR>
before the trap is actually taken. The set of instructions subsequent to T that complete before <BR>
the trap is taken are collectively called the trap shadow of T. The PC pushed on the stack when <BR>
the trap is taken is the PC of the first instruction past the trap shadow. <BR>
<P>
The instructions in the trap shadow of T may use the UNPREDICTABLE result R of T, they <BR>
may generate additional traps, and they may completely change the PC (branches, JSR). <BR>
<P>
Thus, by the time a trap is taken, the PC pushed on the stack may bear no useful relationship to <BR>
the PC of the trigger instruction T, and the state visible to the programmer may have been <BR>
updated using the UNPREDICTABLE result R. If an instruction in the trap shadow of T uses <BR>
R to calculate a subsequent register value, that register value is UNPREDICTABLE, even <BR>
though there may be no trap associated with the subsequent calculation. Similarly: <BR>
<P>
<B>° </B>If an instruction in the trap shadow of T stores R or any subsequent UNPREDICT-ABLE result, the stored value is UNPREDICTABLE. <BR>
<P>
<B>° </B>If an instruction in the trap shadow of T uses R or any subsequent UNPREDICTABLE result as the basis of a conditional or calculated branch, the branch target is UNPRE-DICTABLE. <BR>
<P>
<B>° </B>If an instruction in the trap shadow of T uses R or any subsequent UNPREDICTABLE result as the basis of an address calculation, the memory address actually accessed is <BR>
UNPREDICTABLE. <BR>
Software can follow the rules in Section 4.7.7.3 to reliably bound how far the PC may advance <BR>
before taking a trap, how far an UNPREDICTABLE result may propagate or continue from a <BR>
trap by supplying a well-defined result R within an arithmetic trap handler. Arithmetic instruc-tions <BR>
that do not use the /S exception completion qualifier can reliably produce that behavior <BR>
by inserting TRAPB instructions at appropriate points. 
242
<BR>
<A href=#page242>242</A>
<strong><A name=page243> Page 243</A></strong>
<A href=#page244>244</A>
<BR>
Common PALcode Architecture <B>6– 1 <BR>
Chapter 6 <BR>
Common PALcode Architecture <BR>
</B><P>
<B>6.1 PALcode <BR>
</B>In a family of machines, both users and operating system developers require functions to be <BR>
implemented consistently. When functions conform to a common interface, the code that uses <BR>
those functions can be used on several different implementations without modification. <BR>
<P>
These functions range from the binary encoding of the instruction and data to the exception <BR>
mechanisms and synchronization primitives. Some of these functions can be implemented cost <BR>
effectively in hardware, but others are impractical to implement directly in hardware. These <BR>
functions include low-level hardware support functions such as Translation Buffer miss fill <BR>
routines, interrupt acknowledge, and vector dispatch. They also include support for privileged <BR>
and atomic operations that require long instruction sequences. <BR>
<P>
In the VAX, these functions are generally provided by microcode. This is not seen as a prob-lem <BR>
because the VAX architecture lends itself to a microcoded implementation. <BR>
<P>
One of the goals of Alpha architecture is to implement functions consistently without micro-code. <BR>
However, it is still desirable to provide an architected interface to these functions that <BR>
will be consistent across the entire family of machines. The Privileged Architecture Library <BR>
(PALcode) provides a mechanism to implement these functions without microcode. <BR>
<P>
<B>6. 2 PALcode Instructions and Functions <BR>
</B>PALcode is used to implement the following functions: <BR>
<P>
<B>° </B>Instructions that require complex sequencing as an atomic operation <B>° </B>Instructions that require VAX style interlocked memory access <BR>
<P>
<B>° </B>Privileged instructions <B>° </B>Memory management control, including translation buffer (TB) management <BR>
<B>° </B>Context swapping <B>° </B>Interrupt and exception dispatching <BR>
<B>° </B>Power-up initialization and booting <B>° </B>Console functions <BR>
<B>° </B>Emulation of instructions with no hardware support 
243
<BR>
<A href=#page243>243</A>
<strong><A name=page244> Page 244</A></strong>
<A href=#page245>245</A>
<BR>
<B>6– 2 </B>Alpha Architecture Handbook <BR>
The Alpha architecture lets these functions be implemented in standard machine code that is <BR>
resident in main memory. PALcode is written in standard machine code with some implemen-tation-<BR>
specific extensions to provide access to low-level hardware. This lets an Alpha <BR>
implementation make various design trade-offs based on the hardware technology being used <BR>
to implement the machine. The PALcode can abstract these differences and make them invisi-ble <BR>
to system software. <BR>
<P>
For example, in a MOS VLSI implementation, a small (32-entry) fully associative TB can be <BR>
the right match to the media, given that chip area is a costly resource. In an ECL version, a <BR>
large (1024 entry) direct-mapped TB can be used because it will use RAM chips and does not <BR>
have fast associative memories available. This difference would be handled by implementa-tion-<BR>
specific versions of the PALcode on the two systems, both versions providing transparent <BR>
TB miss service routines. The operating system code would not need to know there were any <BR>
differences. <BR>
<P>
An Alpha Privileged Architecture Library (PALcode) of routines and environments is supplied <BR>
by Compaq. Other systems may use a library supplied by Compaq or architect and implement a <BR>
different library of routines. Alpha systems are required to support the replacement of PAL-code <BR>
defined by Compaq with an operating system-specific version. <BR>
<P>
<B>6. 3 PALcode Environment <BR>
</B>The PALcode environment differs from the normal environment in the following ways: <BR>
<B>° </B>Complete control of the machine state. <BR>
<B>° </B>Interrupts are disabled. <BR>
<B>° </B>Implementation-specific hardware functions are enabled, as described below. <BR>
<B>° </B>I-stream memory management traps are prevented (by disabling I-stream mapping, mapping PALcode with a permanent TB entry, or by other mechanisms). <BR>
<P>
Complete control of the machine state allows all functions of the machine to be controlled. <BR>
Disabling interrupts allows the system to provide multi-instruction sequences as atomic opera-tions. <BR>
Enabling implementation-specific hardware functions allows access to low-level system <BR>
hardware. Preventing I-stream memory management traps allows PALcode to implement <BR>
memory management functions such as translation buffer fill. <BR>
<P>
<B>6. 4 Special Functions Required for PALcode <BR>
</B>PALcode uses the Alpha instruction set for most of its operations. A small number of addi-tional <BR>
functions are needed to implement the PALcode. Five opcodes are reserved to <BR>
implement PALcode functions: PAL19, PAL1B, PAL1D, PAL1E, and PAL1F. These instruc-tions <BR>
produce an trap if executed outside the PALcode environment. <BR>
<P>
<B>° </B>PALcode needs a mechanism to save the current state of the machine and dispatch into PALcode. <BR>
<P>
<B>° </B>PALcode needs a set of instructions to access hardware control registers. 
244
<BR>
<A href=#page244>244</A>
<strong><A name=page245> Page 245</A></strong>
<A href=#page246>246</A>
<BR>
Common PALcode Architecture <B>6– 3 <BR>
° </B>PALcode needs a hardware mechanism to transition the machine from the PALcode environment to the non-PALcode environment. This mechanism loads the PC, enables <BR>
interrupts, enables mapping, and disables PALcode privileges. <BR>
An Alpha implementation may also choose to provide additional functions to simplify or <BR>
improve performance of some PALcode functions. The following are some examples: <BR>
<P>
<B>° </B>An Alpha implementation may include a read/ write virtual function that allows PAL-code to perform mapped memory accesses using the mapping hardware rather than pro-viding <BR>
<P>
the virtual-to-physical translation in PALcode routines. PALcode may provide a <BR>
special function to do physical reads and writes and have the Alpha loads and stores <BR>
continue to operate on virtual address in the PALcode environment. <BR>
<P>
<B>° </B>An Alpha implementation may include hardware assists for various functions, such as saving the virtual address of a reference on a memory management error rather than <BR>
<P>
having to generate it by simulating the effective address calculation in PALcode. <BR>
<B>° </B>An Alpha implementation may include private registers so it can function without hav-ing to save and restore the native general registers. <BR>
<P>
<B>6.5 PALcode Effects on System Code <BR>
</B>PALcode will have one effect on system code. Because PALcode may reside in main memory <BR>
and maintain privileged data structures in main memory, the operating system code that allo-cates <BR>
physical memory cannot use all of physical memory. <BR>
<P>
The amount of memory PALcode requires is small, so the loss to the system is negligible. <BR>
<P>
<B>6.6 PALcode Replacement <BR>
</B>Alpha systems are required to support the replacement of PALcode supplied by Compaq with <BR>
an operating system-specific version. The following functions must be implemented in PAL-code, <BR>
<I>not </I>directly in hardware, to facilitate replacement with different versions. <BR>
<P>
<B>° </B>Translation Buffer fill. Different operating systems will want to replace the Translation Buffer (TB) fill routines. The replacement routines will use different data structures. <BR>
<P>
Page tables will not be present in these systems. Therefore, no portion of the TB fill <BR>
flow that would change with a change in page tables may be placed in hardware, unless <BR>
it is placed in a manner that can be overridden by PALcode. <BR>
<P>
<B>° </B>Process structure. Different operating systems might want to replace the process con-text switch routines. The replacement routines will use different data structures. The <BR>
<P>
HWPCB or PCB will not be present in these systems. Therefore, no portion of the con-text <BR>
switching flows that would change with a change in process structure may be <BR>
placed in hardware. <BR>
<P>
PALcode can be viewed as consisting of the following somewhat intertwined components: <BR>
<B>° </B>Chip/ architecture component <BR>
<B>° </B>Hardware platform component <BR>
<B>° </B>Operating system component 
245
<BR>
<A href=#page245>245</A>
<strong><A name=page246> Page 246</A></strong>
<A href=#page247>247</A>
<BR>
<P>
<B>6– 4 </B>Alpha Architecture Handbook <BR>
PALcode should be written modularly to facilitate the easy replacement or conditional build-ing <BR>
of each component. Such a practice simplifies the integration of CPU hardware, system <BR>
platform hardware, console firmware, operating system software, and compilers. <BR>
<P>
PALcode subsections that are commonly subject to modification include: <BR>
<B>° </B>Translation Buffer fill <BR>
<B>° </B>Process structure and context switch <BR>
<B>° </B>Interrupt and exception frame format and routine dispatch <BR>
<B>° </B>Privileged PALcode instructions <BR>
<B>° </B>Transitions to and from console I/ O mode <BR>
<B>° </B>Power-up reset <BR>
<P>
<B>6.7 Required PALcode Instructions <BR>
</B>The PALcode instructions listed in <A href="#page246">Table 6– 1 </A>
and <A href="#page322">Section C. 11 </A>
must be recognized by mne-monic <BR>
and opcode in all operating system implementations, but the effect of each instruction is <BR>
dependent on the implementation. Compaq defines the operation of these PALcode instruc-tions <BR>
for operating system implementations supplied by Compaq. <BR>
<P>
<B>Table 6– 1: PALcode Instructions that Require Recognition <BR>
Mnemonic Name <BR>
</B>BPT Breakpoint trap <BR>
BUGCHK Bugcheck trap <BR>
CSERVE Console service <BR>
GENTRAP Generate trap <BR>
RDUNIQUE Read unique value <BR>
SWPPAL Swap PALcode <BR>
WRUNIQUE Write unique value 
246
<BR>
<A href=#page246>246</A>
<strong><A name=page247> Page 247</A></strong>
<A href=#page248>248</A>
<BR>
<P>
Common PALcode Architecture <B>6– 5 <BR>
</B>The PALcode instructions listed in <A href="#page247">Table 6– 2 </A>
and described in the following sections must be <BR>
supported by all Alpha implementations: <BR>
<P>
<B>Table 6– 2: Required PALcode Instructions <BR>
Mnemonic Type Operation <BR>
</B>DRAINA Privileged Drain aborts <BR>
HALT Privileged Halt processor <BR>
IMB Unprivileged I-stream memory barrier 
247
<BR>
<A href=#page247>247</A>
<strong><A name=page248> Page 248</A></strong>
<A href=#page249>249</A>
<BR>
<B>6– 6 </B>Alpha Architecture Handbook <BR>
<B>6. 7.1 Drain Aborts <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>IF PS&lt; literal&gt;(&lt;) CM&gt; NE 0 THEN <BR>
{privileged instruction exception} <BR>
</TT><P>
<TT>{Stall instruction issuing until all prior <BR>
instructions are guaranteed to complete <BR>
without incurring aborts.} <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Description: <BR>
</B>If aborts are deliberately generated and handled (such as nonexistent memory aborts while siz-ing <BR>
memory or searching for I/ O devices), the DRAINA instruction forces any outstanding <BR>
aborts to be taken before continuing. <BR>
<P>
Aborts are necessarily implementation dependent. DRAINA stalls instruction issue at least <BR>
until all previously issued instructions have completed and any associated aborts have been <BR>
signaled, as follows: <BR>
<P>
<B>° </B>For operate instructions, this usually means stalling until the result register has been written. <BR>
<P>
<B>° </B>For branch instructions, this usually means stalling until the result register and PC have been written. <BR>
<B>° </B>For load instructions, this usually means stalling until the result register has been writ-ten. <BR>
<B>° </B>For store instructions, this usually means stalling until at least the first level in a poten-tially multilevel memory hierarchy has been written. <BR>
For load instructions, DRAINA does not necessarily guarantee that the unaccessed portions of <BR>
a cache block have been transferred error free before continuing. <BR>
<P>
For store instructions, DRAINA does not necessarily guarantee that the ultimate target loca-tion <BR>
of the store has received error-free data before continuing. An implementation-specific <BR>
technique must be used to guarantee the ultimate completion of a write in implementations that <BR>
have multilevel memory hierarchies or store-and-forward bus adapters. <BR>
<P>
CALL_ PAL DRAINA !PALcode format <BR>
Privileged Instruction <BR>
CALL_ PAL DRAINA Drain Aborts 
248
<BR>
<A href=#page248>248</A>
<strong><A name=page249> Page 249</A></strong>
<A href=#page250>250</A>
<BR>
Common PALcode Architecture <B>6– 7 <BR>
6.7. 2 Halt <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>IF PS&lt; literal&gt;(&lt;) CM&gt; NE 0 THEN <BR>
{privileged instruction exception} <BR>
</TT><P>
<TT>CASE {halt_ action} OF <BR>
! Operating System or Platform dependent choice <BR>
halt: {halt} <BR>
restart/ boot/ halt: {restart/ boot/ halt} <BR>
boot/ halt: {boot/ halt} <BR>
debugger/ halt: {debugger/ halt} <BR>
restart/ halt: {restart/ halt} <BR>
ENDCASE <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Description: <BR>
</B>The HALT instruction stops normal instruction processing and initiates some other operating <BR>
system or platform-specific behavior, depending on the HALT action setting. The choice of <BR>
behavior typically includes the initiation of a restart sequence, a system bootstrap, or entry into <BR>
console mode. See Console Interface (III), Chapter 3, in the <I>Alpha Architecture Reference <BR>
Manual. <BR>
</I><P>
CALL_ PAL HALT !PALcode format <BR>
Privileged Instruction <BR>
CALL_ PAL HALT Halt Processor 
249
<BR>
<A href=#page249>249</A>
<strong><A name=page250> Page 250</A></strong>
<A href=#page251>251</A>
<BR>
<B>6– 8 </B>Alpha Architecture Handbook <BR>
<B>6.7. 3 Instruction Memory Barrier <BR>
Format: <BR>
</B><P>
<B>Operation: <BR>
</B><TT>{Make instruction stream coherent with data stream} <BR>
</TT><P>
<B>Exceptions: <BR>
</B><P>
<B>Instruction mnemonics: <BR>
Description: <BR>
</B>An IMB instruction must be executed after software or I/ O devices write into the instruction <BR>
stream or modify the instruction stream virtual address mapping, and before the new value is <BR>
fetched as an instruction. An implementation may contain an instruction cache that does not <BR>
track either processor or I/ O writes into the instruction stream. The instruction cache and mem-ory <BR>
are made coherent by an IMB instruction. <BR>
<P>
If the instruction stream is modified and an IMB is not executed before fetching an instruction <BR>
from the modified location, it is UNPREDICTABLE whether the old or new value is fetched. <BR>
<P>
<B>Software Note: <BR>
</B>In a multiprocessor environment, executing an IMB on one processor does not affect <BR>
instruction caches on other processors. Thus, a single IMB on one processor is <BR>
insufficient to guarantee that all processors see a modification of the instruction stream. <BR>
<P>
The cache coherency and sharing rules are described in Console Interface (III), Chapter 2, in <BR>
the <I>Alpha Architecture Reference Manual. <BR>
</I><P>
CALL_ PAL IMB !PALcode format <BR>
None <BR>
CALL_ PAL IMB I-stream Memory Barrier 
250
<BR>
<A href=#page250>250</A>
<strong><A name=page251> Page 251</A></strong>
<A href=#page252>252</A>
<BR>
Console Subsystem Overview <B>7– 1 <BR>
Chapter 7 <BR>
Console Subsystem Overview <BR>
</B><P>
On an Alpha system, underlying control of the system platform hardware is provided by a <I>con-sole <BR>
subsystem. </I>The console subsystem: <BR>
<P>
<B>° </B>Initializes, tests, and prepares the system platform hardware for Alpha system software. <BR>
<B>° </B>Bootstraps (loads into memory and starts the execution of) system software. <BR>
<B>° </B>Controls and monitors the state and state transitions of each processor in a multiproces-sor system. <BR>
<P>
<B>° </B>Provides services to system software that simplify system software control of and access to platform hardware. <BR>
<B>° </B>Provides a means for a <I>console operator </I>to monitor and control the system. <BR>
The console subsystem interacts with system platform hardware to accomplish the first three <BR>
tasks. The actual mechanisms of these interactions are specific to the platform hardware; how-ever, <BR>
the net effects are common to all systems. <BR>
<P>
The console subsystem interacts with system software once control of the system platform <BR>
hardware has been transferred to that software. <BR>
<P>
The console subsystem interacts with the console operator through a virtual display device or <BR>
<I>console terminal. </I>The console operator may be a person or a management application. 
251
<BR>
<A href=#page251>251</A>
<strong><A name=page252> Page 252</A></strong>
<A href=#page253>253</A>
<BR>

252
<BR>
<A href=#page252>252</A>
<strong><A name=page253> Page 253</A></strong>
<A href=#page254>254</A>
<BR>
<P>
<B>Chapter 8 <BR>
Input/ Output Overview <BR>
</B><P>
Conceptually, Alpha systems can consist of processors, memory, a processor-memory inter-connect <BR>
(PMI), I/ O buses, bridges, and I/ O devices. <BR>
<P>
<A href="#page253">Figure 8– 1 </A>
shows the Alpha system overview. <BR>
<P>
<B>Figure 8– 1: Alpha System Overview <BR>
</B><P>
As shown in <A href="#page253">Figure 8– 1, </A>
processors, memory, and possibly I/ O devices, are connected by a <BR>
PMI. <BR>
<P>
A bridge connects an I/ O bus to the system, either directly to the PMI or through another I/ O <BR>
bus. The I/ O bus address space is available to the processor either directly or indirectly. Indi-rect <BR>
access is provided through either an I/ O mailbox or an I/ O mapping mechanism. The I/ O <BR>
mapping mechanism includes provisions for mapping between PMI and I/ O bus addresses and <BR>
access to I/ O bus operations. <BR>
<P>
Alpha I/ O operations can include: <BR>
<B>° </B>Accesses between the processor and an I/ O device across the PMI <BR>
<B>° </B>Accesses between the processor and an I/ O device across an I/ O bus <BR>
<B>° </B>DMA accesses — I/ O devices initiating reads and writes to memory <BR>
<B>° </B>Processor interrupts requested by devices <BR>
<B>° </B>Bus-specific I/ O accesses <BR>
<P>
Processor-Memory Interconnect <BR>
I/ O Device Processor Memory <BR>
I/ O Bus <BR>
<P>
I/ O Device I/ O Device <BR>
<P>
Bridge 
253
<BR>
<A href=#page253>253</A>
<strong><A name=page254> Page 254</A></strong>
<A href=#page255>255</A>
<BR>

254
<BR>
<A href=#page254>254</A>
<strong><A name=page255> Page 255</A></strong>
<A href=#page256>256</A>
<BR>
<P>
<B>9– 1 <BR>
Chapter 9 <BR>
OpenVMS Alpha <BR>
</B>The following sections specify the Privileged Architecture Library (PALcode) instructions, that are <BR>
required to support an OpenVMS Alpha system. <BR>
<P>
<B>9. 1 Unprivileged OpenVMS Alpha PALcode <BR>
</B>The unprivileged PALcode instructions provide support for system operations to all modes of opera-tion <BR>
(kernel, executive, supervisor, and user). <BR>
<P>
<A href="#page255">Table 9– 1 </A>
describes the unprivileged OpenVMS Alpha PALcode instructions. <BR>
<B>Table 9– 1 : Unprivileged OpenVMS Alpha PALcode Instruction Summary <BR>
</B>Mnemonic <B>Operation and Description <BR>
</B>BPT Breakpoint <BR>
<P>
The BPT instruction is provided for program debugging. It switches the pro-cessor <BR>
to kernel mode and pushes R2.. R7, the updated PC, and PS on the ker-nel <BR>
stack. It then dispatches to the address in the Breakpoint vector, stored in a <BR>
control block. <BR>
<P>
BUGCHK Bugcheck <BR>
<P>
The BUGCHK instruction is provided for error reporting. It switches the pro-cessor <BR>
to kernel mode and pushes R2.. R7, the updated PC, and PS on the ker-nel <BR>
stack. It then dispatches to the address in the bugcheck vector, stored in a <BR>
control block. The value in R16 specifies the particular bugcheck type. 
255
<BR>
<A href=#page255>255</A>
<strong><A name=page256> Page 256</A></strong>
<A href=#page257>257</A>
<BR>
<B>9– 2 </B>Alpha Architecture Handbook <BR>
CHME Change mode to executive <BR>
The CHME instruction allows a process to change its mode in a controlled <BR>
manner. A change in mode also results in a change of stack pointers: the old <BR>
pointer is saved, the new pointer is loaded. Registers R2.. R7, PS, and PC are <BR>
pushed onto the selected stack. The saved PC addresses the instruction fol-lowing <BR>
the CHME instruction. The value in R16 specifies the particular <BR>
exception type. <BR>
<P>
CHMK Change mode to kernel <BR>
<P>
CHMK allows a process to change its mode to kernel in a controlled manner. <BR>
A change in mode also results in a change of stack pointers: the old pointer is <BR>
saved, the new pointer is loaded. R2.. R7, PS, and PC are pushed onto the ker-nel <BR>
stack. The saved PC addresses the instruction following the CHMK <BR>
instruction. The value in R16 specifies the particular exception type. <BR>
<P>
CHMS Change mode to supervisor <BR>
<P>
CHMS allows a process to change its mode in a controlled manner. A change <BR>
in mode also results in a change of stack pointers: the old pointer is saved, the <BR>
new pointer is loaded. R2.. R7, PS, and PC are pushed onto the selected stack. <BR>
The saved PC addresses the instruction following the CHMS instruction. The <BR>
value in R16 specifies the particular exception type. <BR>
<P>
CHMU Change mode to user <BR>
<P>
CHMU allows a process to call a routine via the change mode mecha-nism. <BR>
R2.. R7, PS, and PC are pushed onto the current stack. The saved PC <BR>
addresses the instruction following the CHMU instruction. The value in R16 <BR>
specifies the particular exception type. <BR>
<P>
CLRFEN Clear floating-point enable <BR>
<P>
CLRFEN writes a zero to the floating-point enable register. <BR>
GENTRAP Generate trap <BR>
<P>
GENTRAP is provided for reporting runtime software conditions. It switches <BR>
the processor to kernel mode and pushes registers R2.. R7, the updated PC, <BR>
and the PS on the kernel stack. It then dispatches to the address of the GEN-TRAP <BR>
vector, stored in a control block. <BR>
<P>
<B>Table 9– 1 : Unprivileged OpenVMS Alpha PALcode Instruction Summary (Continued) <BR>
</B>Mnemonic <B>Operation and Description </B>
256
<BR>
<A href=#page256>256</A>
<strong><A name=page257> Page 257</A></strong>
<A href=#page258>258</A>
<BR>
<B>9– 3 <BR>
</B>IMB I-Stream memory barrier <BR>
IMB ensures that the contents of an instruction cache are coherent after the <BR>
instruction stream has been modified by software or I/ O devices. If the instruc-tion <BR>
stream is modified and an IMB is not executed before fetching an instruc-tion <BR>
from the modified location, it is UNPREDICTABLE whether the old or <BR>
new value is fetched. <BR>
<P>
INSQHIL Insert into longword queue at header, interlocked <BR>
<P>
The entry specified in R17 is inserted into the self-relative queue following <BR>
the header specified in R16. The insertion is a noninterruptible operation. <BR>
The insertion is interlocked to prevent concurrent interlocked insertions or <BR>
removals at the head or tail of the same queue by another process, in a multi-processor <BR>
environment. <BR>
<P>
INSQHILR Insert into longword queue at header, interlocked resident <BR>
<P>
The entry specified in R17 is inserted into the self-relative queue following <BR>
the header specified in R16. The insertion is a noninterruptible operation. <BR>
The insertion is interlocked to prevent concurrent interlocked insertions or <BR>
removals at the head or tail of the same queue by another process, in a multi-processor <BR>
environment. This instruction requires that the queue be memory-resident <BR>
and that the queue header and elements are quadword-aligned. <BR>
<P>
INSQHIQ Insert into quadword queue at header, interlocked <BR>
<P>
The entry specified in R17 is inserted into the self-relative queue following <BR>
the header specified in R16. The insertion is a noninterruptible operation. <BR>
The insertion is interlocked to prevent concurrent interlocked insertions or <BR>
removals at the head or tail of the same queue by another process, in a multi-processor <BR>
environment. <BR>
<P>
INSQHIQR Insert into quadword queue at header, interlocked resident <BR>
<P>
The entry specified in R17 is inserted into the self-relative queue following <BR>
the header specified in R16. The insertion is a noninterruptible operation. <BR>
The insertion is interlocked to prevent concurrent interlocked insertions or <BR>
removals at the head or tail of the same queue by another process, in a multi-processor <BR>
environment. This instruction requires that the queue be memory-resident <BR>
and that the queue header and elements are octaword-aligned. <BR>
<P>
INSQTIL Insert into longword queue at tail, interlocked <BR>
<P>
The entry specified in R17 is inserted into the self-relative queue preceding <BR>
the header specified in R16. The insertion is a noninterruptible operation. <BR>
The insertion is interlocked to prevent concurrent interlocked insertions or <BR>
removals at the head or tail of the same queue by another process, in a multi-processor <BR>
environment. <BR>
<P>
<B>Table 9– 1 : Unprivileged OpenVMS Alpha PALcode Instruction Summary (Continued) <BR>
</B>Mnemonic <B>Operation and Description </B>
257
<BR>
<A href=#page257>257</A>
<strong><A name=page258> Page 258</A></strong>
<A href=#page259>259</A>
<BR>
<B>9– 4 </B>Alpha Architecture Handbook <BR>
INSQTILR Insert into longword queue at tail, interlocked resident <BR>
The entry specified in R17 is inserted into the self-relative queue preceding <BR>
the header specified in R16. The insertion is a noninterruptible operation. <BR>
The insertion is interlocked to prevent concurrent interlocked insertions or <BR>
removals at the head or tail of the same queue by another process, in a multi-processor <BR>
environment. This instruction requires that the queue be memory-resident <BR>
and that the queue header and elements are quadword-aligned. <BR>
<P>
INSQTIQ Insert into quadword queue at tail, interlocked <BR>
<P>
The entry specified in R17 is inserted into the self-relative queue preceding <BR>
the header specified in R16. The insertion is a noninterruptible operation. <BR>
The insertion is interlocked to prevent concurrent interlocked insertions or <BR>
removals at the head or tail of the same queue by another process, in a multi-processor <BR>
environment. <BR>
<P>
INSQTIQR Insert into quadword queue at tail, interlocked resident <BR>
<P>
The entry specified in R17 is inserted into the self-relative queue preceding <BR>
the header specified in R16. The insertion is a noninterruptible operation. <BR>
The insertion is interlocked to prevent concurrent interlocked insertions or <BR>
removals at the head or tail of the same queue by another process, in a multi-processor <BR>
environment. This instruction requires that the queue be memory-resident <BR>
and that the queue header and elements are octaword-aligned. <BR>
<P>
INSQUEL Insert into longword queue <BR>
<P>
The entry specified in R17 is inserted into the absolute queue following the <BR>
entry specified by the predecessor addressed by R16 for INSQUEL, or fol-lowing <BR>
the entry specified by the contents of the longword addressed by R16 <BR>
for INSQUEL/ D. The insertion is a noninterruptible operation. <BR>
<P>
INSQUEQ Insert into quadword queue <BR>
<P>
The entry specified in R17 is inserted into the absolute queue following the <BR>
entry specified by the predecessor addressed by R16 for INSQUEQ, or fol-lowing <BR>
the entry specified by the contents of the quadword addressed by R16 <BR>
for INSQUEQ/ D. The insertion is a noninterruptible operation. <BR>
<P>
PROBE Probe read/ write access <BR>
<P>
PROBE checks the read (PROBER) or write (PROBEW) accessibility of the <BR>
first and last byte specified by the base address and the signed offset; the bytes <BR>
in between are not checked. System software must check all pages between <BR>
the two bytes if they are to be accessed. &lt;p&gt; PROBE is only intended to check <BR>
a single datum for accessibility. <BR>
<P>
<B>Table 9– 1 : Unprivileged OpenVMS Alpha PALcode Instruction Summary (Continued) <BR>
</B>Mnemonic <B>Operation and Description </B>
258
<BR>
<A href=#page258>258</A>
<strong><A name=page259> Page 259</A></strong>
<A href=#page260>260</A>
<BR>
<B>9– 5 <BR>
</B>RD_ PS Read processor status <BR>
RD_ PS writes the Processor Status (PS) to register R0. <BR>
READ_ UNQ Read unique context <BR>
<P>
READ_ UNQ reads the hardware process (thread) unique context value, if <BR>
previously written by WRITE_ UNQ, and places that value in R0. <BR>
<P>
REI Return from exception or interrupt <BR>
<P>
The PS, PC, and saved R2.. R7 are popped from the current stack and held in <BR>
temporary registers. The new PS is checked for validity and consistency. If it <BR>
is valid and consistent, the current stack pointer is then saved and a new stack <BR>
pointer is selected. Registers R2 through R7 are restored by using the saved <BR>
values held in the temporary registers. A check is made to determine if an <BR>
AST or interrupt is pending. If the enabling conditions are present for an inter-rupt <BR>
or AST at the completion of this instruction, the interrupt or AST occurs <BR>
before the next instruction. <BR>
<P>
REMQHIL Remove from longword queue at header, interlocked <BR>
<P>
The self-relative queue entry following the header, pointed to by R16, is <BR>
removed from the queue, and the address of the removed entry is returned in <BR>
R1. The removal is interlocked to prevent concurrent interlocked insertions or <BR>
removals at the head or tail of the same queue by another process, in a multi-processor <BR>
environment. The removal is a noninterruptible operation. <BR>
<P>
REMQHILR Remove from longword queue at header, interlocked resident <BR>
<P>
The queue entry following the header, pointed to by R16, is removed from the <BR>
self-relative queue, and the address of the removed entry is returned in R1. <BR>
The removal is interlocked to prevent concurrent interlocked insertions or <BR>
removals at the head or tail of the same queue by another process, in a multi-processor <BR>
environment. The removal is a noninterruptible operation. This <BR>
instruction requires that the queue be memory-resident and that the queue <BR>
header and elements are quadword-aligned. <BR>
<P>
REMQHIQ Remove from quadword queue at header, interlocked <BR>
<P>
The self-relative queue entry following the header, pointed to by R16, is <BR>
removed from the queue and the address of the removed entry is returned in <BR>
R1. The removal is interlocked to prevent concurrent interlocked insertions or <BR>
removals at the head or tail of the same queue by another process, in a multi-processor <BR>
environment. The removal is a noninterruptible operation. <BR>
<P>
<B>Table 9– 1 : Unprivileged OpenVMS Alpha PALcode Instruction Summary (Continued) <BR>
</B>Mnemonic <B>Operation and Description </B>
259
<BR>
<A href=#page259>259</A>
<strong><A name=page260> Page 260</A></strong>
<A href=#page261>261</A>
<BR>
<B>9– 6 </B>Alpha Architecture Handbook <BR>
REMQHIQR Remove from quadword queue at header, interlocked resident <BR>
The queue entry following the header, pointed to by R16, is removed from the <BR>
self-relative queue and the address of the removed entry is returned in R1. The <BR>
removal is interlocked to prevent concurrent interlocked insertions or remov-als <BR>
at the head or tail of the same queue by another process, in a multiproces-sor <BR>
environment. The removal is a noninterruptible operation. This instruction <BR>
requires that the queue be memory-resident and that the queue header and ele-ments <BR>
are octaword-aligned. <BR>
<P>
REMQTIL Remove from longword queue at tail, interlocked <BR>
<P>
The queue entry preceding the header, pointed to by R16, is removed from the <BR>
self-relative queue and the address of the removed entry is returned in R1. The <BR>
removal is interlocked to prevent concurrent interlocked insertions or remov-als <BR>
at the head or tail of the same queue by another process, in a multiproces-sor <BR>
environment. The removal is a noninterruptible operation. <BR>
<P>
REMQTILR Remove from longword queue at tail, interlocked resident <BR>
<P>
The queue entry preceding the header, pointed to by R16, is removed from the <BR>
self-relative queue and the address of the removed entry is returned in R1. The <BR>
removal is interlocked to prevent concurrent interlocked insertions or remov-als <BR>
at the head or tail of the same queue by another process, in a multiproces-sor <BR>
environment. The removal is a noninterruptible operation. This instruction <BR>
requires that the queue be memory-resident and that the queue header and ele-ments <BR>
are quadword-aligned. <BR>
<P>
REMQTIQ Remove from quadword queue at tail, interlocked <BR>
<P>
The self-relative queue entry preceding the header, pointed to by R16, is <BR>
removed from the queue and the address of the removed entry is returned in <BR>
R1. The removal is interlocked to prevent concurrent interlocked insertions or <BR>
removals at the head or tail of the same queue by another process, in a multi-processor <BR>
environment. The removal is a noninterruptible operation. <BR>
<P>
REMQTIQR Remove from quadword queue at tail, interlocked resident <BR>
<P>
The queue entry preceding the header, pointed to by R16, is removed from the <BR>
self-relative queue and the address of the removed entry is returned in R1. The <BR>
removal is interlocked to prevent concurrent interlocked insertions or remov-als <BR>
at the head or tail of the same queue by another process, in a multiproces-sor <BR>
environment. The removal is a noninterruptible operation. This instruction <BR>
requires that the queue be memory-resident and that the queue header and ele-ments <BR>
are octaword-aligned. <BR>
<P>
<B>Table 9– 1 : Unprivileged OpenVMS Alpha PALcode Instruction Summary (Continued) <BR>
</B>Mnemonic <B>Operation and Description </B>
260
<BR>
<A href=#page260>260</A>
<strong><A name=page261> Page 261</A></strong>
<A href=#page262>262</A>
<BR>
<B>9– 7 <BR>
</B>REMQUEL Remove from longword queue <BR>
The queue entry addressed by R16 for REMQUEL or the entry addressed by <BR>
the longword addressed by R16 for REMQUEL/ D is removed from the long-word <BR>
absolute queue, and the address of the removed entry is returned in R1. <BR>
The removal is a noninterruptible operation. <BR>
<P>
REMQUEQ Remove from quadword queue <BR>
<P>
The queue entry addressed by R16 for REMQUEQ or the entry addressed by <BR>
the quadword addressed by R16 for REMQUEL/ D is removed from the quad-word <BR>
absolute queue, and the address of the removed entry removed is <BR>
returned in R1. The removal is a noninterruptible operation. <BR>
<P>
RSCC Read system cycle counter <BR>
<P>
Register R0 is written with the value of the system cycle counter. This counter <BR>
is an unsigned 64-bit integer that increments at the same rate as the process <BR>
cycle counter. The system cycle counter is suitable for timing a general range <BR>
of intervals to within 10% error and may be used for detailed performance <BR>
characterization. <BR>
<P>
SWASTEN Swap AST enable <BR>
<P>
SWASTEN swaps the AST enable bit for the current mode. The new state for <BR>
the enable bit is supplied in register R16&lt; 0&gt; and previous state of the enable <BR>
bit is returned, zero-extended, in R0. A check is made to determine if an AST <BR>
is pending. If the enabling conditions are present for an AST at the completion <BR>
of this instruction, the AST occurs before the next instruction. <BR>
<P>
WRITE_ UNQ Write unique context <BR>
<P>
WRITE_ UNQ writes the hardware process (thread) unique context value <BR>
passed in R16 to internal storage or to the hardware privileged context block. <BR>
<P>
WR_ PS_ SW Write processor status software field <BR>
<P>
WR_ PS_ SW writes the Processor Status software field (PS&lt; SW&gt;) with the <BR>
low-order three bits of R16&lt; 2: 0&gt;. <BR>
<P>
<B>Table 9– 1 : Unprivileged OpenVMS Alpha PALcode Instruction Summary (Continued) <BR>
</B>Mnemonic <B>Operation and Description </B>
261
<BR>
<A href=#page261>261</A>
<strong><A name=page262> Page 262</A></strong>
<A href=#page263>263</A>
<BR>
<P>
<B>9– 8 </B>Alpha Architecture Handbook <BR>
<B>9. 2 Privileged OpenVMS Alpha Palcode <BR>
</B>The privileged PALcode instructions can be called in kernel mode only. <BR>
<A href="#page262">Table 9– 2 </A>
describes the privileged OpenVMS Alpha PALcode instructions. <BR>
<B>Table 9– 2 : Privileged OpenVMS Alpha PALcode Instructions Summary <BR>
Mnemonic Operation and Description <BR>
</B>CFLUSH Cache flush <BR>
<P>
At least the entire physical page specified by a page frame number in R16 is <BR>
flushed from any data caches associated with the current processor. After doing <BR>
a CFLUSH, the first subsequent load on the same processor to an arbitrary <BR>
address in the target page is fetched from physical memory. <BR>
<P>
CSERVE Console service <BR>
<P>
CSERVE is specific to each PALcode and console implementation and is not <BR>
intended for operating system use. <BR>
<P>
DRAINA Drain aborts <BR>
<P>
DRAINA stalls instruction issuing until all prior instructions are guaranteed to <BR>
complete without incurring aborts. <BR>
<P>
HALT Halt processor <BR>
<P>
HALT stops normal instruction processing. <BR>
LDQP Load quadword physical <BR>
<P>
The quadword-aligned memory operand, whose physical address is in R16, is <BR>
fetched and written to R0. If the operand address in R16 is not quadword-aligned, <BR>
the result is UNPREDICTABLE. <BR>
<P>
MFPR Move from processor register <BR>
<P>
The internal processor register specified by the PALcode function field is writ-ten <BR>
to R0. <BR>
<P>
MTPR Move to processor register <BR>
<P>
The source operands in integer registers R16 (and R17, reserved for future use) <BR>
are written to the internal processor register specified by the PALcode function <BR>
field. The effect of loading a processor register is guaranteed to be active on the <BR>
next instruction. 
262
<BR>
<A href=#page262>262</A>
<strong><A name=page263> Page 263</A></strong>
<A href=#page264>264</A>
<BR>
<B>9– 9 <BR>
</B>STQP Store quadword physical <BR>
The quadword contents of R17 are written to the memory location whose phys-ical <BR>
address is in R16. If the operand address in R16 is not quadword-aligned, <BR>
the result is UNPREDICTABLE. <BR>
<P>
SWPCTX Swap privileged context <BR>
<P>
SWPCTX returns ownership of the data structure that contains the current <BR>
hardware privileged context (the HWPCB) to the operating system and passes <BR>
ownership of the new HWPCB to the processor. <BR>
<P>
SWPPAL Swap PALcode image <BR>
<P>
SWPPAL causes the current PALcode to be replaced by the specified new <BR>
PALcode image. Intended for use by operating systems only during bootstraps <BR>
and by consoles during transitions to console I/ O mode. <BR>
<P>
WTINT Wait for interrupt <BR>
<P>
WTINT requests that, if possible, the PALcode wait for the first of either of the <BR>
following conditions before returning: any interrupt other than a clock tick; or, <BR>
the first clock tick after a specified number of clock ticks has been skipped. <BR>
<P>
<B>Table 9– 2 : Privileged OpenVMS Alpha PALcode Instructions Summary (Continued) <BR>
Mnemonic Operation and Description </B>
263
<BR>
<A href=#page263>263</A>
<strong><A name=page264> Page 264</A></strong>
<A href=#page265>265</A>
<BR>

264
<BR>
<A href=#page264>264</A>
<strong><A name=page265> Page 265</A></strong>
<A href=#page266>266</A>
<BR>
<P>
<B>10– 1 <BR>
Chapter 10 <BR>
Digital UNIX <BR>
</B><P>
The following sections specifiy the Privileged Architecture Library (PALcode) instructions that are <BR>
required to support a Digital UNIX system. <BR>
<P>
<B>10. 1 Unprivileged Digital UNIX PALcode <BR>
<A href="#page265">Table 10– 1 </A>
describes the unprivileged Digital UNIX PALcode instructions. <BR>
<B>Table 10– 1 : Unprivileged Digital UNIX PALcode Instruction Summary <BR>
Mnemonic Operation and Description <BR>
</B>bpt Break point trap <BR>
<P>
The bpt instruction switches mode to kernel, builds a stack frame on the kernel <BR>
stack, and dispatches to the breakpoint code. <BR>
<P>
bugchk Bugcheck <BR>
<P>
The bugchk instruction switches mode to kernel, builds a stack frame on the <BR>
kernel stack, and dispatches to the breakpoint code. <BR>
<P>
callsys System call <BR>
<P>
The callsys instruction switches mode to kernel, builds a callsys stack frame, <BR>
and dispatches to the system call code. <BR>
<P>
clrfen Clear floating-point enable <BR>
<P>
The clrfen instruction writes a zero to the floating-point enable register. <BR>
gentrap Generate trap <BR>
<P>
The gentrap instruction switches mode to kernel, builds a stack frame on the <BR>
kernel stack, and dispatches to the gentrap code. <BR>
<P>
imb I-stream memory barrier <BR>
<P>
The imb instruction makes the I-cache coherent with main memory. 
265
<BR>
<A href=#page265>265</A>
<strong><A name=page266> Page 266</A></strong>
<A href=#page267>267</A>
<BR>
<P>
<B>10– 2 </B>Alpha Architecture Handbook <BR>
<B>10. 2 Privileged Digital UNIX PALcode <BR>
</B>The privileged PALcode instructions can be called only from kernel mode. They provide an interface <BR>
to control the privileged state of the machine. <BR>
<P>
<A href="#page266">Table 10– 2 </A>
describes the privileged Digital UNIX PALcode instructions. <BR>
<P>
rdunique Read unique <BR>
The rdunique instruction returns the process unique value. <BR>
urti Return from user mode trap <BR>
<P>
The urti instruction pops from the user stack the registers a0 through a2, the <BR>
global pointer, the new user assembler temporary register, the stack pointer, the <BR>
program counter, and the processor status register. <BR>
<P>
wrunique Write unique <BR>
<P>
The wrunique instruction sets the process unique register. <BR>
<P>
<B>Table 10– 2 : Privileged Digital UNIX PALcode Instruction Summary <BR>
Mnemonic Operation and Description <BR>
</B>cflush Cache flush The cflush instruction flushes an entire physical page pointed to by <BR>
the specified page frame number (PFN) from any data caches associated with <BR>
the current processor. All processors must implement this instruction. <BR>
<P>
cserve Console service This instruction is specific to each PALcode and console <BR>
implementation and is not intended for operating system use. <BR>
<P>
draina Drain aborts The draina instruction stalls instruction issuing until all prior <BR>
instructions are guaranteed to complete without incurring aborts. <BR>
<P>
halt Halt processor The halt instruction stops normal instruction processing. <BR>
Depending on the halt action setting, the processor can either enter console <BR>
mode or the restart sequence. <BR>
<P>
rdmces Read machine check error summary The rdmces instruction returns the MCES <BR>
register in v0. <BR>
<P>
rdps Read processor status The rdps instruction returns the current PS. <BR>
rdusp Read user stack pointer The rdusp instruction reads the user stack pointer while <BR>
in kernel mode and returns it. <BR>
<P>
rdval Read system value The rdval instruction reads a 64-bit per-processor value and <BR>
returns it. <BR>
<P>
<B>Table 10– 1 : Unprivileged Digital UNIX PALcode Instruction Summary (Continued) <BR>
Mnemonic Operation and Description </B>
266
<BR>
<A href=#page266>266</A>
<strong><A name=page267> Page 267</A></strong>
<A href=#page268>268</A>
<BR>
<B>10– 3 <BR>
</B>retsys Return from system call The retsys instruction pops the return address, the user <BR>
stack pointer, and the user global pointer from the kernel stack. It then saves the <BR>
kernel stack pointer, sets mode to user, enables interrupts, and jumps to the <BR>
address popped off the stack. <BR>
<P>
rti Return from trap, fault or interrupt The rti instruction pops certain registers <BR>
from the kernel stack. If the new mode is user, the kernel stack is saved and the <BR>
user stack restored. <BR>
<P>
swpctx Swap privileged context The swpctx instruction saves the current process data <BR>
in the current process control block (PCB). Then swpctx switches to the PCB <BR>
and loads the new process context. <BR>
<P>
swpipl Swap IPL The swpipl instruction returns the current value IPL and sets the IPL. <BR>
swppal Swap PALcode image The swppal instruction causes the current PALcode to <BR>
be replaced by the specified new PALcode image. Intended only for use by <BR>
operating systems during bootstraps and by consoles during transitions to con-sole <BR>
I/ O mode. <BR>
<P>
tbi TB invalidate The tbi instruction removes entries from the instruction and data <BR>
translation buffers when the mapping entries change. <BR>
<P>
whami Who_ Am_ I The whami instruction returns the processor number for the cur-rent <BR>
processor. The processor number is in the range 0 to the number of proces-sors <BR>
minus one (0.. numproc– 1) that can be configured in the system. <BR>
<P>
wrent Write system entry address The wrent instruction sets the virtual address of the <BR>
system entry points. <BR>
<P>
wrfen Write floating-point enable The wrfen instruction writes a bit to the floating-point <BR>
enable register. <BR>
<P>
wripir Write interprocessor interrupt request The wripr instruction generates an inter-processor <BR>
interrupt on the processor number passed as an input parameter. The <BR>
interrupt request is recorded on the target processor and initiated when the <BR>
proper enabling conditions are present. <BR>
<P>
wrkgp Write kernel global pointer The wrkgp instruction writes the kernel global <BR>
pointer internal register. <BR>
<P>
wrmces Write machine check error summary The wrmces instructions clears the <BR>
machine check in progress bit and clears the processor-or system-correctable <BR>
error in progress bit in the MCES register. The instruction also sets or clears the <BR>
processor-or system-correctable error reporting enable bit in the MCES regis-ter. <BR>
<P>
wrperfmon Performance monitoring function The wrperfmon instruction alerts any perfor-mance <BR>
monitoring software/ hardware in the system to monitor the performance <BR>
of this process. <BR>
<P>
wrusp Write user stack pointer The wrusp instruction writes a value to the user stack <BR>
pointer while in kernel mode. <BR>
<P>
<B>Table 10– 2 : Privileged Digital UNIX PALcode Instruction Summary (Continued) <BR>
Mnemonic Operation and Description </B>
267
<BR>
<A href=#page267>267</A>
<strong><A name=page268> Page 268</A></strong>
<A href=#page269>269</A>
<BR>
<B>10– 4 </B>Alpha Architecture Handbook <BR>
wrval Write system value The wrval instruction writes a 64-bit per-processor value. <BR>
wrvptptr Write virtual page table pointer The wrvptptr instruction writes a pointer to the <BR>
virtual page table pointer (vptptr). <BR>
<P>
wtint Wait for interrupt The wtint instruction requests that, if possible, the PALcode <BR>
wait for the first of either of the following conditions before returning: any <BR>
interrupt other than a clock tick; or, the first clock tick after a specified number <BR>
of clock ticks has been skipped. <BR>
<P>
<B>Table 10– 2 : Privileged Digital UNIX PALcode Instruction Summary (Continued) <BR>
Mnemonic Operation and Description </B>
268
<BR>
<A href=#page268>268</A>
<strong><A name=page269> Page 269</A></strong>
<A href=#page270>270</A>
<BR>
<B>11– 1 <BR>
Chapter 11 <BR>
Windows NT Alpha <BR>
</B><P>
The following sections specify the Privileged Architecture Library (PALcode) instructions that are <BR>
required to support a Windows NT Alpha system. <BR>
<P>
<B>11. 1 Unprivileged Windows NT Alpha PALcode <BR>
</B>The unprivileged PALcode instuctions provide support for system operations and may be called from <BR>
both kernel and user modes. <BR>
<P>
<B>Table 11– 1 : Unprivileged Windows NT Alpha PALcode Instruction Summary <BR>
Mnemonic Operation and description <BR>
</B>bpt Breakpoint trap (standard user-mode breakpoint) <BR>
<P>
The bpt instruction raises a breakpoint general exception to the kernel, setting a <BR>
USER_ BREAKPOINT breakpoint type. <BR>
<P>
callkd Call kernel debugger <BR>
<P>
The callkd instruction raises a breakpoint general exception to the kernel, set-ting <BR>
the breakpoint type with the value supplied as an input parameter. <BR>
<P>
callsys System service call <BR>
<P>
The callsys instruction raises a system service call exception to the kernel. Call-sys <BR>
switches to kernel mode if necessary, builds a trap frame on the kernel <BR>
stack, and then enters the kernel at the kernel system service exception handler. <BR>
<P>
gentrap Generate a trap <BR>
<P>
The gentrap instruction generates a software general exception that raises an <BR>
exception code to the current thread. The exception code is generated from a <BR>
trap number that is specified as an input parameter. Gentrap is used to raise <BR>
software-detected exceptions such as bound check errors or overflow condi-tions. 
269
<BR>
<A href=#page269>269</A>
<strong><A name=page270> Page 270</A></strong>
<A href=#page271>271</A>
<BR>
<B>11– 2 </B>Alpha Architecture Handbook <BR>
<B>11. 2 Privileged Windows NT Alpha PALcode <BR>
</B>The privileged PALcode instuctions provide support for system operations and may be called from <BR>
only kernel mode. <BR>
<P>
imb Instruction memory barrier <BR>
The imb instruction guarantees that all subsequent instruction stream fetches <BR>
are coherent with respect to main memory. Imb must be issued before execut-ing <BR>
code in memory that has been modified (either by stores from the processor <BR>
or DMA from an I/ O processor). User-mode code that modifies the I-stream <BR>
must call the appropriate Windows NT API to ensure I-cache coherency. <BR>
<P>
kbpt Kernel breakpoint trap <BR>
<P>
The kbpt instruction raises a breakpoint general exception to the kernel, setting <BR>
a KERNEL_ BREAKPOINT breakpoint type. <BR>
<P>
rdteb Read thread environment block pointer <BR>
<P>
The rdteb instruction returns the contents of the TEB internal processor register <BR>
for the currently executing thread (the base address of the thread environment <BR>
block). <BR>
<P>
<B>Table 11– 2 : Privileged Windows NT Alpha PALcode Instruction Summary <BR>
Mnemonic Operation and description <BR>
</B>csir Clear software interrupt request <BR>
<P>
The csir instruction clears the specified bit in the SIRR internal processor regis-ter. <BR>
<P>
dalnfix Disable alignment fixups <BR>
The dalnfix instruction disables alignment fixups in PALcode and generates <BR>
alignment fault exceptions whenever an alignment fault occurs. After dalnfix is <BR>
executed on a processor, all alignment faults on that processor are not fixed-up <BR>
by PALcode and alignment fault exceptions are dispatched to the kernel until <BR>
the ealnfix instruction is executed on that processor. <BR>
<P>
di Disable all interrupts <BR>
<P>
The di instruction disables all interrupts by clearing the interrupt enable (IE) bit <BR>
in the PSR internal processor register. The IRQL field is unaffected. Interrupts <BR>
may be re-enabled via the ei instruction. <BR>
<P>
<B>Table 11– 1 : Unprivileged Windows NT Alpha PALcode Instruction Summary <BR>
Mnemonic Operation and description </B>
270
<BR>
<A href=#page270>270</A>
<strong><A name=page271> Page 271</A></strong>
<A href=#page272>272</A>
<BR>
<B>11– 3 <BR>
</B>draina Drain all aborts including machine checks <BR>
The draina instruction drains all aborts, including machine checks, from the <BR>
current processor. Draina guarantees that no abort is signaled for an instruction <BR>
issued before the draina while any instruction issued subsequent to the draina is <BR>
executing. <BR>
<P>
dtbis Data translation buffer invalidate single <BR>
<P>
The dtbis instruction invalidates a single data stream translation. The transla-tion <BR>
for the virtual address must be invalidated in all data translation buffers <BR>
and in all virtual data caches. <BR>
<P>
ealnfix Enable alignment fixups <BR>
<P>
The ealnfix instruction enables alignment fixups in PALcode and prevents <BR>
alignment fault exceptions. After ealnfix is executed on a processor, all align-ment <BR>
faults on that processor are fixed-up by PALcode and no alignment fault <BR>
exceptions are dispatched to the kernel until the dalnfix instruction is executed <BR>
on that processor. <BR>
<P>
ei Enable interrupts <BR>
<P>
The ei instruction enables interrupts for the IRQL set in the PSR internal pro-cessor <BR>
register by setting the interrupt enable (IE) bit in the PSR. <BR>
<P>
halt Halt the operating system by forcing illegal instruction trap <BR>
<P>
The halt instruction forces an illegal instruction exception. <BR>
initpal Initialize PALcode data structures with operating system values <BR>
<P>
The initpal instruction is called early in the kernel initialization sequence to <BR>
establish values for internal processor registers (IPRs) that are needed for trap <BR>
and fault handling. The KGP and PCR registers are initialized once and persist <BR>
throughout the run time of the operating system. <BR>
<P>
initpcr Initialize processor control region data <BR>
<P>
The initpcr instruction caches process-specific information, including parts of <BR>
the interrupt level table (ILT), for use by the PALcode. <BR>
<P>
rdcounters Read the software event counters <BR>
<P>
The rdcounters instruction is only used with debug PALcode. With production <BR>
PALcode, rdcounters returns a status value of zero, indicating that it is not <BR>
implemented in the current PALcode image. <BR>
<P>
<B>Table 11– 2 : Privileged Windows NT Alpha PALcode Instruction Summary (Continued) <BR>
Mnemonic Operation and description </B>
271
<BR>
<A href=#page271>271</A>
<strong><A name=page272> Page 272</A></strong>
<A href=#page273>273</A>
<BR>
<B>11– 4 </B>Alpha Architecture Handbook <BR>
rdirql Read the current IRQL from the PSR <BR>
The rdirql instruction returns the contents of the interrupt request level (IRQL) <BR>
field of the PSR internal processor register. <BR>
<P>
rdksp Read initial kernel stack pointer for the current thread <BR>
<P>
The rdksp instruction returns the contents of the IKSP (initial kernel stack <BR>
pointer) internal processor register for the currently executing thread. <BR>
<P>
rdmces Read the machine check error summary register <BR>
<P>
The rdmces instruction returns the contents of the machine check error sum-mary <BR>
(MCES) internal processor register. <BR>
<P>
rdpcr Read the processor control region base address <BR>
<P>
The rdpcr instruction returns the contents of the PCR internal processor register <BR>
(the base address value of the processor control region). <BR>
<P>
rdpsr Read the current processor status register (PSR) <BR>
<P>
The rdpsr instruction returns the contents of the current PSR (Processor Status <BR>
Register) internal processor register. <BR>
<P>
rdstate Read the current internal processor state <BR>
<P>
The rdstate instruction returns the internal processor state to an internal buffer. <BR>
rdthread Read the thread value for the current thread <BR>
<P>
The rdthread instruction returns the contents of the THREAD internal proces-sor <BR>
register (the value of the currently executing thread). <BR>
<P>
reboot Transfer to console firmware <BR>
<P>
The reboot instruction stops the operating system from executing and returns <BR>
execution to the boot environment. Reboot is responsible for completing the <BR>
ARC restart block before returning to the boot environment. <BR>
<P>
restart Restart the operating system from the restart block <BR>
<P>
The restart instruction restores saved processor state and resumes execution of <BR>
the operating system. <BR>
<P>
<B>Table 11– 2 : Privileged Windows NT Alpha PALcode Instruction Summary (Continued) <BR>
Mnemonic Operation and description </B>
272
<BR>
<A href=#page272>272</A>
<strong><A name=page273> Page 273</A></strong>
<A href=#page274>274</A>
<BR>
<B>11– 5 <BR>
</B>retsys Return from system service call exception <BR>
The retsys instruction returns from a system service call exception by unwind-ing <BR>
the trap frame and returning to the code stream that was executing when the <BR>
original exception was initiated. In addition, retsys accepts a parameter to set <BR>
software interrupt requests that became pending while the exception was han-dled. <BR>
<P>
rfe Return from trap or interrupt <BR>
The rfe instruction returns from exceptions by unwinding the trap frame and <BR>
returning to the code stream that was executing when the original exception <BR>
was initiated. In addition, rfe accepts a parameter to set software interrupt <BR>
requests that became pending while the exception was handled. <BR>
<P>
ssir Set software interrupt request <BR>
<P>
The ssir instruction sets software interrupt requests by setting the appropriate <BR>
bits in the SIRR internal processor register. <BR>
<P>
swpctx Swap thread context <BR>
<P>
The swpctx instruction swaps the privileged portions of thread context. Thread <BR>
context is swapped by establishing the new IKSP, THREAD, and TEB internal <BR>
processor register values. <BR>
<P>
swpirql Swap the current interrupt request level <BR>
<P>
The swpirql instruction swaps the current IRQL field in the PSR internal pro-cessor <BR>
register by setting the processor so that only permitted interrupts are <BR>
enabled for the new IRQL. Swpirql updates the IRQL field and returns the pre-vious <BR>
IRQL. <BR>
<P>
swpksp Swap the initial kernel stack pointer for the current thread <BR>
<P>
The swpksp instruction returns the value of the previous IKSP internal proces-sor <BR>
register and writes a new IKSP for the currently executing thread. <BR>
<P>
swppal Swap the currently executing PALcode <BR>
<P>
The swppal instruction swaps the currently executing PALcode by transferring <BR>
to the base address of the new PALcode image in the PALcode environment. <BR>
<P>
swpprocess Swap process context (swap address space) <BR>
<P>
The swpprocess instruction swaps the privileged process context by changing <BR>
the address space for the currently executing thread. <BR>
<P>
<B>Table 11– 2 : Privileged Windows NT Alpha PALcode Instruction Summary (Continued) <BR>
Mnemonic Operation and description </B>
273
<BR>
<A href=#page273>273</A>
<strong><A name=page274> Page 274</A></strong>
<A href=#page275>275</A>
<BR>
tbia Translation buffer invalidate all <BR>
The tbia instruction invalidates all translations and virtual cache blocks within <BR>
the processor. <BR>
<P>
tbim Translation buffer invalidate multiple <BR>
<P>
The tbim instruction invalidates multiple virtual translations for the current <BR>
ASN. The translation for the virtual address must be invalidated in all processor <BR>
translation buffers and virtual caches. <BR>
<P>
tbimasn Translation buffer invalidate multiple for ASN <BR>
<P>
The tbimasn instruction invalidates multiple virtual translations for a specified <BR>
ASN. The translation for the virtual addresses must be invalidated in all proces-sor <BR>
translation buffers and virtual caches. <BR>
<P>
tbis Translation buffer invalidate single <BR>
<P>
The tbis instruction invalidates a single virtual translation. The translation for <BR>
the passed virtual address must be invalidated in all processor translation buff-ers <BR>
and virtual caches. <BR>
<P>
tbisasn Translation buffer invalidate single for ASN <BR>
<P>
The tbisasn instruction invalidates a single virtual translation for a specified <BR>
address space. The translation for the passed virtual address must be invali-dated <BR>
in all processor translation buffers and virtual caches. <BR>
<P>
wrentry Write kernel exception entry routine <BR>
<P>
The wrentry instruction provides the registry of exception handling routines for <BR>
the exception classes. The kernel must use wrentry to register an exception han-dler <BR>
for each of the exception classes. <BR>
<P>
wrmces Write the machine check error summary register <BR>
<P>
The wrmces instruction writes new values for the MCES internal processor <BR>
register and returns the previous values of that register. <BR>
<P>
wrperfmon Write performance counter interrupt control information <BR>
<P>
The wrperfmon instruction writes control information for the two processor <BR>
performance counters. One parameter identifies the selected performance <BR>
counter, while another controls whether the selected performance counter is <BR>
enabled or disabled. The instruction returns the previous enable state for the <BR>
selected performance counter. <BR>
<P>
<B>Table 11– 2 : Privileged Windows NT Alpha PALcode Instruction Summary (Continued) <BR>
Mnemonic Operation and description </B>
274
<BR>
<A href=#page274>274</A>
<strong><A name=page275> Page 275</A></strong>
<A href=#page276>276</A>
<BR>
<B>A– 1 <BR>
Appendix A <BR>
Software Considerations <BR>
A. 1 Hardware-Software Compact <BR>
</B>The Alpha architecture, like all RISC architectures, depends on careful attention to data align-ment <BR>
and instruction scheduling to achieve high performance. <BR>
<P>
Since there will be various implementations of the Alpha architecture, it is not obvious how <BR>
compilers can generate high-performance code for all implementations. This chapter gives <BR>
some scheduling guidelines that, if followed by all compilers and respected by all implementa-tions, <BR>
will result in good performance. As such, this section represents a good-faith compact <BR>
between hardware designers and software writers. It represents a set of common goals, not a <BR>
set of architectural requirements. Thus, an Appendix, not a Chapter. <BR>
<P>
Many of the performance optimizations discussed below provide an advantage only for fre-quently <BR>
executed code. For rarely executed code, they may produce a bigger program that is <BR>
not any faster. Some of the branching optimizations also depend on good prediction of which <BR>
path from a conditional branch is more frequently executed. These optimizations are best deter-mined <BR>
by using an execution profile, either an estimate generated by compiler heuristics, or a <BR>
real profile of a previous run, such as that gathered by PC-sampling in PCA. <BR>
<P>
Each computer architecture has a "natural word size." For the PDP-11, it is 16 bits; for VAX, <BR>
32 bits; and for Alpha, 64 bits. Other architectures also have a natural word size that varies <BR>
between 16 and 64 bits. Except for very low-end implementations, ALU data paths, cache <BR>
access paths, chip pin buses, and main memory data paths are all usually the natural word size. <BR>
<P>
As an architecture becomes commercially successful, high-end implementations inevitably <BR>
move to double-width data paths that can transfer an <I>aligned </I>(at an even natural word address) <BR>
pair of natural words in one cycle. For Alpha, this means 128-bit wide data paths will eventu-ally <BR>
be implemented. It is difficult to get much speed advantage from paired transfers unless <BR>
the code being executed has instructions and data appropriately aligned on aligned octaword <BR>
boundaries. Since this is difficult to retrofit to old code, the following sections sometimes <BR>
encourage "over-aligning" to octaword boundaries in anticipation of high-speed Alpha <BR>
implementations. 
275
<BR>
<A href=#page275>275</A>
<strong><A name=page276> Page 276</A></strong>
<A href=#page277>277</A>
<BR>
<B>A– 2 </B>Alpha Architecture Handbook <BR>
In some cases, there are performance advantages to aligning instructions or data to cache-block <BR>
boundaries, or putting data whose use is correlated into the same cache block, or trying to <BR>
avoid cache conflicts by not having data whose use is correlated placed at addresses that are <BR>
equal modulo the cache size. Since the Alpha architecture will have many implementations, an <BR>
exact cache design cannot be outlined here. <BR>
<P>
In each case below, the performance implication is given by an order-of-magnitude number: 1, <BR>
3, 10, 30, or 100. A factor of 10 means that the performance difference being discussed will <BR>
likely range from 3 to 30 across all Alpha implementations. <BR>
<P>
<B>A. 2 Instruction-Stream Considerations <BR>
</B>The following sections describe considerations for the instruction stream. <BR>
<P>
<B>A. 2.1 Instruction Alignment <BR>
</B>Code PSECTs should be octaword aligned. Targets of frequently taken branches should be at <BR>
least quadword aligned, and octaword aligned for very frequent loops. Compilers could use <BR>
execution profiles to identify frequently taken branches. <BR>
<P>
Quadword I-fetch implementors should give first priority to executing aligned quadwords <BR>
quickly. Octaword-fetch implementors should give first priority to executing aligned octa-words <BR>
quickly, and second priority to executing aligned quadwords quickly. Dual-issue <BR>
implementations should give first priority to issuing both halves of an aligned quadword in one <BR>
cycle, and second priority to buffering and issuing other combinations. <BR>
<P>
<B>A. 2. 2 Branch Prediction and Minimizing Branch-Taken — Factor of 3 <BR>
</B>In many Alpha implementations, an unexpected change in I-stream address will result in about <BR>
10 lost instruction times. "Unexpected" may mean any branch-taken or may mean a mispre-dicted <BR>
branch. In many implementations, even a correctly predicted branch to a quadword <BR>
target address will be slower than straight-line code. <BR>
<P>
Compilers should follow these rules to minimize unexpected branches: <BR>
1. Branch prediction is implementation specific. Based on execution profiles, compilers <BR>
should physically rearrange code so that it has matching behavior. <BR>
<P>
2. Make basic blocks as big as possible. A good goal is 20 instructions on average between branch-taken. This requires unrolling loops so that they contain at least 20 <BR>
<P>
instructions, and putting subroutines of less than 20 instructions directly in line. It also requires using execution profiles to rearrange code so that the frequent case of a condi-tional <BR>
branch falls through. For very high-performance loops, it will be profitable to move instructions across conditional branches to fill otherwise wasted instruction issue <BR>
slots, even if the instructions moved will not always do useful work. Note that using the Conditional Move instructions can sometimes avoid breaking up basic blocks. <BR>
<P>
3. In an if-then-else construct whose execution profile is skewed even slightly away from 50%-50% (51-49 is enough), put the infrequent case completely out of line, so that the <BR>
frequent case encounters <I>zero </I>branch-takens, and the infrequent case encounters <I>two </I>
276
<BR>
<A href=#page276>276</A>
<strong><A name=page277> Page 277</A></strong>
<A href=#page278>278</A>
<BR>
<P>
Software Considerations <B>A– 3 <BR>
</B>branch-takens. If the infrequent case is rare (5%), put it far enough away that it never comes into the I-cache. If the infrequent case is extremely rare (error message code), <BR>
put it on a page of rarely executed code and expect that page <I>never </I>to be paged in. <BR>
4. There are two functionally identical branch-format opcodes, BSR and BR, as shown in <A href="#page277">Figure A– 1. <BR>
</A>
<P>
<B>Figure A– 1: Branch-Format BSR and BR Opcodes <BR>
</B><P>
Compilers should use the first one for subroutine calls, and the second for GOTOs. <BR>
Some implementations may push a stack of predicted return addresses for BSR and not <BR>
push the stack for BR. Failure to compile the correct opcode will result in mispredicted <BR>
return addresses, and hence make subroutine returns slow. <BR>
<P>
5. The memory-format JSR instruction, shown in <A href="#page277">Figure A– 2, </A>
has 16 unused bits. These should be <A href="#page74">used by the compilers </A>
to <A href="#page277">communicate a hint about </A>
expected branch-target <BR>
<P>
behavior (see <A href="#page74">Section 4.3). <BR>
</A>
<P>
<B>Figure A– 2: Memory-Format JSR Instruction <BR>
</B><P>
If the JSR is used for a computed GOTO or a CASE statement, compile bits &lt;15: 14&gt; <BR>
as 00, and bits &lt;13: 0&gt; such that (updated PC+ Instr&lt; 13: 0&gt;* 4) &lt;15: 0&gt; equals <BR>
(likely_ target_ addr) &lt;15: 0&gt;. In other words, pick the low 14 bits so that a normal <BR>
PC+ displacement* 4 calculation will match the low 16 bits of the most likely target <BR>
longword address. (Implementations will likely prefetch from the matching cache <BR>
block.) <BR>
<P>
If the JSR is used for a computed subroutine call, compile bits &lt;15: 14&gt; as 01, and bits <BR>
&lt;13: 0&gt; as above. Some implementations will prefetch the call target using the <BR>
prediction and also push updated PC on a return-prediction stack. <BR>
<P>
If the JSR is used as a subroutine return, compile bits &lt;15: 14&gt; as 10. Some <BR>
implementations will pop an address off a return-prediction stack. <BR>
<P>
If the JSR is used as a coroutine linkage, compile bits &lt;15: 14&gt; as 11. Some <BR>
implementations will pop an address off a return-prediction stack and also push <BR>
updated PC on the return-prediction stack. <BR>
<P>
Implementors should give first priority to executing straight-line code with no branch-takens as <BR>
<P>
0 31 21 20 <BR>
Displacement Branch Format <BR>
<P>
Branch Format Displacement <BR>
BSR Ra <BR>
Ra BR <BR>
<P>
26 25 <BR>
<P>
0 31 16 15 <BR>
JSR Ra Rb Memory Format 
277
<BR>
<A href=#page277>277</A>
<strong><A name=page278> Page 278</A></strong>
<A href=#page279>279</A>
<BR>
<B>A– 4 </B>Alpha Architecture Handbook <BR>
quickly as possible, second priority to predicting conditional branches based on the sign of the <BR>
displacement field (backward taken, forward not-taken), and third priority to predicting sub-routine <BR>
return addresses by running a small prediction stack. (VAX traces show a stack of two <BR>
to four entries correctly predicts most branches.) <BR>
<P>
<B>A. 2. 3 Improving I-Stream Density — Factor of 3 <BR>
</B>Compilers should try to use profiles to make sure almost 100% of the bytes brought into an <BR>
I-cache are actually executed. This requires aligning branch targets and putting rarely executed <BR>
code out of line. <BR>
<P>
<B>A. 2. 4 Instruction Scheduling — Factor of 3 <BR>
</B>The performance of Alpha programs is sensitive to how carefully the code is scheduled to min-imize <BR>
instruction-issue delays. <BR>
<P>
"Result latency" is defined as the number of CPU cycles that must elapse between an instruc-tion <BR>
that writes a result register and one that uses that register, if execution-time stalls are to be <BR>
avoided. Thus, with a latency of zero, the instruction writes a result register and the instruction <BR>
that uses that register can be multiple-issued in the <I>same </I>cycle. With a latency of 2, if the writ-ing <BR>
instruction is issued at cycle N, the reading instruction can issue no earlier than cycle N+ 2. <BR>
Latency is implementation specific. <BR>
<P>
Most Alpha instructions have a non-zero result latency. Compilers should schedule code so <BR>
that a result is not used too soon, at least in frequently executed code (inner loops, as identified <BR>
by execution profiles). In general, this will require unrolling loops and inlining short <BR>
procedures. <BR>
<P>
Compilers should try to schedule code to match the above latency rules and also to match the <BR>
multiple-issue rules. If doing both is impractical for a particular sequence of code, the latency <BR>
rules are more important (since they apply even in single-issue implementations). <BR>
<P>
Implementors should give first priority to minimizing the latency of back-to-back integer oper-ations, <BR>
of address calculations immediately followed by load/ store, of load immediately <BR>
followed by branch, and of compare immediately followed by branch. Give second priority to <BR>
minimizing latencies in general. <BR>
<P>
<B>A. 3 Data-Stream Considerations <BR>
</B>The following sections describe considerations for the data stream. <BR>
<P>
<B>A. 3. 1 Data Alignment — Factor of 10 <BR>
</B>Data PSECTs should be at least octaword aligned, so that aggregates (arrays, some records, <BR>
subroutine stack frames) can be allocated on aligned octaword boundaries to take advantage of <BR>
any implementations with aligned octaword data paths, and to decrease the number of cache <BR>
fills in almost all implementations. <BR>
<P>
Aggregates (arrays, records, common blocks, and so forth) should be allocated on at least 
278
<BR>
<A href=#page278>278</A>
<strong><A name=page279> Page 279</A></strong>
<A href=#page280>280</A>
<BR>
Software Considerations <B>A– 5 <BR>
</B>aligned octaword boundaries whenever language rules allow. In some implementations, a <BR>
series of writes that completely fill a cache block may be a factor of 10 faster than a series of <BR>
writes that partially fill a cache block, when that cache block would give a read miss. This is <BR>
true of write-back caches that read a partially filled cache block from memory, but optimize <BR>
away the read for completely filled blocks. <BR>
<P>
For such implementations, long strings of sequential writes will be faster if they start on a <BR>
cache-block boundary (a multiple of 128 bytes will do well for most, if not all, Alpha imple-mentations). <BR>
This applies to array results that sweep through large portions of memory, and to <BR>
register-save areas for context switching, graphics frame buffer accesses, and other places <BR>
where exactly 8, 16, 32, or more quadwords are stored sequentially. Allocating the targets at <BR>
multiples of 8, 16, 32, or more quadwords, respectively, and doing the writes in order of <BR>
increasing address will maximize the write speed. <BR>
<P>
Items within aggregates that are forced to be unaligned (records, common blocks) should gen-erate <BR>
compile-time warning messages and inline byte extract/ insert code. Users must be <BR>
educated that the warning message means that they are taking a factor of 30 performance hit. <BR>
<P>
Compiled code for parameters should assume that the parameters are aligned. Unaligned actu-als <BR>
will cause run-time alignment traps and very slow fixups. The fixup routine, if invoked, <BR>
should generate warning messages to the user, preferably giving the first few statement num-bers <BR>
that are doing unaligned parameter access, and at the end of a run the total number of <BR>
alignment traps (and perhaps an estimate of the performance improvement if the data were <BR>
aligned). Users must be educated that the trap routine warning message means they are taking a <BR>
factor of 30 performance hit. <BR>
<P>
Frequently used scalars should reside in registers. Each scalar datum allocated in memory <BR>
should normally be allocated an aligned quadword to itself, even if the datum is only a byte <BR>
wide. This allows aligned quadword loads and stores and avoids partial-quadword writes <BR>
(which may be half as fast as full-quadword writes, due to such factors as read-modify-write a <BR>
quadword to do quadword ECC calculation). <BR>
<P>
Implementors should give first priority to fast reads of aligned octawords and second priority <BR>
to fast writes of full cache blocks. <BR>
<P>
<B>A. 3. 2 Shared Data in Multiple Processors — Factor of 3 <BR>
</B>Software locks are aligned quadwords and should be allocated to large cache blocks that either <BR>
contain no other data or read-mostly data whose usage is correlated with the lock. <BR>
<P>
Whenever there is high contention for a lock, one processor will have the lock and be using the <BR>
guarded data, while other processors will be in a read-only spin loop on the lock bit. Under <BR>
these circumstances, <I>any </I>write to the cache block containing the lock will likely cause excess <BR>
bus traffic and cache fills, thus affecting performance on all processors that are involved and <BR>
the buses between them. In some decomposed FORTRAN programs, refills of the cache blocks <BR>
containing one or two frequently used locks can account for a third of all the bus bandwidth the <BR>
program consumes. <BR>
<P>
Whenever there is almost no contention for a lock, one processor will have the lock and be <BR>
using the guarded data. Under these circumstances, it might be desirable to keep the guarded 
279
<BR>
<A href=#page279>279</A>
<strong><A name=page280> Page 280</A></strong>
<A href=#page281>281</A>
<BR>
<B>A– 6 </B>Alpha Architecture Handbook <BR>
data in the <I>same </I>cache block as the lock. <BR>
For the high-sharing case, compilers should assume that <I>almost all </I>accesses to shared data <BR>
result in cache misses all the way back to main memory, for each distinct cache block used. <BR>
Such accesses will likely be a factor of 30 slower than cache hits. It is helpful to pack corre-lated <BR>
shared data into a small number of cache blocks. It is helpful also to segregate blocks <BR>
written by one processor from blocks read by others. <BR>
<P>
Therefore, accesses to shared data, including locks, should be minimized. For example, a <BR>
four-processor decomposition of some manipulation of a 1000-row array should avoid access-ing <BR>
lock variables every row, but instead might access a lock variable every 250 rows. <BR>
<P>
Array manipulation should be partitioned across processors so that cache blocks do not thrash <BR>
between processors. Having each of four processors work on every fourth array element <BR>
severely impairs performance on any implementation with a cache block of four elements or <BR>
larger. The processors all contend for copies of the <I>same </I>cache blocks and use only one quar-ter <BR>
of the data in each block. Writes in one processor severely impair cache performance on all <BR>
processors. <BR>
<P>
A better decomposition is to give each processor the largest possible contiguous chunk of data <BR>
to work on (N/ 4 consecutive rows for four processors and row-major array storage; N/ 4 col-umns <BR>
for column-major storage). With the possible exception of three cache blocks at the <BR>
partition boundaries, this decomposition will result in each processor caching data that is <BR>
touched by <I>no </I>other processor. <BR>
<P>
Operating-system scheduling algorithms should attempt to minimize process migration from <BR>
one processor to another. Any time migration occurs, there are likely to be a large number of <BR>
cache misses on the new processor. <BR>
<P>
Similarly, operating-system scheduling algorithms should attempt to enforce some affinity <BR>
between a given device's interrupts and the processor on which the interrupt-handler runs. I/ O <BR>
control data structures and locks for different devices should be disjoint. Observing these <BR>
guidelines allows higher cache hit rates on the corresponding I/ O control data structures. <BR>
<P>
Implementors should give first priority to an efficient (low-bandwidth) way of transferring iso-lated <BR>
lock values and other isolated, shared write data between processors. <BR>
<P>
Implementors should assume that the amount of shared data will continue to increase, so over <BR>
time the need for efficient sharing implementations will also increase. <BR>
<P>
<B>A. 3. 3 Avoiding Cache/ TB Conflicts — Factor of 1 <BR>
</B>Occasionally, programs that run with a direct-mapped cache or TB will thrash, taking exces-sive <BR>
cache or TB misses. With some work, thrashing can be minimized at compile time. <BR>
<P>
<B>Note: <BR>
</B>No Alpha processor through and including the 21264 has implemented a direct-mapped <BR>
TB. 
280
<BR>
<A href=#page280>280</A>
<strong><A name=page281> Page 281</A></strong>
<A href=#page282>282</A>
<BR>
<P>
Software Considerations <B>A– 7 <BR>
</B>In a frequently executed loop, compilers could allocate the data items accessed from memory <BR>
so that, on each loop iteration, all of the memory addresses accessed are either in <I>exactly the <BR>
same </I>aligned 64-byte block or differ in bits VA&lt; 10: 6&gt;. For loops that go through arrays in a <BR>
common direction with a common stride, this requires allocating the arrays, checking that the <BR>
first-iteration addresses differ, and if not, inserting up to 64 bytes of padding <I>between </I>the <BR>
arrays. This rule will avoid thrashing in small direct-mapped data caches with block sizes up to <BR>
64 bytes and total sizes of 2K bytes or more. <BR>
<P>
Example: <BR>
<TT>REAL* 4 A( 1000), B( 1000) <BR>
DO 60 i= 1,1000 <BR>
60 A( i ) = f( B( i )) <BR>
</TT><P>
Figures <A href="#page281">A– 3, </A>
<A href="#page281">A– 4, </A>
and <A href="#page281">A– 5 </A>
show bad, better, and best allocation in cache, respectively. <BR>
BAD allocation (A and B thrash in 8 KB direct-mapped cache): <BR>
<P>
<B>Figure A– 3: Bad Allocation in Cache <BR>
</B><P>
BETTER allocation (A and B offset by 64 mod 2 KB, so 16 elements of A and 16 of B can be <BR>
in cache simultaneously): <BR>
<P>
<B>Figure A– 4: Better Allocation in Cache <BR>
</B><P>
BEST allocation (A and B offset by 64 mod 2 KB, so 16 elements of A and 16 of B can be in <BR>
cache simultaneously, <I>and </I>both arrays fit entirely in 8 KB or bigger cache): <BR>
<P>
<B>Figure A– 5: Best Allocation in Cache <BR>
</B><P>
In a frequently executed loop, compilers could allocate the data items accessed from memory <BR>
so that, on each loop iteration, all of the memory addresses accessed are either in <I>exactly the <BR>
same 8 KB </I>page, or differ in bits VA&lt; 17: 13&gt;. For loops that go through arrays in a common <BR>
direction with a common stride, this requires allocating the arrays, checking that the first-itera-<BR>
<P>
A B <BR>
0 4K 8K 16K 12K <BR>
<P>
A B <BR>
0 4K 8K+ 64 16K 12K <BR>
<P>
A B <BR>
0 4K-64 8K 16K 12K 
281
<BR>
<A href=#page281>281</A>
<strong><A name=page282> Page 282</A></strong>
<A href=#page283>283</A>
<BR>
<B>A– 8 </B>Alpha Architecture Handbook <BR>
tion addresses differ, and if they do not, inserting up to 8K bytes of padding <I>between </I>the <BR>
arrays. This rule will avoid thrashing in direct-mapped TBs and in some large direct-mapped <BR>
data caches with total sizes of 32 pages (256 KB) or more. <BR>
<P>
Usually, this padding will mean <I>zero </I>extra bytes in the executable image, just a skip in virtual <BR>
address space to the next-higher page boundary. <BR>
<P>
For large caches, the rule above should be applied to the I-stream, in addition to all the <BR>
D-stream references. Some implementations will have combined I-stream/ D-stream large <BR>
caches. <BR>
<P>
Both of the rules above can be satisfied simultaneously, thus often eliminating thrashing in all <BR>
anticipated direct-mapped cache/ TB implementations. <BR>
<P>
<B>A. 3. 4 Sequential Read/ Write — Factor of 1 <BR>
</B>All other things being equal, sequences of consecutive reads or writes should use ascending <BR>
(rather than descending) memory addresses. Where possible, the memory address for a block <BR>
of 2** Kbytes should be on a 2** K boundary, since this minimizes the number of different <BR>
cache blocks used and minimizes the number of partially written cache blocks. <BR>
<P>
To avoid overrunning memory bandwidth, sequences of more than eight quadword load or <BR>
store instructions should be broken up with intervening instructions (if there is any useful work <BR>
to be done). <BR>
<P>
For consecutive reads, implementors should give first priority to prefetching ascending cache <BR>
blocks and second priority to absorbing up to eight consecutive quadword load instructions <BR>
(aligned on a 64-byte boundary) without stalling. <BR>
<P>
For consecutive writes, implementors should give first priority to avoiding read overhead for <BR>
fully written aligned cache blocks and second priority to absorbing up to eight consecutive <BR>
quadword store instructions (aligned on a 64-byte boundary) without stalling. <BR>
<P>
<B>A. 3. 5 Prefetching — Factor of 3 <BR>
</B>Prefetching can be directed toward a cache block (a cache line) in the primary cache. <BR>
<P>
Alpha hardware, beginning with the 21164 (EV5) and subsequent, supports cache block <BR>
prefetching. Cache block prefetching is performed by the following load operations to the R31 <BR>
or F31 register: <BR>
<P>
<B>Table A– 1: Cache Block Prefetching <BR>
Type Instructions Operation <BR>
</B>Normal Prefetch LDL R31, xxx (Rn) If the load operation hits in the Dcache, the <BR>
instruction is dismissed; otherwise, the <BR>
addressed cache block is allocated into the <BR>
Dcache. 
282
<BR>
<A href=#page282>282</A>
<strong><A name=page283> Page 283</A></strong>
<A href=#page284>284</A>
<BR>
<P>
Software Considerations <B>A– 9 <BR>
A. 4 Code Sequences <BR>
</B>The following section describes code sequences. <BR>
<P>
<B>A. 4. 1 Aligned Byte/ Word (Within Register) Memory Accesses <BR>
</B>The instruction sequences given in <A href="#page103">Section 4.6 </A>
for byte-within-register accesses are worst-case <BR>
code. More importantly, they do not reflect the instructions available with the BWX extension, <BR>
described in the Sections <A href="#page62">4.2.2, </A>
<A href="#page71">4.2.6, </A>
and <A href="#page116">4. 6.5, </A>
and in <A href="#page327">Section D. 3. </A>
If the BWX extension <BR>
instructions are available, it is wise to consider them rather than the sequences that follow. <BR>
<P>
The following sequences are appropriate if the BWX extension instructions are not available. <BR>
In the common case of accessing a byte or aligned word field at a known offset from a pointer <BR>
that is expected to be at least longword aligned, the common-case code is much shorter. <BR>
"Expected" means that the code should run fast for a longword-aligned pointer and trap for <BR>
unaligned. The trap handler may at its option fix up the unaligned reference. <BR>
<P>
For access at a known offset D from a longword-aligned pointer Rx, let D. lw be D rounded <BR>
down to a multiple of 4 (( D div 4)* 4), and let D. mod be D mod 4. <BR>
<P>
In the common case, the intended sequence for loading and zero-extending an aligned word is: <BR>
<TT>LDL R1, D. lw( Rx) ! Traps if unaligned <BR>
EXTWL R1,# D. mod, R1 ! Picks up word at byte 0 or byte 2 <BR>
</TT><P>
In the common case, the intended sequence for loading and sign-extending an aligned word is: <BR>
<TT>LDL R1,D. lw( Rx) ! Traps if unaligned <BR>
SLL R1,# 48-8* D. mod, R1 ! Aligns word at high end of R1 <BR>
SRA R1,# 48,R1 ! SEXT to low end of R1 <BR>
</TT><P>
Prefetch with <BR>
Modify Intent <BR>
LDS F31, xxx (Rn) If the load operation hits a dirty, modified, <BR>
Dcache block, the instruction is dismissed. Oth-erwise, <BR>
the addressed cache block is allocated <BR>
into the Dcache for write access — its dirty and <BR>
modified bits are set. <BR>
<P>
Prefetch, Evict <BR>
Next <BR>
LDQ R31, xxx (Rn) Prefetch a cache block and mark that block in an <BR>
associated cache to be evicted on the next cache <BR>
fill to an associated address. (This operation is <BR>
useful to prefetch data that is not to be repeat-edly <BR>
referenced.) <BR>
<P>
<B>Table A– 1: Cache Block Prefetching <BR>
Type Instructions Operation </B>
283
<BR>
<A href=#page283>283</A>
<strong><A name=page284> Page 284</A></strong>
<A href=#page285>285</A>
<BR>
<B>A– 10 </B>Alpha Architecture Handbook <BR>
<B>Note: <BR>
</B>The shifts often can be combined with shifts that might surround subsequent arithmetic <BR>
operations (for example, to produce word overflow from the high end of a register). <BR>
<P>
In the common case, the intended sequence for loading and zero-extending a byte is: <BR>
<TT>LDL R1,D. lw( Rx) ! <BR>
EXTBL R1,# D. mod, R1 ! <BR>
</TT><P>
In the common case, the intended sequence for loading and sign-extending a byte is: <BR>
<TT>LDL R1,D. lw( Rx) ! <BR>
SLL R1,# 56-8* D. mod, R1 ! <BR>
SRA R1,# 56,R1 ! <BR>
</TT><P>
In the common case, the intended sequence for storing an aligned word R5 is: <BR>
<TT>LDL R1,D. lw( Rx) ! <BR>
INSWL R5,# D. mod, R3 ! <BR>
MSKWL R1,# D. mod, R1 ! <BR>
BIS R3,R1, R1 ! <BR>
STL R1,D. lw( Rx) ! <BR>
</TT>In the common case, the intended sequence for storing a byte R5 is: <BR>
<P>
<TT>LDL R1,D. lw( Rx) ! <BR>
INSBL R5,# D. mod, R3 ! <BR>
MSKBL R1,# D. mod, R1 ! <BR>
BIS R3,R1, R1 ! <BR>
STL R1,D. lw( Rx) ! <BR>
</TT><P>
<B>A. 4. 2 Division <BR>
</B>In all implementations, floating-point division is likely to have a substantially longer result <BR>
latency than floating-point multiply. In addition, in many implementations multiplies will be <BR>
pipelined and divides will not. <BR>
<P>
Thus, any division by a constant power of two should be compiled as a multiply by the exact <BR>
reciprocal, if it is representable without overflow or underflow. If language rules or surround-ing <BR>
context allow, multiplication by the reciprocal can closely approximate other divisions by <BR>
constants. <BR>
<P>
Integer division does not exist as a hardware opcode. Division by a constant can always be <BR>
done via UMULH of another appropriate constant, followed by a right shift. A subroutine can <BR>
do general quadword division by true variables. The subroutine could test for small divisors <BR>
(less than about 1000 in absolute value) and for those, do a table lookup on the exact constant <BR>
and shift count for an UMULH/ shift sequence. For the remaining cases, a table lookup on <BR>
about a 1000-entry table and a multiply can give a linear approximation to 1/ divisor that is <BR>
accurate to 16 bits. <BR>
<P>
Using this approximation, a multiply and a back-multiply and a subtract can generate one 
284
<BR>
<A href=#page284>284</A>
<strong><A name=page285> Page 285</A></strong>
<A href=#page286>286</A>
<BR>
Software Considerations <B>A– 11 <BR>
</B>16-bit quotient digit plus a 48-bit new partial dividend. Three more such steps can generate the <BR>
full quotient. Having prior knowledge of the possible sizes of the divisor and dividend, normal-izing <BR>
away leading bytes of zeros, and performing an early-out test can reduce the average <BR>
number of multiplies to about five (compared to a best case of one and a worst case of nine). <BR>
<P>
<B>A. 4.3 Byte Swap <BR>
</B>When it is necessary to swap all the bytes of a datum, perhaps because the datum originated on <BR>
a machine of the opposite byte numbering convention, the simplest sequence is to use the VAX <BR>
floating-point load instruction to swap words, followed by an integer sequence to swap four <BR>
pairs of bytes. Assume as shown below that an aligned quadword datum is in memory at loca-tion <BR>
X and is to be left in R1 after byte-swapping; temp is an aligned quadword temporary, and <BR>
"." (period) in the comments stands for a byte of zeros. Similar sequences can be used for data <BR>
in registers, sometimes doing the byte swaps first and word swap second: <BR>
<P>
<TT>; X = ABCD EFGH <BR>
LDG F0, X ; F0 = GHEF CDAB <BR>
STT F0, temp <BR>
LDQ R1, temp ; R1 = GHEF CDAB <BR>
SLL R1,# 8, R2 ; R2 = HEFC DAB. <BR>
SRL R1,# 8, R1 ; R1 = .GHE FCDA <BR>
ZAP R2,# 55( hex), R2 ; R2 = H. F. D. B. <BR>
ZAP R1,# AA( hex), R1 ; R1 = .G. E .C. A <BR>
OR R1, R2, R1 ; R1 = HGFE DCBA <BR>
</TT><P>
For bulk swapping of arrays, this sequence can be usefully unrolled about four times and <BR>
scheduled, using four different aligned quadword memory temps. <BR>
<P>
<B>A. 4. 4 Stylized Code Forms <BR>
</B>Using the same stylized code form for a common operation improves the readability of com-piler <BR>
output and increases the likelyhood that an implementation will speed up the stylized <BR>
form. <BR>
<P>
<B>A. 4.4.1 NOP <BR>
</B>The universal NOP form is: <BR>
<P>
<TT>UNOP == LDQ_ U R31,0( Rx) <BR>
</TT>In most implementations, UNOP should encounter no operand issue delays, no destination <BR>
issue delay, and no functional unit issue delays. (In some implementations, it may encounter an <BR>
operand issue delay for Rx.) Implementations are free to optimize UNOP into no action and <BR>
zero execution cycles. <BR>
<P>
If the actual instruction is encoded as LDQ_ U Rn, 0( Rx), where <I>n </I>is other than 31, and such an <BR>
instruction generates a memory-management exception, it is UNPREDICTABLE whether <BR>
UNOP would generate the same exception. On most implementations, UNOP does not gener-ate <BR>
memory management exceptions. 
285
<BR>
<A href=#page285>285</A>
<strong><A name=page286> Page 286</A></strong>
<A href=#page287>287</A>
<BR>
<B>A– 12 </B>Alpha Architecture Handbook <BR>
The standard NOP forms are: <BR>
<TT>NOP == BIS R31, R31, R31 <BR>
FNOP == CPYS F31, F31, F31 <BR>
</TT><P>
These generate no exceptions. In most implementations, they should encounter no operand <BR>
issue delays and no destination issue delay. Implementations are free to optimize these into no <BR>
action and zero execution cycles. <BR>
<P>
<B>A. 4.4.2 Clear a Register <BR>
</B>The standard clear register forms are: <BR>
<P>
<TT>CLR == BIS R31, R31, Rx <BR>
FCLR == CPYS F31, F31, Fx <BR>
</TT><P>
These generate no exceptions. In most implementations, they should encounter no operand <BR>
issue delays and no functional unit issue delay. <BR>
<P>
<B>A. 4.4.3 Load Literal <BR>
</B>The standard load integer literal (ZEXT 8-bit) form is: <BR>
<P>
<TT>MOV #lit8, Ry == BIS R31, lit8, Ry <BR>
</TT>The Alpha literal construct in Operate instructions creates a canonical longword constant for <BR>
values 0.. 255. <BR>
<P>
A longword constant stored in an Alpha 64-bit register is in canonical form when bits <BR>
&lt;63: 32&gt;= bit &lt;31&gt;. <BR>
<P>
A canonical 32-bit literal can usually be generated with one or two instructions, but sometimes <BR>
three instructions are needed. Use the following procedure to determine the offset fields of the <BR>
instructions: <BR>
<P>
<TT>val = &lt;sign-extended, 32-bit value&gt; <BR>
low = val &lt;15: 0&gt; <BR>
tmp1 = val -SEXT( low) ! Account for LDA instruction <BR>
</TT><P>
<TT>high = tmp1 &lt;31: 16&gt; <BR>
tmp2 = tmp1 -SHIFT_ LEFT( SEXT( high, 16) ) <BR>
</TT><P>
<TT>if tmp2 NE 0 then <BR>
! original val was in range 7FFF8000 16 .. 7FFFFFFF 16 <BR>
</TT><P>
<TT>extra = 4000 16 <BR>
tmp1 = tmp1 -40000000 16 <BR>
high = tmp1 &lt;31: 16&gt; <BR>
else <BR>
extra = 0 <BR>
endif </TT>
286
<BR>
<A href=#page286>286</A>
<strong><A name=page287> Page 287</A></strong>
<A href=#page288>288</A>
<BR>
Software Considerations <B>A– 13 <BR>
</B>The general sequence is: <BR>
<TT>LDA Rdst, low( R31) <BR>
LDAH Rdst, extra( Rdst) ! Omit if extra= 0 <BR>
LDAH Rdst, high( Rdst) ! Omit if high= 0 <BR>
</TT><P>
<B>A. 4.4.4 Register-to-Register Move <BR>
</B>The standard register move forms are: <BR>
<P>
<TT>MOV RX, RY == BIS RX, RX, RY <BR>
FMOV FX, FY == CPYS FX, FX, FY <BR>
</TT><P>
These move forms generate no exceptions. In most implementations, these should encounter no <BR>
functional unit issue delay. <BR>
<P>
<B>A. 4.4.5 Negate <BR>
</B>The standard register negate forms are: <BR>
<P>
<TT>NEGz Rx, Ry == SUBz R31, Rx, Ry ! z = L or Q <BR>
NEGz Fx, Fy == SUBz F31, Fx, Fy ! z = F G S or T <BR>
FNEGz Fx, Fy == CPYSN Fx, Fx, Fy ! z = F G S or T <BR>
</TT><P>
The integer subtract generates no Integer Overflow trap if Rx contains the largest negative <BR>
number (SUBz/ V would trap). The floating subtract generates a floating-point exception for a <BR>
non-finite value in Fx. The CPYSN form generates no exceptions. <BR>
<P>
<B>A. 4.4.6 NOT <BR>
</B>The standard integer register NOT form is: <BR>
<P>
<TT>NOT Rx, Ry == ORNOT R31, Rx, Ry <BR>
</TT>This generates no exceptions. In most implementations, this should encounter no functional <BR>
unit issue delay. <BR>
<P>
<B>A. 4.4.7 Booleans <BR>
</B>The standard alternative to BIS is: <BR>
<P>
<TT>OR Rx, Ry, Rz == BIS Rx, Ry, Rz <BR>
</TT>The standard alternative to BIC is: <BR>
<TT>ANDNOT Rx, Ry, Rz == BIC Rx, Ry, Rz <BR>
</TT>The standard alternative to EQV is: <BR>
<TT>XORNOT Rx, Ry, Rz == EQV Rx, Ry, Rz </TT>
287
<BR>
<A href=#page287>287</A>
<strong><A name=page288> Page 288</A></strong>
<A href=#page289>289</A>
<BR>
<P>
<B>A– 14 </B>Alpha Architecture Handbook <BR>
<B>A. 4. 5 Exceptions and Trap Barriers <BR>
</B>The EXCB instruction allows software to guarantee that in a pipelined implementation, all pre-vious <BR>
instructions have completed any behavior that is related to exceptions or rounding modes <BR>
before any instructions after the EXCB are issued. In particular, all changes to the float-ing-<BR>
point control register (FPCR) are guaranteed to have been made, whether or not there is an <BR>
associated exception. Also, all potential floating-point exceptions and integer overflow excep-tions <BR>
are guaranteed to have been taken. <BR>
<P>
The TRAPB instruction guarantees that it and any following instructions do not issue until all <BR>
possible preceding traps have been signaled. This does not mean that all preceding instructions <BR>
have necessarily run to completion (for example, a Load instruction may have passed all the <BR>
fault checks but not yet delivered data from a cache miss). <BR>
<P>
EXCB is thus a superset of TRAPB. <BR>
<P>
<B>A. 4. 6 Pseudo-Operations (Stylized Code Forms) <BR>
</B>This section summarizes the pseudo-operations for the Alpha architecture that may be used by <BR>
various software components in an Alpha system. Most of these forms are discussed in preced-ing <BR>
sections. <BR>
<P>
In the context of this section, pseudo-operations all represent a single underlying machine <BR>
instruction. Each pseudo-operation represents a particular instruction with either replicated <BR>
fields (such as FMOV), or hard-coded zero fields. Since the pattern is distinct, these <BR>
pseudo-operations can be decoded by instruction decode mechanisms. <BR>
<P>
In <A href="#page288">Table A– 2, </A>
the pseudo-operation codes can be viewed as macros with parameters. The for-mal <BR>
form is listed in the left column, and the expansion in the code stream is listed in the right <BR>
column. <BR>
<P>
Some instruction mnemonics have synonyms. These differ from pseudo-operations in that each <BR>
synonym represents the same underlying instruction with no special encoding of operand <BR>
fields. As a result, synonyms cannot be distinquished from each other. They are not listed in <BR>
the table. Examples of synonyms are: BIC/ ANDNOT, BIS/ OR, and EQV/ XORNOT. <BR>
<P>
<B>Table A– 2: Decodable Pseudo-Operations (Stylized Code Forms) <BR>
Pseudo-Operation <BR>
in Listing Meaning <BR>
Actual Instruction <BR>
Encoding <BR>
</B><P>
BR target Branch to target (21-bit signed <BR>
displacement) <BR>
BR R31, target <BR>
<P>
CLR Rx Clear integer register BIS R31, R31, Rx <BR>
FABS Fx, Fy No-exception generic floating <BR>
absolute value <BR>
CPYS F31, Fx, Fy <BR>
<P>
FCLR Fx Clear a floating-point register CPYS F31, F31, Fx <BR>
FMOV Fx, Fy Floating-point move CPYS Fx, Fx, Fy 
288
<BR>
<A href=#page288>288</A>
<strong><A name=page289> Page 289</A></strong>
<A href=#page290>290</A>
<BR>
Software Considerations <B>A– 15 <BR>
</B>FNEG Fx, Fy No-exception generic floating <BR>
negation <BR>
CPYSN Fx, Fx, Fy <BR>
<P>
FNOP Floating-point no-op CPYS F31, F31, F31 <BR>
MOV Lit, Rx Move 16-bit sign-extended <BR>
literal to Rx <BR>
LDA Rx, lit( R31) <BR>
<P>
MOV {Rx/ Lit8}, Ry Move Rx/ 8-bit zero-extended <BR>
literal to Ry <BR>
BIS R31,{ Rx/ Lit8}, Ry <BR>
<P>
MF_ FPCR Fx Move from FPCR MF_ FPCR Fx, Fx, Fx <BR>
MT_ FPCR Fx Move to FPCR MT_ FPCR Fx, Fx, Fx <BR>
NEGF Fx, Fy Negate F_ floating SUBF F31, Fx, Fy <BR>
NEGF/ S Fx, Fy Negate F_ floating, semi-precise SUBF/ S F31, Fx, Fy <BR>
NEGG Fx, Fy Negate G_ floating SUBG F31, Fx, Fy <BR>
NEGG/ S Fx, Fy Negate G_ floating, <BR>
semi-precise <BR>
SUBG/ S F31, Fx, Fy <BR>
<P>
NEGL {Rx/ Lit8}, Ry Negate longword SUBL R31,{ Rx/ Lit}, Ry <BR>
NEGL/ V {Rx/ Lit8}, Ry Negate longword with <BR>
overflow detection <BR>
SUBL/ V R31, {Rx/ Lit}, Ry <BR>
<P>
NEGQ {Rx/ Lit8}, Ry Negate quadword SUBQ R31,{Rx/ Lit},Ry <BR>
NEGQ/ V {Rx/ Lit8}, Ry Negate quadword with <BR>
overflow detection <BR>
SUBQ/ V R31, {Rx/ Lit}, Ry <BR>
<P>
NEGS Fx, Fy Negate S_ floating SUBS F31, Fx, Fy <BR>
NEGS/ SU Fx, Fy Negate S_ floating, software <BR>
with underflow detection <BR>
SUBS/ SU F31, Fx, Fy <BR>
<P>
NEGS/ SUI Fx, Fy Negate S_ floating, software <BR>
with underflow and inexact <BR>
result detection <BR>
<P>
SUBS/ SUI F31, Fx, Fy <BR>
<P>
NEGT Fx, Fy Negate T_ floating SUBT F31, Fx, Fy <BR>
NEGT/ SU Fx, Fy Negate T_ floating, software <BR>
with underflow detection <BR>
SUBT/ SU F31, Fx, Fy <BR>
<P>
NEGT/ SUI Negate T_ floating, software <BR>
with underflow and inexact <BR>
result detection <BR>
<P>
SUBT/ SUI F31, Fx, Fy <BR>
<P>
NOP Integer no-op BIS R31, R31, R31 <BR>
NOT {Rx/ Lit8}, Ry Logical NOT of Rx/ 8-bit <BR>
zero-extended literal storing <BR>
results in Ry <BR>
<P>
ORNOT R31, {Rx/ Lit}, Ry <BR>
<P>
<B>Table A– 2: Decodable Pseudo-Operations (Stylized Code Forms) (Continued) <BR>
Pseudo-Operation <BR>
in Listing Meaning <BR>
Actual Instruction <BR>
Encoding </B>
289
<BR>
<A href=#page289>289</A>
<strong><A name=page290> Page 290</A></strong>
<A href=#page291>291</A>
<BR>
<B>A– 16 </B>Alpha Architecture Handbook <BR>
<B>A. 5 Timing Considerations: Atomic Sequences <BR>
</B>A sufficiently long instruction sequence between LDx_ L and STx_ C will never complete, <BR>
because periodic timer interrupts will always occur before the sequence completes. The follow-ing <BR>
rules describe sequences that will eventually complete in all Alpha implementations: <BR>
<P>
<B>° </B>At most 40 operate or conditional-branch (not taken) instructions executed in the sequence between LDx_ L and STx_ C. <BR>
<P>
<B>° </B>At most two I-stream TB-miss faults. Sequential instruction execution guarantees this. <BR>
<B>° </B>No other exceptions triggered during the last execution of the sequence. <BR>
<P>
<B>Implementation Note: <BR>
</B>On all expected implementations, this allows for about 50 msec of execution time, even <BR>
with 100 percent cache misses. This should satisfy any requirement for a 1-msec timer <BR>
interrupt rate. <BR>
<P>
SEXTL {Rx/ Lit8}, Ry Longword sign-extension of Rx <BR>
storing results in Ry <BR>
ADDL R31, {Rx/ Lit}, Ry <BR>
<P>
UNOP Universal NOP for both integer <BR>
and floating-point code <BR>
LDQ_ U R31, 0( Rx) <BR>
<P>
<B>Table A– 2: Decodable Pseudo-Operations (Stylized Code Forms) (Continued) <BR>
Pseudo-Operation <BR>
in Listing Meaning <BR>
Actual Instruction <BR>
Encoding </B>
290
<BR>
<A href=#page290>290</A>
<strong><A name=page291> Page 291</A></strong>
<A href=#page292>292</A>
<BR>
<B>B– 1 <BR>
Appendix B <BR>
IEEE Floating-Point Conformance <BR>
</B>A subset of IEEE Standard for Binary Floating-Point Arithmetic (ANSI/ IEEE Standard <BR>
754-1985) is provided in the Alpha floating-point instructions. This appendix describes how to <BR>
construct a complete IEEE implementation. <BR>
<P>
The order of presentation parallels the order of the IEEE specification. <BR>
<P>
<B>B. 1 Alpha Choices for IEEE Options <BR>
</B>Alpha supports IEEE single, double, and optionally (in software) extended double formats. <BR>
There is no hardware support for the optional extended double format. <BR>
<P>
Alpha hardware supports normal and chopped IEEE rounding modes. IEEE plus infinity and <BR>
minus infinity rounding modes can be implemented in hardware or software. <BR>
<P>
Alpha hardware does not support optional IEEE software trap enable/ disable modes. See the <BR>
following discussion about software support. <BR>
<P>
Alpha hardware supports add, subtract, multiply, divide, convert between floating formats, <BR>
convert between floating and integer formats, compare, and square root. Software routines sup-port <BR>
remainder, round to integer in floating-point format, and convert binary to/ from decimal. <BR>
<P>
In the Alpha architecture, copying without change of format is not considered an operation. <BR>
(LDx, CPYSx, and STx do not check for non-finite numbers; an operation would.) Compilers <BR>
may generate ADDx F31,Fx, Fy to get the opposite effect. <BR>
<P>
Optional operations for differing formats are not provided. <BR>
The Alpha choice is that the accuracy provided by conversions between decimal strings and <BR>
binary floating-point numbers will meet or exceed IEEE standard requirements. It is imple-mentation <BR>
dependent whether the software binary/ decimal conversions beyond 9 or 17 digits <BR>
treat any excess digits as zeros. 
291
<BR>
<A href=#page291>291</A>
<strong><A name=page292> Page 292</A></strong>
<A href=#page293>293</A>
<BR>
<B>B– 2 </B>Alpha Architecture Handbook <BR>
Overflow and underflow, NaNs, and infinities encountered during software binary to decimal <BR>
conversion return strings that specify the conditions. <BR>
<P>
Alpha hardware supports comparisons of same-format numbers. Software supports compari-sons <BR>
of different-format numbers. <BR>
<P>
In the Alpha architecture, results are true-false in response to a predicate. <BR>
Alpha hardware supports the required six predicates and the optional unordered predicate. The <BR>
other 19 optional predicates can be constructed from sequences of two comparisons and two <BR>
branches. <BR>
<P>
Alpha hardware supports infinity arithmetic with the compare instructions (CMPTyy). When a <BR>
/S qualifier is included, Alpha hardware may optionally support infinity arithmetic when infin-ity <BR>
operands are encountered and, together with overflow disable (OVFD) and division by zero <BR>
disable (DZED), when infinity is to be generated from finite operands. Otherwise, Alpha hard-ware <BR>
supports infinity arithmetic by trapping. That is the case when an infinity operand is <BR>
encountered and when an infinity is to be created from finite operands by overflow or division <BR>
by zero. An OS completion handler (interposed between the hardware and the IEEE user) pro-vides <BR>
correct infinity arithmetic. <BR>
<P>
When a /S qualifier is included, Alpha hardware may optionally support NaNs and invalid <BR>
operations, controlled by the INVD option. Otherwise, Alpha hardware supports NaNs and <BR>
invalid operations by trapping when a NaN operand is encountered and when a NaN is to be <BR>
created. An OS completion handler (interposed between the hardware and the IEEE user) pro-vides <BR>
correct Signaling and Quiet NaN behavior. <BR>
<P>
In the Alpha architecture, Quiet NaNs do not afford retrospective diagnostic information. <BR>
In the Alpha architecture, copying a Signaling NaN without a change of format does not signal <BR>
an invalid exception (LDx, CPYSx, and STx do not check for non-finite numbers). Compilers <BR>
may generate ADDx F31,Fx, Fy to get the opposite effect. <BR>
<P>
Alpha hardware fully supports negative zero operands and follows the IEEE rules for creating <BR>
negative zero results except for underflow. When a /S qualifier is included, Alpha hardware <BR>
may optionally support underflow and denormalized numbers, controlled by the UNFD option. <BR>
Otherwise, Alpha hardware supports underflow and denormalized numbers by trapping when a <BR>
denormalized operand is encountered, when a denormalized result is created, and when an <BR>
underflow occurs. An OS completion handler (interposed between the hardware and the IEEE <BR>
user) provides correct denormalized and underflow arithmetic. <BR>
<P>
Except for the optional trap disable bits in the FPCR, Alpha hardware does not supply IEEE <BR>
exception trap behavior; the hardware traps are a superset of the IEEE-required conditions. An <BR>
OS completion handler (interposed between the hardware and the IEEE user) provides correct <BR>
IEEE exception behavior. <BR>
<P>
In the Alpha architecture, tininess is detected by hardware after rounding, and loss of accuracy <BR>
is detected by software as an inexact result. 
292
<BR>
<A href=#page292>292</A>
<strong><A name=page293> Page 293</A></strong>
<A href=#page294>294</A>
<BR>
<P>
IEEE Floating-Point Conformance <B>B– 3 <BR>
</B>In the Alpha architecture, user signal handlers are supported by compilers and an OS comple-tion <BR>
handler (interposed between the hardware and the IEEE user), as described in the next <BR>
section. <BR>
<P>
<B>B. 2 Alpha Support for OS Completion Handlers <BR>
</B>Alpha floating-point trap behavior is statically controlled by the /S, /U, and /I mode qualifiers <BR>
on floating-point instructions. Changing these options usually requires recompiling. Instruc-tions <BR>
with any valid qualifier combination that includes the /S qualifier can be dynamically <BR>
controlled by the optional trap disable bits and denormal control bits in the FPCR. <BR>
<P>
Each Alpha implementation may choose how to distribute support for the completion modes <BR>
(/ S, /SU, /SV, /SUI, and /SVI), between hardware and software. An implementation may <BR>
minimize hardware complexity by trapping to implementation software for support of excep-tions <BR>
and non-finites. An implementation may choose increased floating-point performance at <BR>
the cost of increased hardware complexity by providing hardware support for exceptions and <BR>
non-finites. <BR>
<P>
However completion mode support is distributed, application software on any system that <BR>
meets the Alpha architecture specification will see consistent floating-point semantics because <BR>
Alpha implementation software provides support for any floating-point feature that is not <BR>
directly supported by the hardware. <BR>
<P>
Each Alpha operating system must include an OS completion handler that does software com-pletion <BR>
of instructions that have any valid qualifier combination that includes the /S qualifier, <BR>
and that finishes the computation of any floating-point operation that is not completed by the <BR>
hardware. The OS completion handler is responsible for providing the result specified by the <BR>
architecture. The handler either continues execution of the application program or signals an <BR>
exception to the application. <BR>
<P>
If the exception summary parameter of an arithmetic trap indicates that an instruction requir-ing <BR>
software completion caused the trap, the operating system must finish the operation. An <BR>
OS completion handler uses the register write mask parameter to ignore instructions in the trap <BR>
shadow and to locate the trigger instruction of the arithmetic trap. The handler then uses the <BR>
trigger instruction input register values to compute the result in the output register and to <BR>
record any appropriate signal status. The handler then continues execution with the instruction <BR>
following the trigger instruction, unless the application has requested execution of an optional <BR>
signal handler. <BR>
<P>
It is recommended that the OS completion handler report an enabled IEEE exception to the <BR>
user application as a fault, rather than as a trap. When reported as a fault, the reported PC <BR>
points to the trigger instruction, rather than after the trigger instruction. Regardless of whether <BR>
an enabled fault occurs, it is recommended that the completion trap handler set the result regis-ter <BR>
and status flags to the IEEE standard nontrapping results, as defined in the IEEE Standard <BR>
section in <A href="#page144">Section 4.7. 10. </A>
That behavior makes it possible for the user application to continue <BR>
from a fault by stepping over the trigger instruction. <BR>
<P>
The Floating-Point Control Register (FPCR) contains several trap disable bits and denormal <BR>
control bits. Implementation of these bits in the FPCR is optional. A system that includes 
293
<BR>
<A href=#page293>293</A>
<strong><A name=page294> Page 294</A></strong>
<A href=#page295>295</A>
<BR>
<P>
<B>B– 4 </B>Alpha Architecture Handbook <BR>
these bits may choose to complete computations involving non-finite values without the assis-tance <BR>
of software completion. Operating systems use these FPCR bits to enable hardware <BR>
completion of instructions with any valid qualifier combination that includes /S in those cases <BR>
where the operating system does not require a trap to do exception signaling. <BR>
<P>
To get the optional full IEEE user trap handler behavior, an OS completion handler must be <BR>
provided that implements the exception status flags, dynamic user trap handler disabling, han-dler <BR>
saving and restoring, default behavior for disabled user trap handlers, and linkages that <BR>
allow a user handler to return a substitute result. OS completion handlers can use the <BR>
FP_ Control quadword, along with the floating-point control register (FPCR), to provide vari-ous <BR>
levels of IEEE-compliant behavior. <BR>
<P>
OS completion handlers provide two options for special handling of denormal numbers in <BR>
instructions that are compiled with any valid qualifier combination that includes the /S quali-fier. <BR>
These options are controlled by bits defined by implementation software in the IEEE <BR>
Floating-Point Control (FP_ C) Quadword. <BR>
<P>
<B>° </B>The first option maps all denormal results to a true zero value. That option is useful for improving the performance of IEEE compliant code that does not need gradual under-flow <BR>
<P>
and for mixing IEEE instructions that both include and do not include the /S qual-ifier. <BR>
<P>
<B>° </B>A second option treats all denormal input operands as if they were signed zeros. That option is useful for improving the performance of IEEE compliant code that encounters <BR>
spurious denormal values in uninitialized data. <BR>
The optional UNDZ and DNZ (denormal control) bits in the FPCR can assist hardware to <BR>
improve the performance of these denormal handling options. <BR>
<P>
<B>B. 2.1 IEEE Floating-Point Control (FP_ C) Quadword <BR>
</B>Operating system implementations provide the following support for an IEEE floating-point <BR>
control quadword (FP_ C), illustrated <A href="#page294">in Figure B– </A>
1 and described <A href="#page295">in Table B– </A>
1. <BR>
<P>
<B>Figure B– 1: IEEE Floating-Point Control (FP_ C) Quadword <BR>
</B><P>
<B>° </B>The operating system software completion mechanism maintains the FP_ C. Therefore, the FP_ C affects (and is affected by) only those instructions with any valid qualifier <BR>
combination that includes the /S qualifier. <BR>
<B>° </B>The FP_ C quadword is context switched when the operating system switches the thread context. (The FP_ C can be placed in a currently switched data structure.) <BR>
<P>
<B>° </B>Although the operating system can keep the FP_ C in a user mode memory location, user code may not directly access the FP_ C. <BR>
<P>
63 0 6 54 32 <BR>
Reserved <BR>
1 <BR>
N V <BR>
E <BR>
<P>
D Z <BR>
E E <BR>
O V <BR>
F E <BR>
U N <BR>
F E N E E <BR>
<P>
17 <BR>
N V <BR>
S <BR>
<P>
18 <BR>
D Z <BR>
<P>
E S <BR>
<P>
19 <BR>
O V <BR>
<P>
F S <BR>
<P>
20 <BR>
U N <BR>
<P>
F S <BR>
<P>
21 <BR>
N E <BR>
S <BR>
<P>
22 <BR>
Reserved <BR>
16 <BR>
I I I I N <BR>
<P>
O S <BR>
D <BR>
23 <BR>
<P>
N O D <BR>
7 <BR>
<P>
E 
294
<BR>
<A href=#page294>294</A>
<strong><A name=page295> Page 295</A></strong>
<A href=#page296>296</A>
<BR>
<P>
IEEE Floating-Point Conformance <B>B– 5 <BR>
° </B>Integer overflow (IOV) exceptions are controlled by the INVE enable mask bit (FP_ C&lt; 1&gt;), as allowed by the IEEE standard. Implementation software is responsible <BR>
for setting the INVS status bit (FP_ C&lt; 17&gt;) when a CVTTQ or CVTQL instruction <BR>
traps into the software completion mechanism for integer overflow . <BR>
<P>
<B>° </B>At process creation, all trap enable flags in the FP_ C are clear. The settings of other FP_ C bits, defined in <A href="#page295">Table B– 1 </A>
as reserved for implementation software, are defined <BR>
<P>
by operating system software. <BR>
At other events such as forks or thread creation, and at asynchronous routine calls such as traps <BR>
and signals, the operating system controls all assigned FP_ C bits and those defined as reserved <BR>
for implementation software. <BR>
<P>
<B>Table B– 1: Floating-Point Control (FP_ C) Quadword Bit Summary <BR>
Bit Description <BR>
</B>63– 48 Reserved for implementation software. <BR>
47– 23 Reserved for future architecture definition. <BR>
22 Denormal operand status (DNOS) <BR>
A floating arithmetic or conversion operation used a denormal operand value. <BR>
This status field is left unchanged if the system is treating denormal operand val-ues <BR>
as if they were signed zero values. If an operation with a denormal operand <BR>
causes other exceptions, all appropriate status bits are set. <BR>
<P>
21 Inexact result status (INES) <BR>
A floating arithmetic or conversion operation gave a result that differed from the <BR>
mathematically exact result. <BR>
<P>
20 Underflow status (UNFS) <BR>
A floating arithmetic or conversion operation underflowed the destination expo-nent. <BR>
<P>
19 Overflow status (OVFS) <BR>
A floating arithmetic or conversion operation overflowed the destination expo-nent. <BR>
<P>
18 Division by zero status (DZES) <BR>
An attempt was made to perform a floating divide operation with a divisor of zero. <BR>
<P>
17 Invalid operation status (INVS) <BR>
An attempt was made to perform a floating arithmetic, conversion, or comparison <BR>
operation, and one or more of the operand values were illegal. <BR>
<P>
16– 12 Reserved for implementation software. <BR>
11– 7 Reserved for future architecture definition. <BR>
6 Denormal operand exception enable (DNOE) <BR>
Initiate an INV exception if a floating arithmetic or conversion operation involves <BR>
a denormal operand value. This exception does not signal if the system is treating <BR>
denormal operand values as if they were signed zero values. If an operation can <BR>
initiate more than one enabled exception, the denormal operand exception has pri-ority. 
295
<BR>
<A href=#page295>295</A>
<strong><A name=page296> Page 296</A></strong>
<A href=#page297>297</A>
<BR>
<P>
<B>B– 6 </B>Alpha Architecture Handbook <BR>
<B>B. 3 Mapping to IEEE Standard <BR>
</B>There are five IEEE exceptions, each of which can be "IEEE software trap-enabled" or dis-abled <BR>
(the default condition). Implementing the IEEE software trap-enabled mode is optional <BR>
in the IEEE standard. <BR>
<P>
The assumption, therefore, is that the only access to IEEE-specified software trap-enabled <BR>
results will be generated in assembly language code. The following design allows this, but <I>only <BR>
</I>if such assembly language code has TRAPB instructions after each floating-point instruction, <BR>
and generates the IEEE-specified scaled result in a trap handler by emulating the instruction <BR>
that was trapped by hardware overflow/ underflow detection, using the original operands. <BR>
<P>
There is a set of detailed IEEE-specified result values, both for operations that are specified to <BR>
raise IEEE traps and those that do not. This behavior is created on Alpha by four layers of <BR>
hardware, PALcode, the operating-system completion handler, and the user signal handler, as <BR>
shown in <A href="#page297">Figure B– 2. <BR>
</A>
<P>
5 Inexact result enable (INEE) <BR>
Initiate an INE exception if the result of a floating arithmetic or conversion opera-tion <BR>
differs from the mathematically exact result. <BR>
<P>
4 Underflow enable (UNFE) <BR>
Initiate a UNF exception if a floating arithmetic or conversion operation under-flows <BR>
the destination exponent. <BR>
<P>
3 Overflow enable (OVFE) <BR>
Initiate an OVF exception if a floating arithmetic or conversion operation over-flows <BR>
the destination exponent. <BR>
<P>
2 Division by zero enable (DZEE) <BR>
Initiate a DZE exception if an attempt is made to perform a floating divide opera-tion <BR>
with a divisor of zero. <BR>
<P>
1 Invalid operation enable (INVE) <BR>
Initiate an INV exception if an attempt is made to perform a floating arithmetic, <BR>
conversion, or comparison operation, and one or more of the operand values is <BR>
illegal. <BR>
<P>
0 Reserved for implementation software. <BR>
<P>
<B>Table B– 1: Floating-Point Control (FP_ C) Quadword Bit Summary (Continued) <BR>
Bit Description </B>
296
<BR>
<A href=#page296>296</A>
<strong><A name=page297> Page 297</A></strong>
<A href=#page298>298</A>
<BR>
<P>
IEEE Floating-Point Conformance <B>B– 7 <BR>
Figure B– 2: IEEE Trap Handling Behavior <BR>
</B>The IEEE-specified trap behavior occurs <I>only </I>with respect to the user signal handler (the last <BR>
layer in <A href="#page297">Figure B– 2); </A>
any trap-and-fixup behavior in the first three layers is outside the scope <BR>
of the IEEE standard. <BR>
<P>
The IEEE number system is divided into finite and non-finite numbers: <BR>
The finites are normal numbers: <BR>
<P>
<B>° </B>–MAX..– MIN, –0, 0, +MIN..+ MAX <BR>
<B>° </B>The non-finites are: <BR>
<B>° </B>Denormals, +/– Infinity, Signaling NaN, Quiet NaN <BR>
<P>
Alpha hardware must treat minus zero operands and results as special cases, as required by the <BR>
IEEE standard. <BR>
<P>
If the DNZ (denormal operands to zero) bit in the FPCR is set or if the OS completion handler <BR>
is treating denormal operands as zero, then IEEE trap handling is done as if each denormal <BR>
operand had the corresponding signed zero value. <BR>
<P>
<A href="#page298">Table B– 2 </A>
specifies, for the IEEE /S qualifier modes, which layer does each piece of trap han-dling. <BR>
The table describes where the hardware and PALcode can trap to the OS completion <BR>
handler. However, for IEEE operations with any valid qualifier combination that includes the <BR>
/S qualifier, the system may choose not to trap to the OS completion handler, provided that any <BR>
applicable exception is disabled by the trap disable bits in the FPCR and the hardware and <BR>
PALcode can produce the expected IEEE result as modified by the denormal control bits in the <BR>
FPCR. See <A href="#page135">Section 4.7.8 </A>
for more detail on the hardware instruction descriptions. <BR>
<P>
Hardware <BR>
PALcode <BR>
<P>
User Signal Handler <BR>
<P>
Traps to PALcode <BR>
Traps to Operating System <BR>
Traps to User IEEE Trap Handler <BR>
(IEEE Standard) <BR>
<P>
Operating System 
297
<BR>
<A href=#page297>297</A>
<strong><A name=page298> Page 298</A></strong>
<A href=#page299>299</A>
<BR>
<P>
<B>B– 8 </B>Alpha Architecture Handbook <BR>
<B>Table B– 2: IEEE Floating-Point Trap Handling <BR>
Alpha Instructions Hardware 1 <BR>
PAL-Code <BR>
OS <BR>
Completion <BR>
Handler <BR>
</B><P>
<B>User <BR>
Signal <BR>
Handler <BR>
</B><P>
FBEQ FBNE FBLT FBLE FBGT <BR>
FBGE <BR>
Bits Only – No Exceptions <BR>
<P>
LDS LDT Bits Only— No Exceptions <BR>
STS STT Bits Only— No Exceptions <BR>
CPYS CPYSN Bits Only— No Exceptions <BR>
FCMOVx Bits Only— No Exceptions <BR>
<P>
<B>ADDx SUBx INPUT Exceptions: <BR>
</B>Denormal operand Trap Trap Supply sum [Denormal Op 2 ] <BR>
+/-Inf operand Trap Trap Supply sum – <BR>
QNaN operand Trap Trap Supply QNaN – <BR>
SNaN operand Trap Trap Supply QNaN [Invalid Op] <BR>
+Inf + –Inf Trap Trap Supply QNaN [Invalid Op] <BR>
<P>
<B>ADDx SUBx OUTPUT Exceptions: <BR>
</B>Exponent overflow Trap Trap Supply <BR>
+/– Inf <BR>
+/– MAX <BR>
<P>
[Overflow 3 ] <BR>
Scale by bias <BR>
adjust <BR>
<P>
Exponent underflow and disabled Supply +0 – – – 4 <BR>
<P>
Exponent underflow and enabled Supply +0 <BR>
and trap <BR>
Trap Supply <BR>
+/– MIN <BR>
denorm <BR>
+/– 0 <BR>
<P>
<A href="#page301">[Underflow 3 </A>
] <BR>
Scale by bias <BR>
adjust <BR>
<P>
Inexact and disabled – – – – <BR>
Inexact and enabled Supply sum <BR>
and trap <BR>
Trap – [Inexact] <BR>
<P>
<B>MULx INPUT Exceptions: <BR>
</B>Denormal operand Trap Trap Supply prod. [Denormal <A href="#page301">Op 2 </A>
] <BR>
+/-Inf operand Trap Trap Supply prod. – <BR>
QNaN operand Trap Trap Supply QNaN – <BR>
SNaN operand Trap Trap Supply QNaN [Invalid Op] <BR>
0 * Inf Trap Trap Supply QNaN [Invalid Op] 
298
<BR>
<A href=#page298>298</A>
<strong><A name=page299> Page 299</A></strong>
<A href=#page300>300</A>
<BR>
<P>
IEEE Floating-Point Conformance <B>B– 9 <BR>
MULx OUTPUT Exceptions: <BR>
</B>Exponent overflow Trap Trap Supply <BR>
+/– Inf <BR>
+/– MAX <BR>
<P>
[Overflow <A href="#page301">3 </A>
<A href="#page301">] <BR>
</A>
Scale by bias <BR>
adjust <BR>
<P>
Exponent underflow and disabled Supply +0 – – – <BR>
Exponent underflow and enabled Supply +0 <BR>
and Trap <BR>
Trap Supply <BR>
+/– MIN <BR>
denorm <BR>
+/– 0 <BR>
<P>
[Underflow <A href="#page301">3 ] <BR>
</A>
Scale by bias <BR>
adjust <BR>
<P>
Inexact and disabled – – – – <BR>
Inexact and enabled Supply prod. <BR>
and trap <BR>
Trap – [Inexact] <BR>
<P>
<B>DIVx INPUT Exceptions: <BR>
</B>Denormal operand Trap Trap Supply quot. [Denormal <A href="#page301">Op 2 </A>
] <BR>
<P>
+/-Inf operand Trap Trap Supply quot. – <BR>
QNaN operand Trap Trap Supply QNaN – <BR>
SNaN operand Trap Trap Supply QNaN [Invalid Op] <BR>
0/ 0 or Inf/ Inf Trap Trap Supply QNaN [Invalid Op] <BR>
A/ 0 Trap Trap Supply <BR>
+/– Inf <BR>
[Div. Zero] <BR>
<P>
<B>DIVx OUTPUT Exceptions: <BR>
</B>Exponent overflow Trap Trap Supply <BR>
+/– Inf <BR>
+/– MAX <BR>
<P>
[Overflow <A href="#page301">3 ] <BR>
</A>
Scale by bias <BR>
adjust <BR>
<P>
Exponent underflow and disabled Supply +0 – – – <BR>
Exponent underflow and enabled Supply +0 <BR>
and trap <BR>
Trap Supply <BR>
+/– MIN <BR>
denorm <BR>
+/– 0 <BR>
<P>
[Underflow <A href="#page301">3 ] <BR>
</A>
Scale by bias <BR>
adjust <BR>
<P>
Inexact and disabled – – – – <BR>
Inexact and enabled Supply quot. <BR>
and trap <BR>
Trap – [Inexact] <BR>
<P>
<B>CMPTEQ CMPTUN INPUT Exceptions: <BR>
</B>Denormal operand Trap Trap Supply (=) [Denormal <A href="#page301">Op 2 </A>
] <BR>
QNaN operand Trap Trap Supply False <BR>
for EQ, True <BR>
for UN <BR>
<P>
– <BR>
<P>
SNaN operand Trap Trap Supply <BR>
False/ True <BR>
[Invalid Op] <BR>
<P>
<B>Table B– 2: IEEE Floating-Point Trap Handling (Continued) <BR>
Alpha Instructions Hardware 1 <BR>
PAL-<BR>
Code <BR>
</B><P>
<B>OS <BR>
Completion <BR>
Handler <BR>
</B><P>
<B>User <BR>
Signal <BR>
Handler </B>
299
<BR>
<A href=#page299>299</A>
<strong><A name=page300> Page 300</A></strong>
<A href=#page301>301</A>
<BR>
<P>
<B>B– 10 </B>Alpha Architecture Handbook <BR>
<B>CMPTLT CMPTLE INPUT Exceptions: <BR>
</B>Denormal operand Trap Trap Supply £ or &lt; [Denormal <A href="#page301">Op 2 </A>
] <BR>
QNaN operand Trap Trap Supply False [Invalid Op] <BR>
SNaN operand Trap Trap Supply False [Invalid Op] <BR>
<P>
<B>CVTfi INPUT Exceptions: <BR>
</B>Denormal operand Trap Trap Supply Cvt [Denormal <A href="#page301">Op 2 </A>
] <BR>
+/-Inf operand Trap Trap Supply 0 [Invalid Op] <BR>
QNaN operand Trap Trap Supply 0 – <BR>
SNaN operand Trap Trap Supply 0 [Invalid Op] <BR>
<P>
<B>CVTfi OUTPUT Exceptions: <BR>
</B>Inexact and disabled – – – – <BR>
Inexact and enabled Supply Cvt <BR>
and trap <BR>
Trap – [Inexact] <BR>
<P>
Integer overflow Supply Trunc. <BR>
result and trap <BR>
if enabled <BR>
<P>
Trap – [Invalid Op 5 ] <BR>
<P>
<B>CVTif OUTPUT Exceptions: <BR>
</B>Inexact and disabled – – – – <BR>
Inexact and enabled Supply Cvt <BR>
and trap <BR>
Trap – [Inexact] <BR>
<P>
<B>CVTff INPUT Exceptions: <BR>
</B>Denormal operand Trap Trap Supply Cvt [Denormal <A href="#page301">Op 2 </A>
] <BR>
+/-Inf operand Trap Trap Supply Cvt – <BR>
QNaN operand Trap Trap Supply QNaN – <BR>
SNaN operand Trap Trap Supply QNaN [Invalid Op] <BR>
<P>
<B>CVTff OUTPUT Exceptions: <BR>
</B>Exponent overflow Trap Trap Supply <BR>
+/– Inf <BR>
+/– MAX <BR>
<P>
[Overflow <A href="#page301">3 ] <BR>
</A>
Scale by bias <BR>
adjust <BR>
<P>
Exponent underflow and disabled Supply +0 – – – <BR>
Exponent underflow and enabled Supply +0 <BR>
and trap <BR>
Trap Supply <BR>
+/– MIN <BR>
denorm <BR>
+/– 0 <BR>
<P>
[Underflow <A href="#page301">3 ] <BR>
</A>
Scale by bias <BR>
adjust <BR>
<P>
Inexact and disabled – – – – <BR>
Inexact and enabled Supply Cvt <BR>
and trap <BR>
Trap – [Inexact] <BR>
<P>
<B>Table B– 2: IEEE Floating-Point Trap Handling (Continued) <BR>
Alpha Instructions Hardware 1 <BR>
PAL-<BR>
Code <BR>
</B><P>
<B>OS <BR>
Completion <BR>
Handler <BR>
</B><P>
<B>User <BR>
Signal <BR>
Handler </B>
300
<BR>
<A href=#page300>300</A>
<strong><A name=page301> Page 301</A></strong>
<A href=#page302>302</A>
<BR>
<P>
IEEE Floating-Point Conformance <B>B– 11 <BR>
</B>Other IEEE operations (software subroutines or sequences of instructions) are listed here for <BR>
completeness: <BR>
Remainder Round float to integer-valued float <BR>
<P>
Convert binary to/ from decimal Compare, other combinations than the four above <BR>
<P>
<B>SQRTx INPUT Exceptions <BR>
</B>Negative nonzero operand Trap Trap Supply QNan [Invalid Op] <BR>
+/– 0 Supply +/– 0 – – – <BR>
+ Denormal operand Trap Trap Supply SQRT [Denormal <A href="#page301">Op 2 </A>
] <BR>
<P>
– Denormal operand Trap Trap Supply QNaN [Denormal Op/ <BR>
Invalid Op] <BR>
<P>
+ Infinity operand Trap Trap Supply +Inf – <BR>
– Infinity operand Trap Trap Supply QNaN [Invalid Op] <BR>
QNaN operand Trap Trap Supply QNaN – <BR>
SNaN operand Trap Trap Supply QNaN [Invalid Op] <BR>
<P>
<B>SQRTx OUTPUT Exceptions <BR>
</B>Exponent overflow Not possible <BR>
Exponent underflow Not possible <BR>
Inexact and disabled – – – – <BR>
Inexact and enabled Supply SQRT Trap – [Inexact] <BR>
<P>
1 This column describes the minimum necessary hardware support. <BR>
2 [Denormal Op] signals have priority over all other signals. <BR>
3 [Overflow] and [Underflow] signals have priority over [Inexact] signals. <BR>
4 An implementation could choose instead to trap to PALcode and have the PALcode <BR>
<P>
supply a zero result on all underflows. 5 <BR>
An implementation could choose instead to trap to PALcode on extreme values and <BR>
have the PALcode supply a truncated result on all overflows. <BR>
<P>
<B>Table B– 2: IEEE Floating-Point Trap Handling (Continued) <BR>
Alpha Instructions Hardware 1 <BR>
PAL-Code <BR>
OS <BR>
Completion <BR>
Handler <BR>
</B><P>
<B>User <BR>
Signal <BR>
Handler </B>
301
<BR>
<A href=#page301>301</A>
<strong><A name=page302> Page 302</A></strong>
<A href=#page303>303</A>
<BR>
<P>
<B>B– 12 </B>Alpha Architecture Handbook <BR>
<A href="#page302">Table B– 3 </A>
shows the IEEE standard charts. In the charts, the second column is the result when <BR>
the user signal handler is disabled; the third column is the result when that handler is enabled. <BR>
The OS completion handler supplies the IEEE default that is specified in the second column. <BR>
The contents of the Alpha registers contain sufficient information for an enabled user handler <BR>
to compute the value in the third column. <BR>
<P>
<B>Table B– 3: IEEE Standard Charts <BR>
</B><P>
<B>Exception User Signal Handler Disabled (IEEE Default) User Signal Handler Enabled (Optional) <BR>
Invalid Operation <BR>
</B>(1) Input signaling NaN Quiet NaN <BR>
(2) Mag. subtract Inf. Quiet NaN <BR>
(3) 0 * Inf. Quiet NaN <BR>
(4) 0/ 0 or Inf/ Inf Quiet NaN <BR>
(5) x REM 0 or Inf REM y Quiet NaN <BR>
(6) SQRT( negative non-zero) Quiet NaN <BR>
(7) Cvt to int( ovfl) Low-order bits <BR>
(8) Cvt to int( Inf, NaN) 0 <BR>
(9) Compare unordered Quiet NaN <BR>
<B>Division by Zero <BR>
</B><P>
x/ 0, x finite &lt;&gt; 0 +/– Inf <BR>
<B>Overflow <BR>
</B><P>
Round nearest +/– Inf. Res/ 2** 192 or 1536 <BR>
Round to zero +/– MAX Res/ 2** 192 or 1536 <BR>
Round to –Inf +MAX/– Inf Res/ 2** 192 or 1536 <BR>
Round to +Inf +Inf/– MAX Res/ 2** 192 or 1536 <BR>
<B>Underflow <BR>
</B><P>
Underflow 0/ denorm Res* 2** 192 or 1536 <BR>
<B>Inexact <BR>
</B><P>
Inexact Rounded Res 
302
<BR>
<A href=#page302>302</A>
<strong><A name=page303> Page 303</A></strong>
<A href=#page304>304</A>
<BR>
<P>
<B>C– 1 <BR>
Appendix C <BR>
Instruction Summary <BR>
</B>This appendix summarizes all instructions and opcodes in the Alpha architecture. All values <BR>
are in hexadecimal radix. <BR>
<P>
<B>C. 1 Common Architecture Instruction Summary <BR>
</B>This section summarizes all common Alpha instructions. <A href="#page303">Table C– 1 </A>
describes the contents of <BR>
the Format and Opcode columns <A href="#page304">in Table C– </A>
2. <BR>
<P>
<A href="#page304">Table C– 2 </A>
shows qualifiers for operate format instructions. Qualifiers for IEEE and VAX <BR>
floating-point instructions are shown in <A href="#page308">Sections C. </A>
2 <A href="#page309">and C. </A>
3, respectively. <BR>
<P>
<B>Table C– 1: Instruction Format and Opcode Notation <BR>
Instruction <BR>
Format <BR>
Format <BR>
Symbol <BR>
Opcode <BR>
Notation Meaning <BR>
</B><P>
Branch Bra oo <I>oo </I>is the 6-bit opcode field <BR>
Floating-point F-P oo. fff <I>oo </I>is the 6-bit opcode field <BR>
<I>fff </I>is the 11-bit function code field <BR>
<P>
Memory Mem oo <I>oo </I>is the 6-bit opcode field <BR>
Memory/ func code Mfc oo. ffff <I>oo </I>is the 6-bit opcode field <BR>
<I>ffff </I>is the 16-bit function code in the dis-placement <BR>
field <BR>
<P>
Memory/ branch Mbr oo. h <I>oo </I>is the 6-bit opcode field <BR>
h is the high-order two bits of the displace-ment <BR>
field <BR>
<P>
Operate Opr oo. ff <I>oo </I>is the 6-bit opcode field <BR>
<I>ff </I>is the 7-bit function code field <BR>
<P>
PALcode Pcd oo <I>oo </I>is the 6-bit opcode field; the particular <BR>
PALcode instruction is specified in the <BR>
26-bit function code field. 
303
<BR>
<A href=#page303>303</A>
<strong><A name=page304> Page 304</A></strong>
<A href=#page305>305</A>
<BR>
<B>C– 2 </B>Alpha Architecture Handbook <BR>
<B>Table C– 2: Common Architecture Instructions <BR>
Mnemonic Format Opcode Description <BR>
</B>ADDF F-P 15.080 Add F_ floating ADDG F-P 15.0A0 Add G_ floating <BR>
<P>
ADDL Opr 10.00 Add longword ADDL/ V 10.40 <BR>
ADDQ Opr 10.20 Add quadword ADDQ/ V 10.60 <BR>
ADDS F-P 16.080 Add S_ floating ADDT F-P 16.0A0 Add T_ floating <BR>
AMASK Opr 11.61 Architecture mask AND Opr 11.00 Logical product <BR>
BEQ Bra 39 Branch if = zero BGE Bra 3E Branch if ³ zero <BR>
BGT Bra 3F Branch if &gt; zero BIC Opr 11.08 Bit clear <BR>
BIS Opr 11.20 Logical sum BLBC Bra 38 Branch if low bit clear <BR>
BLBS Bra 3C Branch if low bit set BLE Bra 3B Branch if £ zero <BR>
BLT Bra 3A Branch if &lt; zero BNE Bra 3D <BR>
Branch if ¹ zero BR Bra 30 Unconditional branch <BR>
<P>
BSR Mbr 34 Branch to subroutine CALL_ PAL Pcd 00 Trap to PALcode <BR>
CMOVEQ Opr 11.24 CMOVE if = zero CMOVGE Opr 11.46 CMOVE if ³ zero <BR>
CMOVGT Opr 11.66 CMOVE if &gt; zero CMOVLBC Opr 11.16 CMOVE if low bit clear <BR>
CMOVLBS Opr 11.14 CMOVE if low bit set CMOVLE Opr 11.64 CMOVE if £ zero <BR>
CMOVLT Opr 11.44 CMOVE if &lt; zero CMOVNE Opr 11.26 <BR>
CMOVE if ¹ zero CMPBGE Opr 10.0F Compare byte <BR>
<P>
CMPEQ Opr 10.2D Compare signed quadword equal CMPGEQ F-P 15.0A5 Compare G_ floating equal <BR>
CMPGLE F-P 15.0A7 Compare G_ floating less than or equal CMPGLT F-P 15.0A6 Compare G_ floating less than <BR>
CMPLE Opr 10.6D Compare signed quadword less than or equal CMPLT Opr 10.4D Compare signed quadword less than <BR>
CMPTEQ F-P 16.0A5 Compare T_ floating equal CMPTLE F-P 16.0A7 Compare T_ floating less than or equal <BR>
CMPTLT F-P 16.0A6 Compare T_ floating less than CMPTUN F-P 16. 0A4 Compare T_ floating unordered <BR>
CMPULE Opr 10.3D Compare unsigned quadword less than or equal CMPULT Opr 10.1D Compare unsigned quadword less than <BR>
CPYS F-P 17.020 Copy sign CPYSE F-P 17.022 Copy sign and exponent <BR>
CPYSN F-P 17.021 Copy sign negate CTLZ Opr 1C. 32 Count leading zero <BR>
CTPOP Opr 1C. 30 Count population CTTZ Opr 1C. 33 Count trailing zero <BR>
CVTDG F-P 15.09E Convert D_ floating to G_ floating CVTGD F-P 15.0AD Convert G_ floating to D_ floating <BR>
CVTGF F-P 15.0AC Convert G_ floating to F_ floating 
304
<BR>
<A href=#page304>304</A>
<strong><A name=page305> Page 305</A></strong>
<A href=#page306>306</A>
<BR>
Instruction Summary <B>C– 3 <BR>
</B>CVTGQ F-P 15.0AF Convert G_ floating to quadword CVTLQ F-P 17.010 Convert longword to quadword <BR>
CVTQF F-P 15.0BC Convert quadword to F_ floating CVTQG F-P 15.0BE Convert quadword to G_ floating <BR>
CVTQL F-P 17.030 Convert quadword to longword CVTQS F-P 16.0BC Convert quadword to S_ floating <BR>
CVTQT F-P 16.0BE Convert quadword to T_ floating CVTST F-P 16.2AC Convert S_ floating to T_ floating <BR>
CVTTQ F-P 16.0AF Convert T_ floating to quadword CVTTS F-P 16.0AC Convert T_ floating to S_ floating <BR>
DIVF F-P 15.083 Divide F_ floating DIVG F-P 15.0A3 Divide G_ floating <BR>
DIVS F-P 16.083 Divide S_ floating DIVT F-P 16.0A3 Divide T_ floating <BR>
ECB Mfc 18.E800 Evict cache block EQV Opr 11.48 Logical equivalence <BR>
EXCB Mfc 18.0400 Exception barrier EXTBL Opr 12.06 Extract byte low <BR>
EXTLH Opr 12.6A Extract longword high EXTLL Opr 12.26 Extract longword low <BR>
EXTQH Opr 12.7A Extract quadword high EXTQL Opr 12.36 Extract quadword low <BR>
EXTWH Opr 12.5A Extract word high EXTWL Opr 12.16 Extract word low <BR>
FBEQ Bra 31 Floating branch if = zero FBGE Bra 36 Floating branch if ³ zero <BR>
FBGT Bra 37 Floating branch if &gt; zero FBLE Bra 33 Floating branch if £ zero <BR>
FBLT Bra 32 Floating branch if &lt; zero FBNE Bra 35 <BR>
Floating branch if ¹ zero FCMOVEQ F-P 17.02A FCMOVE if = zero <BR>
<P>
FCMOVGE F-P 17.02D FCMOVE if ³ zero FCMOVGT F-P 17.02F FCMOVE if &gt; zero <BR>
FCMOVLE F-P 17.02E FCMOVE if £ zero FCMOVLT F-P 17.02C FCMOVE if &lt; zero <BR>
FCMOVNE F-P 17.02B FCMOVE if ¹ zero <BR>
FETCH Mfc 18. 8000 Prefetch data FETCH_ M Mfc 18. A000 Prefetch data, modify intent <BR>
<P>
FTOIS F-P 1C. 78 Floating to integer move, S_ floating FTOIT F-P 1C. 70 Floating to integer move, T_ floating <BR>
IMPLVER Opr 11.6C Implementation version INSBL Opr 12.0B Insert byte low <BR>
INSLH Opr 12.67 Insert longword high INSLL Opr 12.2B Insert longword low <BR>
INSQH Opr 12.77 Insert quadword high INSQL Opr 12.3B Insert quadword low <BR>
INSWH Opr 12.57 Insert word high INSWL Opr 12.1B Insert word low <BR>
ITOFF F-P 14.014 Integer to floating move, F_ floating ITOFS F-P 14.004 Integer to floating move, S_ floating <BR>
ITOFT F-P 14.024 Integer to floating move, T_ floating JMP Mbr 1A. 0 Jump <BR>
JSR Mbr 1A. 1 Jump to subroutine JSR_ COROUTINE Mbr 1A. 3 Jump to subroutine return <BR>
<P>
<B>Table C– 2: Common Architecture Instructions (Continued) <BR>
Mnemonic Format Opcode Description </B>
305
<BR>
<A href=#page305>305</A>
<strong><A name=page306> Page 306</A></strong>
<A href=#page307>307</A>
<BR>
<B>C– 4 </B>Alpha Architecture Handbook <BR>
LDA Mem 08 Load address LDAH Mem 09 Load address high <BR>
LDBU Mem 0A Load zero-extended byte LDWU Mem 0C Load zero-extended word <BR>
LDF Mem 20 Load F_ floating LDG Mem 21 Load G_ floating <BR>
LDL Mem 28 Load sign-extended longword LDL_ L Mem 2A Load sign-extended longword locked <BR>
LDQ Mem 29 Load quadword LDQ_ L Mem 2B Load quadword locked <BR>
LDQ_ U Mem 0B Load unaligned quadword LDS Mem 22 Load S_ floating <BR>
LDT Mem 23 Load T_ floating MAXSB8 Opr 1C. 3E Vector signed byte maximum <BR>
MAXSW4 Opr 1C. 3F Vector signed word maximum MAXUB8 Opr 1C. 3C Vector unsigned byte maximum <BR>
MAXUW4 Opr 1C. 3D Vector unsigned word maximum MB Mfc 18. 4000 Memory barrier <BR>
MF_ FPCR F-P 17. 025 Move from FPCR MINSB8 Opr 1C. 38 Vector signed byte minimum <BR>
MINSW4 Opr 1C. 39 Vector signed word minimum MINUB8 Opr 1C. 3A Vector unsigned byte minimum <BR>
MINUW4 Opr 1C. 3B Vector unsigned word minimum MSKBL Opr 12.02 Mask byte low <BR>
MSKLH Opr 12.62 Mask longword high MSKLL Opr 12.22 Mask longword low <BR>
MSKQH Opr 12.72 Mask quadword high MSKQL Opr 12.32 Mask quadword low <BR>
MSKWH Opr 12.52 Mask word high MSKWL Opr 12.12 Mask word low <BR>
MT_ FPCR F-P 17.024 Move to FPCR MULF F-P 15.082 Multiply F_ floating <BR>
MULG F-P 15.0A2 Multiply G_ floating MULL Opr 13.00 Multiply longword <BR>
MULL/ V 13.40 MULQ Opr 13.20 Multiply quadword <BR>
MULQ/ V 13. 60 MULS F-P 16.082 Multiply S_ floating <BR>
MULT F-P 16.0A2 Multiply T_ floating ORNOT Opr 11.28 Logical sum with complement <BR>
PERR Opr 1C. 31 Pixel error PKLB Opr 1C. 37 Pack longwords to bytes <BR>
PKWB Opr 1C. 36 Pack words to bytes RC Mfc 18. E000 Read and clear <BR>
RET Mbr 1A. 2 Return from subroutine RPCC Mfc 18.C000 Read process cycle counter <BR>
RS Mfc 18.F000 Read and set S4ADDL Opr 10.02 Scaled add longword by 4 <BR>
S4ADDQ Opr 10.22 Scaled add quadword by 4 S4SUBL Opr 10.0B Scaled subtract longword by 4 <BR>
S4SUBQ Opr 10.2B Scaled subtract quadword by 4 S8ADDL Opr 10.12 Scaled add longword by 8 <BR>
S8ADDQ Opr 10.32 Scaled add quadword by 8 S8SUBL Opr 10.1B Scaled subtract longword by 8 <BR>
<P>
<B>Table C– 2: Common Architecture Instructions (Continued) <BR>
Mnemonic Format Opcode Description </B>
306
<BR>
<A href=#page306>306</A>
<strong><A name=page307> Page 307</A></strong>
<A href=#page308>308</A>
<BR>
Instruction Summary <B>C– 5 <BR>
</B>S8SUBQ Opr 10.3B Scaled subtract quadword by 8 SEXTB Opr 1C. 00 Sign extend byte <BR>
SEXTW Opr 1C. 01 Sign extend word SLL Opr 12.39 Shift left logical <BR>
SQRTF F-P 14.08A Square root F_ floating SQRTG F-P 14.0AA Square root G_ floating <BR>
SQRTS F-P 14.08B Square root S_ floating SQRTT F-P 14.0AB Square root T_ floating <BR>
SRA Opr 12.3C Shift right arithmetic SRL Opr 12.34 Shift right logical <BR>
STB Mem 0E Store byte STF Mem 24 Store F_ floating <BR>
STG Mem 25 Store G_ floating STS Mem 26 Store S_ floating <BR>
STL Mem 2C Store longword STL_ C Mem 2E Store longword conditional <BR>
STQ Mem 2D Store quadword STQ_ C Mem 2F Store quadword conditional <BR>
STQ_ U Mem 0F Store unaligned quadword STT Mem 27 Store T_ floating <BR>
STW Mem 0D Store word SUBF F-P 15.081 Subtract F_ floating <BR>
SUBG F-P 15.0A1 Subtract G_ floating SUBL Opr 10.09 Subtract longword <BR>
SUBL/ V 10.49 SUBQ Opr 10.29 Subtract quadword <BR>
SUBQ/ V 10.69 SUBS F-P 16.081 Subtract S_ floating <BR>
SUBT F-P 16.0A1 Subtract T_ floating TRAPB Mfc 18. 0000 Trap barrier <BR>
UMULH Opr 13.30 Unsigned multiply quadword high UNPKBL Opr 1C. 35 Unpack bytes to longwords <BR>
UNPKBW Opr 1C. 34 Unpack bytes to words WH64 Mfc 18.F800 Write hint — 64 bytes <BR>
WMB Mfc 18.4400 Write memory barrier XOR Opr 11.40 Logical difference <BR>
ZAP Opr 12.30 Zero bytes ZAPNOT Opr 12.31 Zero bytes not <BR>
<P>
<B>Table C– 2: Common Architecture Instructions (Continued) <BR>
Mnemonic Format Opcode Description </B>
307
<BR>
<A href=#page307>307</A>
<strong><A name=page308> Page 308</A></strong>
<A href=#page309>309</A>
<BR>
<P>
<B>C– 6 </B>Alpha Architecture Handbook <BR>
<B>C. 2 IEEE Floating-Point Instructions <BR>
<A href="#page308">Table C– 3 </A>
lists the hexadecimal value of the 11-bit function code field for the IEEE float-ing-<BR>
point instructions, with and without qualifiers. The opcode for the following instructions is <BR>
16 16 , except for SQRTS and SQRTT, which are opcode 14 16 . <BR>
<P>
<B>Table C– 3: IEEE Floating-Point Instruction Function Codes <BR>
None /C /M /D /U /UC /UM /UD <BR>
ADDS </B>080 000 040 0C0 180 100 140 1C0 <B>ADDT </B>0A0 020 060 0E0 1A0 120 160 1E0 <BR>
<P>
<B>CMPTEQ </B>0A5 <B>CMPTLE </B>0A7 <BR>
<B>CMPTLT </B>0A6 <B>CMPTUN </B>0A4 <BR>
<B>CVTQS </B>0BC 03C 07C 0FC <B>CVTQT </B>0BE 03E 07E 0FE <BR>
<B>CVTST </B>See below <B>CVTTQ </B>See below <BR>
<B>CVTTS </B>0AC 02C 06C 0EC 1AC 12C 16C 1EC <B>DIVS </B>083 003 043 0C3 183 103 143 1C3 <BR>
<B>DIVT </B>0A3 023 063 0E3 1A3 123 163 1E3 <B>MULS </B>082 002 042 0C2 182 102 142 1C2 <BR>
<B>MULT </B>0A2 022 062 0E2 1A2 122 162 1E2 <B>SQRTS </B>08B 00B 04B 0CB 18B 10B 14B 1CB <BR>
<B>SQRTT </B>0AB 02B 06B 0EB 1AB 12B 16B 1EB <B>SUBS </B>081 001 041 0C1 181 101 141 1C1 <BR>
<B>SUBT </B>0A1 021 061 0E1 1A1 121 161 1E1 <BR>
<P>
<B>/SU /SUC /SUM /SUD /SUI /SUIC /SUIM /SUID <BR>
ADDS </B>580 500 540 5C0 780 700 740 7C0 <B>ADDT </B>5A0 520 560 5E0 7A0 720 760 7E0 <BR>
<P>
<B>CMPTEQ </B>5A5 <B>CMPTLE </B>5A7 <BR>
<B>CMPTLT </B>5A6 <B>CMPTUN </B>5A4 <BR>
<B>CVTQS </B>7BC 73C 77C 7FC <B>CVTQT </B>7BE 73E 77E 7FE <BR>
<B>CVTTS </B>5AC 52C 56C 5EC 7AC 72C 76C 7EC <B>DIVS </B>583 503 543 5C3 783 703 743 7C3 <BR>
<B>DIVT </B>5A3 523 563 5E3 7A3 723 763 7E3 <B>MULS </B>582 502 542 5C2 782 702 742 7C2 <BR>
<B>MULT </B>5A2 522 562 5E2 7A2 722 762 7E2 <B>SQRTS </B>58B 50B 54B 5CB 78B 70B 74B 7CB <BR>
<B>SQRTT </B>5AB 52B 56B 5EB 7AB 72B 76B 7EB <B>SUBS </B>581 501 541 5C1 781 701 741 7C1 <BR>
<B>SUBT </B>5A1 521 561 5E1 7A1 721 761 7E1 <BR>
<P>
<B>None /S <BR>
CVTST </B>2AC 6AC 
308
<BR>
<A href=#page308>308</A>
<strong><A name=page309> Page 309</A></strong>
<A href=#page310>310</A>
<BR>
<P>
Instruction Summary <B>C– 7 <BR>
Programming Note: <BR>
</B>To use CMPTxx with software completion trap handling, specify the /SU IEEE trap mode, <BR>
even though an underflow trap is not possible. To use CVTQS or CVTQT with software <BR>
completion trap handling, specify the /SUI IEEE trap mode, even though an underflow trap <BR>
is not possible. <BR>
<P>
<B>C. 3 VAX Floating-Point Instructions <BR>
<A href="#page309">Table C– 4 </A>
lists the hexadecimal value of the 11-bit function code field for the VAX float-ing-<BR>
point instructions. The opcode for the following instructions is 15 16 , except for SQRTF <BR>
<P>
and SQRTG, which are opcode 14 16 . <BR>
<P>
<B>None /C /V /VC /SV /SVC /SVI /SVIC <BR>
CVTTQ </B>0AF 02F 1AF 12F 5AF 52F 7AF 72F <BR>
<P>
/D <B>/VD /SVD /SVID /M /VM /SVM /SVIM <BR>
CVTTQ </B>0EF 1EF 5EF 7EF 06F 16F 56F 76F <BR>
<P>
<B>Table C– 4: VAX Floating-Point Instruction Function Codes <BR>
None /C /U /UC /S /SC /SU /SUC <BR>
ADDF </B>080 000 180 100 480 400 580 500 <B>CVTDG </B>09E 01E 19E 11E 49E 41E 59E 51E <BR>
<P>
<B>ADDG </B>0A0 020 1A0 120 4A0 420 5A0 520 <B>CMPGEQ </B>0A5 4A5 <BR>
<B>CMPGLE </B>0A7 4A6 <B>CMPGLT </B>0A6 4A7 <BR>
<B>CVTGD </B>0AD 02D 1AD 12D 4AD 42D 5AD 52D <B>CVTGF </B>0AC 02C 1AC 12C 4AC 42C 5AC 52C <BR>
<B>CVTQF </B>0BC 03C <B>CVTQG </B>0BE 03E <BR>
<B>CVTGQ </B>See below <B>DIVF </B>083 003 183 103 483 403 583 503 <BR>
<B>DIVG </B>0A3 023 1A3 123 4A3 423 5A3 523 <B>MULF </B>082 002 182 102 482 402 582 502 <BR>
<B>MULG </B>0A2 022 1A2 122 4A2 422 5A2 522 <B>SQRTF </B>08A 00A 18A 10A 48A 40A 58A 50A <BR>
<B>SQRTG </B>0AA 02A 1AA 12A 4AA 42A 5AA 52A <B>SUBF </B>081 001 181 101 481 401 581 501 <BR>
<B>SUBG </B>0A1 021 1A1 121 4A1 421 5A1 521 <BR>
<P>
<B>None /C /V /VC /S /SC /SV /SVC <BR>
CVTGQ </B>0AF 02F 1AF 12F 4AF 42F 5AF 52F <BR>
<P>
<B>Table C– 3: IEEE Floating-Point Instruction Function Codes (Continued) </B>
309
<BR>
<A href=#page309>309</A>
<strong><A name=page310> Page 310</A></strong>
<A href=#page311>311</A>
<BR>
<P>
<B>C– 8 </B>Alpha Architecture Handbook <BR>
<B>C. 4 Independent Floating-Point Instructions <BR>
<A href="#page310">Table C– 5 </A>
lists the hexadecimal value of the 11-bit function code field for the floating-point <BR>
instructions that are not directly tied to IEEE or VAX floating point. The opcode for the fol-lowing <BR>
instructions is 17 16 . <BR>
<P>
<B>C. 5 Opcode Summary <BR>
<A href="#page311">Table C– 6 </A>
lists all Alpha opcodes from 00 (CALL_ PAL) through 3F (BGT). In the table, the <BR>
column headings that appear over the instructions have a granularity of 8 16 . The rows beneath <BR>
<P>
the leftmost column supply the individual hex number to resolve that granularity. <BR>
<P>
If an instruction column has a 0 (zero) in the right (low) hex digit, replace that 0 with the num-ber <BR>
to the left of the backslash in the leftmost column on the instruction's row. If an instruction <BR>
column has an 8 in the right (low) hexadecimal digit, replace that 8 with the number to the <BR>
right of the backslash in the leftmost column. <BR>
<P>
For example, the third row (2/ A) under the 10 column contains the symbol INTS*, represent-ing <BR>
all the integer shift instructions. The opcode for those instructions would then be 12 16 <BR>
<P>
because the 0 in 10 is replaced by the 2 in the leftmost column. Likewise, the third row under <BR>
the 18 column contains the symbol JSR*, representing all jump instructions. The opcode for <BR>
those instructions is 1A because the 8 in the heading is replaced by the number to the right of <BR>
the backslash in the leftmost column. <BR>
<P>
<B>Table C– 5: Independent Floating-Point Instruction Function Codes <BR>
None /V /SV <BR>
CPYS </B>020 <B>CPYSE </B>022 <BR>
<P>
<B>CPYSN </B>021 <B>CVTLQ </B>010 <BR>
<B>CVTQL </B>030 130 530 <B>FCMOVEQ </B>02A <BR>
<B>FCMOVGE </B>02D <B>FCMOVGT </B>02F <BR>
<B>FCMOVLE </B>02E <B>FCMOVLT </B>02C <BR>
<B>MF_ FPCR </B>025 <B>MT_ FPCR </B>024 
310
<BR>
<A href=#page310>310</A>
<strong><A name=page311> Page 311</A></strong>
<A href=#page312>312</A>
<BR>
<P>
Instruction Summary <B>C– 9 <BR>
</B>The instruction format is listed under the instruction symbol. The symbols in <A href="#page311">Table C– 6 </A>
are <BR>
explained in <A href="#page311">Table C– 7. <BR>
</A>
<P>
<B>Table C– 6: Opcode Summary <BR>
00 08 10 18 20 28 30 38 <BR>
0/ 8 </B>PAL* <BR>
(pal) <BR>
LDA <BR>
(mem) <BR>
INTA* <BR>
(op) <BR>
MISC* <BR>
(mem) <BR>
LDF <BR>
(mem) <BR>
LDL <BR>
(mem) <BR>
BR <BR>
(br) <BR>
BLBC <BR>
(br) <BR>
<P>
<B>1/ 9 </B>Res LDAH <BR>
(mem) <BR>
INTL* <BR>
(op) \ <BR>
PAL \ LDG <BR>
(mem) <BR>
LDQ <BR>
(mem) <BR>
FBEQ <BR>
(br) <BR>
BEQ <BR>
(br) <BR>
<P>
<B>2/ A </B>Res LDBU <BR>
(mem) <BR>
INTS* <BR>
(op) <BR>
JSR* <BR>
(mem) <BR>
LDS <BR>
(mem) <BR>
LDL_ L <BR>
(mem) <BR>
FBLT <BR>
(br) <BR>
BLT <BR>
(br) <BR>
<P>
<B>3/ B </B>Res LDQ_ U <BR>
(mem) <BR>
INTM* <BR>
(op) \ <BR>
PAL \ LDT <BR>
(mem) <BR>
LDQ_ L <BR>
(mem) <BR>
FBLE <BR>
(br) <BR>
BLE <BR>
(br) <BR>
<P>
<B>4/ C </B>Res LDWU <BR>
(mem) <BR>
ITFP* FPTI* STF <BR>
(mem) <BR>
STL <BR>
(mem) <BR>
BSR <BR>
(br) <BR>
BLBS <BR>
(br) <BR>
<P>
<B>5/ D </B>Res STW <BR>
(mem) <BR>
FLTV* <BR>
(op) \PAL\ <BR>
STG <BR>
(mem) <BR>
STQ <BR>
(mem) <BR>
FBNE <BR>
(br) <BR>
BNE <BR>
(br) <BR>
<P>
<B>6/ E </B>Res STB <BR>
(mem) <BR>
FLTI* <BR>
(op) \ <BR>
PAL \ STS <BR>
(mem) <BR>
STL_ C <BR>
(mem) <BR>
FBGE <BR>
(br) <BR>
BGE <BR>
(br) <BR>
<P>
<B>7/ F </B>Res STQ_ U <BR>
(mem) <BR>
FLTL* <BR>
(op) \ <BR>
PAL \ STT <BR>
(mem) <BR>
STQ_ C <BR>
(mem) <BR>
FBGT <BR>
(br) <BR>
BGT <BR>
(br) <BR>
<P>
<B>Table C– 7: Key to Opcode Summary <BR>
Symbol Meaning <BR>
</B>FLTI* IEEE floating-point instruction opcodes <BR>
FLTL* Floating-point Operate instruction opcodes <BR>
FLTV* VAX floating-point instruction opcodes <BR>
FPTI* Floating-point to integer register move opcodes <BR>
INTA* Integer arithmetic instruction opcodes <BR>
INTL* Integer logical instruction opcodes <BR>
INTM* Integer multiply instruction opcodes <BR>
INTS* Integer shift instruction opcodes <BR>
ITFP* Integer to floating-point register move opcodes <BR>
JSR* Jump instruction opcodes <BR>
MISC* Miscellaneous instruction opcodes <BR>
PAL* PALcode instruction (CALL_ PAL) opcodes <BR>
<P>
\ PAL \ Reserved for PALcode <BR>
Res Reserved for Compaq 
311
<BR>
<A href=#page311>311</A>
<strong><A name=page312> Page 312</A></strong>
<A href=#page313>313</A>
<BR>
<B>C– 10 </B>Alpha Architecture Handbook <BR>
<B>C. 6 Common Architecture Opcodes in Numerical Order <BR>
Table C– 8: Common Architecture Opcodes in Numerical Order <BR>
Opcode Opcode Opcode <BR>
</B>00 CALL_ PAL 11.26 CMOVNE 14.014 ITOFF <BR>
01 OPC01 11.28 ORNOT 14.024 ITOFT <BR>
02 OPC02 11.40 XOR 14.02A SQRTG/ C <BR>
03 OPC03 11.44 CMOVLT 14.02B SQRTT/ C <BR>
04 OPC04 11.46 CMOVGE 14.04B SQRTS/ M <BR>
05 OPC05 11.48 EQV 14.06B SQRTT/ M <BR>
06 OPC06 11.61 AMASK 14.08A SQRTF <BR>
07 OPC07 11.64 CMOVLE 14.08B SQRTS <BR>
08 LDA 11.66 CMOVGT 14.0AA SQRTG <BR>
09 LDAH 11.6C IMPLVER 14.0AB SQRTT <BR>
0A LDBU 12.02 MSKBL 14.0CB SQRTS/ D <BR>
0B LDQ_ U 12.06 EXTBL 14.0EB SQRTT/ D <BR>
0C LDWU 12.0B INSBL 14.10A SQRTF/ UC <BR>
0D STW 12.12 MSKWL 14.10B SQRTS/ UC <BR>
0E STB 12.16 EXTWL 14.12A SQRTG/ UC <BR>
0F STQ_ U 12.1B INSWL 14.12B SQRTT/ UC <BR>
10. 00 ADDL 12.22 MSKLL 14.14B SQRTS/ UM <BR>
10. 02 S4ADDL 12.26 EXTLL 14.16B SQRTT/ UM <BR>
10. 09 SUBL 12.2B INSLL 14.18A SQRTF/ U <BR>
10. 0B S4SUBL 12.30 ZAP 14.18B SQRTS/ U <BR>
10. 0F CMPBGE 12.31 ZAPNOT 14.1AA SQRTG/ U <BR>
10. 12 S8ADDL 12.32 MSKQL 14.1AB SQRTT/ U <BR>
10. 1B S8SUBL 12.34 SRL 14.1CB SQRTS/ UD <BR>
10. 1D CMPULT 12.36 EXTQL 14.1EB SQRTT/ UD <BR>
10. 20 ADDQ 12.39 SLL 14.40A SQRTF/ SC <BR>
10. 22 S4ADDQ 12.3B INSQL 14.42A SQRTG/ SC <BR>
10. 29 SUBQ 12.3C SRA 14.48A SQRTF/ S <BR>
10. 2B S4SUBQ 12.52 MSKWH 14.4AA SQRTG/ S <BR>
10. 2D CMPEQ 12.57 INSWH 14.50A SQRTF/ SUC <BR>
10. 32 S8ADDQ 12.5A EXTWH 14.50B SQRTS/ SUC <BR>
10. 3B S8SUBQ 12.62 MSKLH 14.52A SQRTG/ SUC <BR>
10. 3D CMPULE 12.67 INSLH 14.52B SQRTT/ SUC <BR>
10. 40 ADDL/ V 12.6A EXTLH 14.54B SQRTS/ SUM <BR>
10. 49 SUBL/ V 12.72 MSKQH 14.56B SQRTT/ SUM <BR>
10. 4D CMPLT 12.77 INSQH 14.58A SQRTF/ SU <BR>
10. 60 ADDQ/ V 12.7A EXTQH 14.58B SQRTS/ SU <BR>
10. 69 SUBQ/ V 13.00 MULL 14.5AA SQRTG/ SU <BR>
10. 6D CMPLE 13.20 MULQ 14.5AB SQRTT/ SU <BR>
11. 00 AND 13.30 UMULH 14.5CB SQRTS/ SUD <BR>
11. 08 BIC 13.40 MULL/ V 14.5EB SQRTT/ SUD <BR>
11. 14 CMOVLBS 13.60 MULQ/ V 14.70B SQRTS/ SUIC <BR>
11. 16 CMOVLBC 14.004 ITOFS 14.72B SQRTT/ SUIC <BR>
11. 20 BIS 14.00A SQRTF/ C 14.74B SQRTS/ SUIM <BR>
11. 24 CMOVEQ 14.00B SQRTS/ C 14.76B SQRTT/ SUIM 
312
<BR>
<A href=#page312>312</A>
<strong><A name=page313> Page 313</A></strong>
<A href=#page314>314</A>
<BR>
Instruction Summary <B>C– 11 <BR>
</B>14. 78B SQRTS/ SUI 15.12F CVTGQ/ VC 15.521 SUBG/ SUC <BR>
14. 7AB SQRTT/ SUI 15.180 ADDF/ U 15.522 MULG/ SUC <BR>
14. 7CB SQRTS/ SUID 15.181 SUBF/ U 15.523 DIVG/ SUC <BR>
14. 7EB SQRTT/ SUID 15.182 MULF/ U 15.52C CVTGF/ SUC <BR>
15. 000 ADDF/ C 15.183 DIVF/ U 15.52D CVTGD/ SUC <BR>
15. 001 SUBF/ C 15.19E CVTDG/ U 15.52F CVTGQ/ SVC <BR>
15. 002 MULF/ C 15.1A0 ADDG/ U 15.580 ADDF/ SU <BR>
15. 003 DIVF/ C 15.1A1 SUBG/ U 15.581 SUBF/ SU <BR>
15. 01E CVTDG/ C 15.1A2 MULG/ U 15.582 MULF/ SU <BR>
15. 020 ADDG/ C 15.1A3 DIVG/ U 15.583 DIVF/ SU <BR>
15. 021 SUBG/ C 15.1AC CVTGF/ U 15.59E CVTDG/ SU <BR>
15. 022 MULG/ C 15.1AD CVTGD/ U 15.5A0 ADDG/ SU <BR>
15. 023 DIVG/ C 15.1AF CVTGQ/ V 15.5A1 SUBG/ SU <BR>
15. 02C CVTGF/ C 15.400 ADDF/ SC 15.5A2 MULG/ SU <BR>
15. 02D CVTGD/ C 15.401 SUBF/ SC 15.5A3 DIVG/ SU <BR>
15. 02F CVTGQ/ C 15.402 MULF/ SC 15.5AC CVTGF/ SU <BR>
15. 03C CVTQF/ C 15.403 DIVF/ SC 15.5AD CVTGD/ SU <BR>
15. 03E CVTQG/ C 15.41E CVTDG/ SC 15.5AF CVTGQ/ SV <BR>
15. 080 ADDF 15.420 ADDG/ SC 16.000 ADDS/ C <BR>
15. 081 SUBF 15.421 SUBG/ SC 16.001 SUBS/ C <BR>
15. 082 MULF 15.422 MULG/ SC 16.002 MULS/ C <BR>
15. 083 DIVF 15.423 DIVG/ SC 16.003 DIVS/ C <BR>
15. 09E CVTDG 15.42C CVTGF/ SC 16.020 ADDT/ C <BR>
15. 0A0 ADDG 15.42D CVTGD/ SC 16.021 SUBT/ C <BR>
15. 0A1 SUBG 15.42F CVTGQ/ SC 16.022 MULT/ C <BR>
15. 0A2 MULG 15.480 ADDF/ S 16.023 DIVT/ C <BR>
15. 0A3 DIVG 15.481 SUBF/ S 16.02C CVTTS/ C <BR>
15. 0A5 CMPGEQ 15.482 MULF/ S 16.02F CVTTQ/ C <BR>
15. 0A6 CMPGLT 15.483 DIVF/ S 16.03C CVTQS/ C <BR>
15. 0A7 CMPGLE 15.49E CVTDG/ S 16.03E CVTQT/ C <BR>
15. 0AC CVTGF 15.4A0 ADDG/ S 16.040 ADDS/ M <BR>
15. 0AD CVTGD 15.4A1 SUBG/ S 16.041 SUBS/ M <BR>
15. 0AF CVTGQ 15.4A2 MULG/ S 16.042 MULS/ M <BR>
15. 0BC CVTQF 15.4A3 DIVG/ S 16.043 DIVS/ M <BR>
15. 0BE CVTQG 15.4A5 CMPGEQ/ S 16.060 ADDT/ M <BR>
15. 100 ADDF/ UC 15.4A6 CMPGLT/ S 16.061 SUBT/ M <BR>
15. 101 SUBF/ UC 15.4A7 CMPGLE/ S 16.062 MULT/ M <BR>
15. 102 MULF/ UC 15.4AC CVTGF/ S 16.063 DIVT/ M <BR>
15. 103 DIVF/ UC 15.4AD CVTGD/ S 16.06C CVTTS/ M <BR>
15. 11E CVTDG/ UC 15.4AF CVTGQ/ S 16.06F CVTTQ/ M <BR>
15. 120 ADDG/ UC 15.500 ADDF/ SUC 16.07C CVTQS/ M <BR>
15. 121 SUBG/ UC 15.501 SUBF/ SUC 16.07E CVTQT/ M <BR>
15. 122 MULG/ UC 15.502 MULF/ SUC 16.080 ADDS <BR>
15. 123 DIVG/ UC 15.503 DIVF/ SUC 16.081 SUBS <BR>
15. 12C CVTGF/ UC 15.51E CVTDG/ SUC 16.082 MULS <BR>
15. 12D CVTGD/ UC 15.520 ADDG/ SUC 16.083 DIVS <BR>
<P>
<B>Table C– 8: Common Architecture Opcodes in Numerical Order (Continued) <BR>
Opcode Opcode Opcode </B>
313
<BR>
<A href=#page313>313</A>
<strong><A name=page314> Page 314</A></strong>
<A href=#page315>315</A>
<BR>
<B>C– 12 </B>Alpha Architecture Handbook <BR>
16. 0A0 ADDT 16.182 MULS/ U 16.5A3 DIVT/ SU <BR>
16. 0A1 SUBT 16.183 DIVS/ U 16.5A4 CMPTUN/ SU <BR>
16. 0A2 MULT 16.1A0 ADDT/ U 16.5A5 CMPTEQ/ SU <BR>
16. 0A3 DIVT 16.1A1 SUBT/ U 16.5A6 CMPTLT/ SU <BR>
16. 0A4 CMPTUN 16.1A2 MULT/ U 16.5A7 CMPTLE/ SU <BR>
16. 0A5 CMPTEQ 16.1A3 DIVT/ U 16.5AC CVTTS/ SU <BR>
16. 0A6 CMPTLT 16.1AC CVTTS/ U 16.5AF CVTTQ/ SV <BR>
16. 0A7 CMPTLE 16.1AF CVTTQ/ V 16.5C0 ADDS/ SUD <BR>
16. 0AC CVTTS 16.1C0 ADDS/ UD 16.5C1 SUBS/ SUD <BR>
16. 0AF CVTTQ 16.1C1 SUBS/ UD 16.5C2 MULS/ SUD <BR>
16. 0BC CVTQS 16.1C2 MULS/ UD 16.5C3 DIVS/ SUD <BR>
16. 0BE CVTQT 16.1C3 DIVS/ UD 16.5E0 ADDT/ SUD <BR>
16. 0C0 ADDS/ D 16.1E0 ADDT/ UD 16.5E1 SUBT/ SUD <BR>
16. 0C1 SUBS/ D 16.1E1 SUBT/ UD 16.5E2 MULT/ SUD <BR>
16. 0C2 MULS/ D 16.1E2 MULT/ UD 16.5E3 DIVT/ SUD <BR>
16. 0C3 DIVS/ D 16.1E3 DIVT/ UD 16.5EC CVTTS/ SUD <BR>
16. 0E0 ADDT/ D 16.1EC CVTTS/ UD 16.5EF CVTTQ/ SVD <BR>
16. 0E1 SUBT/ D 16.1EF CVTTQ/ VD 16.6AC CVTST/ S <BR>
16. 0E2 MULT/ D 16.2AC CVTST 16.700 ADDS/ SUIC <BR>
16. 0E3 DIVT/ D 16.500 ADDS/ SUC 16.701 SUBS/ SUIC <BR>
16. 0EC CVTTS/ D 16.501 SUBS/ SUC 16.702 MULS/ SUIC <BR>
16. 0EF CVTTQ/ D 16.502 MULS/ SUC 16.703 DIVS/ SUIC <BR>
16. 0FC CVTQS/ D 16.503 DIVS/ SUC 16.720 ADDT/ SUIC <BR>
16. 0FE CVTQT/ D 16.520 ADDT/ SUC 16.721 SUBT/ SUIC <BR>
16. 100 ADDS/ UC 16.521 SUBT/ SUC 16.722 MULT/ SUIC <BR>
16. 101 SUBS/ UC 16.522 MULT/ SUC 16.723 DIVT/ SUIC <BR>
16. 102 MULS/ UC 16.523 DIVT/ SUC 16.72C CVTTS/ SUIC <BR>
16. 103 DIVS/ UC 16.52C CVTTS/ SUC 16.72F CVTTQ/ SVIC <BR>
16. 120 ADDT/ UC 16.52F CVTTQ/ SVC 16.73C CVTQS/ SUIC <BR>
16. 121 SUBT/ UC 16.540 ADDS/ SUM 16.73E CVTQT/ SUIC <BR>
16. 122 MULT/ UC 16.541 SUBS/ SUM 16.740 ADDS/ SUIM <BR>
16. 123 DIVT/ UC 16.542 MULS/ SUM 16.741 SUBS/ SUIM <BR>
16. 12C CVTTS/ UC 16.543 DIVS/ SUM 16.742 MULS/ SUIM <BR>
16. 12F CVTTQ/ VC 16.560 ADDT/ SUM 16.743 DIVS/ SUIM <BR>
16. 140 ADDS/ UM 16.561 SUBT/ SUM 16.760 ADDT/ SUIM <BR>
16. 141 SUBS/ UM 16.562 MULT/ SUM 16.761 SUBT/ SUIM <BR>
16. 142 MULS/ UM 16.563 DIVT/ SUM 16.762 MULT/ SUIM <BR>
16. 143 DIVS/ UM 16.56C CVTTS/ SUM 16.763 DIVT/ SUIM <BR>
16. 160 ADDT/ UM 16.56F CVTTQ/ SVM 16.76C CVTTS/ SUIM <BR>
16. 161 SUBT/ UM 16.580 ADDS/ SU 16.76F CVTTQ/ SVIM <BR>
16. 162 MULT/ UM 16.581 SUBS/ SU 16.77C CVTQS/ SUIM <BR>
16. 163 DIVT/ UM 16.582 MULS/ SU 16.77E CVTQT/ SUIM <BR>
16. 16C CVTTS/ UM 16.583 DIVS/ SU 16.780 ADDS/ SUI <BR>
16. 16F CVTTQ/ VM 16.5A0 ADDT/ SU 16.781 SUBS/ SUI <BR>
16. 180 ADDS/ U 16.5A1 SUBT/ SU 16.782 MULS/ SUI <BR>
16. 181 SUBS/ U 16.5A2 MULT/ SU 16.783 DIVS/ SUI <BR>
<P>
<B>Table C– 8: Common Architecture Opcodes in Numerical Order (Continued) <BR>
Opcode Opcode Opcode </B>
314
<BR>
<A href=#page314>314</A>
<strong><A name=page315> Page 315</A></strong>
<A href=#page316>316</A>
<BR>
Instruction Summary <B>C– 13 <BR>
</B>16. 7A0 ADDT/ SUI 18.4000 MB 1F PAL1F <BR>
16. 7A1 SUBT/ SUI 18.4400 WMB 20 LDF <BR>
16. 7A2 MULT/ SUI 18.8000 FETCH 21 LDG <BR>
16. 7A3 DIVT/ SUI 18.A000 FETCH_ M 22 LDS <BR>
16. 7AC CVTTS/ SUI 18.C000 RPCC 23 LDT <BR>
16. 7AF CVTTQ/ SVI 18.E000 RC 24 STF <BR>
16. 7BC CVTQS/ SUI 18.E800 ECB 25 STG <BR>
16. 7BE CVTQT/ SUI 18.F000 RS 26 STS <BR>
16. 7C0 ADDS/ SUID 18.F800 WH64 27 STT <BR>
16. 7C1 SUBS/ SUID 19 PAL19 28 LDL <BR>
16. 7C2 MULS/ SUID 1A. 0 JMP 29 LDQ <BR>
16. 7C3 DIVS/ SUID 1A. 1 JSR 2A LDL_ L <BR>
16. 7E0 ADDT/ SUID 1A. 2 RET 2B LDQ_ L <BR>
16. 7E1 SUBT/ SUID 1A. 3 JSR_ COROUTINE 2C STL <BR>
16. 7E2 MULT/ SUID 1B PAL1B 2D STQ <BR>
16. 7E3 DIVT/ SUID 1C. 00 SEXTB 2E STL_ C <BR>
16. 7EC CVTTS/ SUID 1C. 01 SEXTW 2F STQ_ C <BR>
16. 7EF CVTTQ/ SVID 1C. 30 CTPOP 30 BR <BR>
16. 7FC CVTQS/ SUID 1C. 31 PERR 31 FBEQ <BR>
16. 7FE CVTQT/ SUID 1C. 32 CTLZ 32 FBLT <BR>
17. 010 CVTLQ 1C. 33 CTTZ 33 FBLE <BR>
17. 020 CPYS 1C. 34 UNPKBW 34 BSR <BR>
17. 021 CPYSN 1C. 35 UNPKBL 35 FBNE <BR>
17. 022 CPYSE 1C. 36 PKWB 36 FBGE <BR>
17. 024 MT_ FPCR 1C. 37 PKLB 37 FBGT <BR>
17. 025 MF_ FPCR 1C. 38 MINSB8 38 BLBC <BR>
17. 02A FCMOVEQ 1C. 39 MINSW4 39 BEQ <BR>
17. 02B FCMOVNE 1C. 3A MINUB8 3A BLT <BR>
17. 02C FCMOVLT 1C. 3B MINUW4 3B BLE <BR>
17. 02D FCMOVGE 1C. 3C MAXUB8 3C BLBS <BR>
17. 02E FCMOVLE 1C. 3D MAXUW4 3D BNE <BR>
17. 02F FCMOVGT 1C. 3E MAXSB8 3E BGE <BR>
17. 030 CVTQL 1C. 3F MAXSW4 3F BGT <BR>
17. 130 CVTQL/ V 1C. 70 FTOIT <BR>
17. 530 CVTQL/ SV 1C. 78 FTOIS <BR>
18. 0000 TRAPB 1D PAL1D <BR>
18. 0400 EXCB 1E PAL1E <BR>
<P>
<B>Table C– 8: Common Architecture Opcodes in Numerical Order (Continued) <BR>
Opcode Opcode Opcode </B>
315
<BR>
<A href=#page315>315</A>
<strong><A name=page316> Page 316</A></strong>
<A href=#page317>317</A>
<BR>
<B>C– 14 </B>Alpha Architecture Handbook <BR>
<B>C. 7 OpenVMS Alpha PALcode Instruction Summary <BR>
Table C– 9: OpenVMS Alpha Unprivileged PALcode Instructions <BR>
Mnemonic Opcode Description <BR>
</B>AMOVRM 00.00A1 Atomic move from register to memory AMOVRR 00.00A0 Atomic move from register to register <BR>
<P>
BPT 00.0080 Breakpoint BUGCHK 00.0081 Bugcheck <BR>
CHMK 00.0083 Change mode to kernel CHME 00.0082 Change mode to executive <BR>
CHMS 00.0084 Change mode to supervisor CHMU 00.0085 Change mode to user <BR>
CLRFEN 00.00AE Clear floating-point enable GENTRAP 00.00AA Generate software trap <BR>
IMB 00.0086 I-stream memory barrier INSQHIL 00.0087 Insert into longword queue at head interlocked <BR>
INSQHILR 00.00A2 Insert into longword queue at head interlocked resident INSQHIQ 00.0089 Insert into quadword queue at head interlocked <BR>
INSQHIQR 00.00A4 Insert into quadword queue at head interlocked resident INSQTIL 00.0088 Insert into longword queue at tail interlocked <BR>
INSQTILR 00.00A3 Insert into longword queue at tail interlocked resident INSQTIQ 00.008A Insert into quadword queue at tail interlocked <BR>
INSQTIQR 00.00A5 Insert into quadword queue at tail interlockedresident INSQUEL 00.008B Insert entry into longword queue <BR>
INSQUEL/ D 00.008D Insert entry into longword queue deferred INSQUEQ 00.008C Insert entry into quadword queue <BR>
INSQUEQ/ D 00.008E Insert entry into quadword queue deferred PROBER 00.008F Probe for read access <BR>
PROBEW 00.0090 Probe for write access RD_ PS 00.0091 Move processor status <BR>
READ_ UNQ 00.009E Read unique context REI 00.0092 Return from exception or interrupt <BR>
REMQHIL 00.0093 Remove from longword queue at head interlocked REMQHILR 00.00A6 Remove from longword queue at head interlocked resident <BR>
REMQHIQ 00.0095 Remove from quadword queue at head interlocked REMQHIQR 00.00A8 Remove from quadword queue at head interlocked resident <BR>
REMQTIL 00.0094 Remove from longword queue at tail interlocked REMQTILR 00.00A7 Remove from longword queue at tail interlocked resident <BR>
REMQTIQ 00.0096 Remove from quadword queue at tail interlocked REMQTIQR 00.00A9 Remove from quadword queue at tail interlocked resident <BR>
REMQUEL 00.0097 Remove entry from longword queue REMQUEL/ D 00.0099 Remove entry from longword queue deferred <BR>
REMQUEQ 00.0098 Remove entry from quadword queue REMQUEQ/ D 00.009A Remove entry from quadword queue deferred <BR>
RSCC 00.009D Read system cycle counter SWASTEN 00.009B Swap AST enable for current mode <BR>
WRITE_ UNQ 00.009F Write unique context WR_ PS_ SW 00.009C Write processor status software field 
316
<BR>
<A href=#page316>316</A>
<strong><A name=page317> Page 317</A></strong>
<A href=#page318>318</A>
<BR>
Instruction Summary <B>C– 15 <BR>
Table C– 10: OpenVMS Alpha Privileged PALcode Instructions <BR>
Mnemonic Opcode Description <BR>
</B>CFLUSH 00.0001 Cache flush CSERVE 00.0009 Console service <BR>
<P>
DRAINA 00.0002 Drain aborts HALT 00.0000 Halt processor <BR>
LDQP 00.0003 Load quadword physical MFPR_ ASN 00.0006 Move from processor register ASN <BR>
MFPR_ ESP 00.001E Move from processor register ESP MFPR_ FEN 00.000B Move from processor register FEN <BR>
MFPR_ IPL 00.000E Move from processor register IPL MFPR_ MCES 00.0010 Move from processor register MCES <BR>
MFPR_ PCBB 00.0012 Move from processor register PCBB MFPR_ PRBR 00.0013 Move from processor register PRBR <BR>
MFPR_ PTBR 00.0015 Move from processor register PTBR MFPR_ SCBB 00.0016 Move from processor register SCBB <BR>
MFPR_ SISR 00.0019 Move from processor register SISR MFPR_ SSP 00.0020 Move from processor register SSP <BR>
MFPR_ TBCHK 00.001A Move from processor register TBCHK MFPR_ USP 00.0022 Move from processor register USP <BR>
MFPR_ VPTB 00.0029 Move from processor register VPTB MFPR_ WHAMI 00.003F Move from processor register WHAMI <BR>
MTPR_ ASTEN 00.0026 Move to processor register ASTEN MTPR_ ASTSR 00.0027 Move to processor register ASTSR <BR>
MTPR_ DATFX 00.002E Move to processor register DATFX MTPR_ ESP 00.001F Move to processor register ESP <BR>
MTPR_ FEN 00.000B Move to processor register FEN MTPR_ IPIR 00.000D Move to processor register IPRI <BR>
MTPR_ IPL 00.000E Move to processor register IPL MTPR_ MCES 00.0011 Move to processor register MCES <BR>
MTPR_ PERFMON 00.002B Move to processor register PERFMON MTPR_ PRBR 00.0014 Move to processor register PRBR <BR>
MTPR_ SCBB 00.0017 Move to processor register SCBB MTPR_ SIRR 00.0018 Move to processor register SIRR <BR>
MTPR_ SSP 00.0021 Move to processor register SSP MTPR_ TBIA 00.001B Move to processor register TBIA <BR>
MTPR_ TBIAP 00.001C Move to processor register TBIAP MTPR_ TBIS 00.001D Move to processor register TBIS <BR>
MTPR_ TBISD 00.0024 Move to processor register TBISD MTPR_ TBISI 00.0025 Move to processor register TBISI <BR>
MTPR_ USP 00.0023 Move to processor register USP MTPR_ VPTB 00.002A Move to processor register VPTB <BR>
STQP 00.0004 Store quadword physical SWPCTX 00.0005 Swap privileged context <BR>
SWPPAL 00.000A Swap PALcode image WTINT 00.003E Wait for interrupt 
317
<BR>
<A href=#page317>317</A>
<strong><A name=page318> Page 318</A></strong>
<A href=#page319>319</A>
<BR>
<B>C– 16 </B>Alpha Architecture Handbook <BR>
<B>C. 8 DIGITAL UNIX PALcode Instruction Summary <BR>
Table C– 11: DIGITAL UNIX Unprivileged PALcode Instructions <BR>
Mnemonic Opcode Description <BR>
</B>bpt 00.0080 Breakpoint trap bugchk 00.0081 Bugcheck <BR>
<P>
callsys 00.0083 System call clrfen 00.00AE Clear floating-point enable <BR>
gentrap 00.00AA Generate software trap imb 00.0086 I-stream memory barrier <BR>
rdunique 00.009E Read unique value urti 00.0092 Return from user mode trap <BR>
wrunique 00.009F Write unique value <BR>
<P>
<B>Table C– 12: DIGITAL UNIX Privileged PALcode Instructions <BR>
Mnemonic Opcode Description <BR>
</B>cflush 00.0001 Cache flush cserve 00.0009 Console service <BR>
<P>
draina 00.0002 Drain aborts halt 00.0000 Halt the processor <BR>
rdmces 00.0010 Read machine check error summary register rdps 00.0036 Read processor status <BR>
rdusp 00.003A Read user stack pointer rdval 00.0032 Read system value <BR>
retsys 00.003D Return from system call rti 00.003F Return from trap or interrupt <BR>
swpctx 00.0030 Swap privileged context swpipl 00.0035 Swap interrupt priority level <BR>
swppal 00.000A Swap PALcode image tbi 00.0033 Translation buffer invalidate <BR>
whami 00.003C Who am I wrent 00.0034 Write system entry address <BR>
wrfen 00.002B Write floating-point enable wripir 00.000D Write interprocessor interrupt request <BR>
wrkgp 00.0037 Write kernel global pointer wrmces 00.0011 Write machine check error summary register <BR>
wrperfmon 00.0039 Performance monitoring function wrusp 00.0038 Write user stack pointer <BR>
wrval 00.0031 Write system value wrvptptr 00.002D Write virtual page table pointer <BR>
wtint 00.003E Wait for interrupt 
318
<BR>
<A href=#page318>318</A>
<strong><A name=page319> Page 319</A></strong>
<A href=#page320>320</A>
<BR>
Instruction Summary <B>C– 17 <BR>
C. 9 Windows NT Alpha Instruction Summary <BR>
Table C– 13: Windows NT Alpha Unprivileged PALcode Instructions <BR>
Mnemonic Opcode Description <BR>
</B>bpt 00.0080 Breakpoint trap callkd 00.00AD Call kernel debugger <BR>
<P>
callsys 00.0083 Call system service gentrap 00.00AA Generate trap <BR>
imb 00.0086 Instruction memory barrier kbpt 00.00AC Kernel breakpoint trap <BR>
rdteb 00.00AB Read TEB internal processor register <BR>
<P>
<B>Table C– 14: Windows NT Alpha Privileged PALcode instructions <BR>
Mnemonic Opcode Description <BR>
</B>csir 00.000D Clear software interrupt request dalnfix 00.0025 Disable alignment fixups <BR>
<P>
di 00.0008 Disable interrupts draina 00.0002 Drain aborts <BR>
dtbis 00.0016 Data translation buffer invalidate single ealnfix 00.0024 Enable alignment fixups <BR>
ei 00.0009 Enable interrupts halt 00.0000 Trap to illegal instruction <BR>
initpal 00.0004 Initialize the PALcode initpcr 00.0038 Initialize processor control region data <BR>
rdcounters 00.0030 Read PALcode event counters rdirql 00.0007 Read current IRQL <BR>
rdksp 00.0018 Read initial kernel stack rdmces 00.0012 Read machine check error summary <BR>
rdpcr 00.001C Read PCR (processor control registers) rdpsr 00.001A Read processor status register <BR>
rdstate 00.0031 Read internal processor state rdthread 00. 001E Read the current thread value <BR>
reboot 00.0002 Transfer to console firmware restart 00.0001 Restart the processor <BR>
retsys 00.000F Return from system service call rfe 00.000E Return from exception <BR>
swpirql 00.0006 Swap IRQL swpksp 00.0019 Swap initial kernel stack <BR>
swppal 00.000A Swap PALcode swpprocess 00.0011 Swap privileged process context <BR>
swpctx 00.0010 Swap privileged thread context ssir 00.000C Set software interrupt request <BR>
tbia 00.0014 Translation buffer invalidate all tbim 00.0020 Translation buffer invalidate multiple <BR>
tbimasn 00.0021 Translation buffer invalidate multiple ASN tbis 00.0015 Translation buffer invalidate single <BR>
tbisasn 00.0017 Translation buffer invalidate single ASN wrentry 00.0005 Write system entry <BR>
wrmces 00.0013 Write machine check error summary wrperfmon 00.0032 Write performance monitoring values 
319
<BR>
<A href=#page319>319</A>
<strong><A name=page320> Page 320</A></strong>
<A href=#page321>321</A>
<BR>
<B>C– 18 </B>Alpha Architecture Handbook <BR>
<B>C. 10 PALcode Opcodes in Numerical Order <BR>
</B>Opcodes 00.003816 through 00. 003F16 are reserved for processor implementation-specific <BR>
PALcode instructions. All other opcodes are reserved for use by Compaq. <BR>
<P>
<B>Table C– 15: PALcode Opcodes in Numerical Order <BR>
</B><P>
<B>Opcode 16 Opcode 10 OpenVMS Alpha DIGITAL UNIX Windows NT Alpha <BR>
</B>00.0000 00.0000 HALT halt halt 00.0001 00.0001 CFLUSH cflush restart <BR>
<P>
00.0002 00.0002 DRAINA draina draina 00.0003 00.0003 LDQP — reboot <BR>
00.0004 00.0004 STQP — initpal 00.0005 00.0005 SWPCTX — wrentry <BR>
00.0006 00.0006 MFPR_ ASN — swpirql 00.0007 00.0007 MTPR_ ASTEN — rdirql <BR>
00.0008 00.0008 MTPR_ ASTSR — di 00.0009 00.0009 CSERVE cserve ei <BR>
00.000A 00.0010 SWPPAL swppal swppal 00.000B 00.0011 MFPR_ FEN — — <BR>
00.000C 00.0012 MTPR_ FEN — ssir 00.000D 00.0013 MTPR_ IPIR wripir csir <BR>
00.000E 00.0014 MFPR_ IPL — rfe 00.000F 00.0015 MTPR_ IPL — retsys <BR>
00.0010 00.0016 MFPR_ MCES rdmces swpctx 00.0011 00.0017 MTPR_ MCES wrmces swpprocess <BR>
00.0012 00.0018 MFPR_ PCBB — rdmes 00.0013 00.0019 MFPR_ PRBR — wrmces <BR>
00.0014 00.0020 MTPR_ PRBR — tbia 00.0015 00.0021 MFPR_ PTBR — tbis <BR>
00.0016 00.0022 MFPR_ SCBB — dtbis 00.0017 00.0023 MTPR_ SCBB — tbisasn <BR>
00.0018 00.0024 MTPR_ SIRR — rdksp 00.0019 00.0025 MFPR_ SISR — swpksp <BR>
00.001A 00.0026 MFPR_ TBCHK — rdpsr 00.001B 00.0027 MTPR_ TBIA — — <BR>
00.001C 00.0028 MTPR_ TBIAP — rdpcr 00.001D 00.0029 MTPR_ TBIS — — <BR>
00.001E 00.0030 MFPR_ ESP — rdthread 00.001F 00.0031 MTPR_ ESP — — <BR>
00.0020 00.0032 MFPR_ SSP — tbim 00.0021 00.0033 MTPR_ SSP — tbimasn <BR>
00.0022 00.0034 MFPR_ USP — — 00.0023 00.0035 MTPR_ USP — — <BR>
00.0024 00.0036 MTPR_ TBISD — ealnfix 00.0025 00.0037 MTPR_ TBISI — dalnfix <BR>
00.0026 00.0038 MFPR_ ASTEN — — 00.0027 00.0039 MFPR_ ASTSR — — <BR>
00.0029 00.0041 MFPR_ VPTB — — 00.002A 00.0042 MTPR_ VPTB — — <BR>
00.002B 00.0043 MTPR_ PERFMON wrfen — 00.002D 00.0045 — wrvptptr — <BR>
00.002E 00.0046 MTPR_ DATFX — — 00.0030 00.0048 — swpctx rdcounters <BR>
00.0031 00.0049 — wrval rdstate 
320
<BR>
<A href=#page320>320</A>
<strong><A name=page321> Page 321</A></strong>
<A href=#page322>322</A>
<BR>
Instruction Summary <B>C– 19 <BR>
</B>00.0032 00.0050 — rdval wrperfmon 00.0033 00.0051 — tbi — <BR>
00.0034 00.0052 — wrent — 00.0035 00.0053 — swpipl — <BR>
00.0036 00.0054 — rdps — 00.0037 00.0055 — wrkgp initpcr <BR>
00.0038 00.0056 — wrusp — 00.0039 00.0057 — wrperfmon — <BR>
00.003A 00.0058 — rdusp — 00.003C 00.0060 — whami — <BR>
00.003D 00.0061 — retsys — 00.003E 00.0062 WTINT wtint — <BR>
00.003F 00.0063 MFPR_ WHAMI rti — 00.0080 00.0128 BPT bpt bpt <BR>
00.0081 00.0129 BUGCHK bugchk — 00.0082 00.0130 CHME — — <BR>
00.0083 00.0131 CHMK callsys callsys 00.0084 00.0132 CHMS — — <BR>
00.0085 00.0133 CHMU — — 00.0086 00.0134 IMB imb imb <BR>
00.0087 00.0135 INSQHIL — — 00.0088 00.0136 INSQTIL — — <BR>
00.0089 00.0137 INSQHIQ — — 00.008A 00.0138 INSQTIQ — — <BR>
00.008B 00.0139 INSQUEL — — 00.008C 00.0140 INSQUEQ — — <BR>
00.008D 00.0141 INSQUEL/ D — — 00.008E 00.0142 INSQUEQ/ D — — <BR>
00.008F 00.0143 PROBER — — 00.0090 00.0144 PROBEW — — <BR>
00.0091 00.0145 RD_ PS — — 00.0092 00.0146 REI urti — <BR>
00.0093 00.0147 REMQHIL — — 00.0094 00.0148 REMQTIL — — <BR>
00.0095 00.0149 REMQHIQ — — 00.0096 00.0150 REMQTIQ — — <BR>
00.0097 00.0151 REMQUEL — — 00.0098 00.0152 REMQUEQ — — <BR>
00.0099 00.0153 REMQUEL/ D — 00.009A 00.0154 REMQUEQ/ D — — <BR>
00.009B 00.0155 SWASTEN — — 00.009C 00.0156 WR_ PS_ SW — — <BR>
00.009D 00.0157 RSCC — — 00.009E 00.0158 READ_ UNQ rdunique — <BR>
00.009F 00.0159 WRITE_ UNQ wrunique — 00.00A0 00.0160 AMOVRR — — <BR>
00.00A1 00.0161 AMOVRM — — 00.00A2 00.0162 INSQHILR — — <BR>
00.00A3 00.0163 INSQTILR — — 00.00A4 00.0164 INSQHIQR — — <BR>
00.00A5 00.0165 INSQTIQR — — <BR>
00.00A6 00.0166 REMQHILR — — 00.00A7 00.0167 REMQTILR — — <BR>
<P>
<B>Table C– 15: PALcode Opcodes in Numerical Order (Continued) <BR>
Opcode 16 Opcode 10 OpenVMS Alpha DIGITAL UNIX Windows NT Alpha </B>
321
<BR>
<A href=#page321>321</A>
<strong><A name=page322> Page 322</A></strong>
<A href=#page323>323</A>
<BR>
<P>
<B>C– 20 </B>Alpha Architecture Handbook <BR>
<B>C. 11 Required PALcode Opcodes <BR>
</B>The opcodes listed in <A href="#page322">Table C– 16 </A>
are required for all Alpha implementations. The notation <BR>
used is oo. ffff, where <I>oo is the hexadecimal </A>
6-bit opcode and <I>ffff </I>is the hexadecimal 26-bit <BR>
function code. <BR>
<P>
<B>C. 12 Opcodes Reserved to PALcode <BR>
</B>The opcodes listed <A href="#page322">in Table C– 17 </A>
are reserved for use in implementing PALcode. <BR>
<P>
00.00A8 00.0168 REMQHIQR — — 00.00A9 00.0169 REMQTIQR — — <BR>
00.00AA 00.0170 GENTRAP gentrap gentrap 00.00AB 00.0171 — — rdteb <BR>
00.00AC 00.0172 — — kbpt 00.00AD 00.0173 — — callkd <BR>
00.00AE 00.0174 CLRFEN clrfen <BR>
<P>
<B>Table C– 16: Required PALcode Opcodes <BR>
Mnemonic Type Opcode <BR>
</B>DRAINA Privileged 00.0002 <BR>
HALT Privileged 00.0000 <BR>
IMB Unprivileged 00.0086 <BR>
<P>
<B>Table C– 17: Opcodes Reserved for PALcode <BR>
Mnemonic Mnemonic Mnemonic <BR>
</B>PAL19 19 PAL1B 1B PAL1D 1D <BR>
PAL1E 1E PAL1F 1F <BR>
<P>
<B>Table C– 15: PALcode Opcodes in Numerical Order (Continued) <BR>
Opcode 16 Opcode 10 OpenVMS Alpha DIGITAL UNIX Windows NT Alpha </B>
322
<BR>
<A href=#page322>322</A>
<strong><A name=page323> Page 323</A></strong>
<A href=#page324>324</A>
<BR>
<P>
Instruction Summary <B>C– 21 <BR>
C. 13 Opcodes Reserved to Compaq <BR>
</B>The opcodes listed <A href="#page323">in Table C– 18 </A>
are reserved to Compaq. <BR>
<P>
<B>Programming Note: <BR>
</B>The code points 18.4800 and 18. 4C00 are reserved for adding weaker memory barrier <BR>
instructions. Those code points must operate as a Memory Barrier instruction (MB <BR>
18.4000) for implementations that precede their definition as weaker memory barrier <BR>
instructions. Software must use the 18.4000 code point for MB. <BR>
<P>
<B>C. 14 Unused Function Code Behavior <BR>
</B>Unused function codes for all opcodes assigned (not reserved) in the Version 5 Alpha architec-ture <BR>
specification (May 1992) produce UNPREDICTABLE but not UNDEFINED results; they <BR>
are not security holes. <BR>
<P>
Unused function codes for opcodes defined as reserved in the Version 5 Alpha architecture <BR>
specification produce an illegal instruction trap. Those opcodes are 01, 02, 03, 04, 05, 06, 07, <BR>
0A, 0C, 0D, 0E, 14, 19, 1B, 1C, 1D, 1E, and 1F. Unused function codes for those opcodes <BR>
reserved to PALcode produce an illegal instruction trap only if not used in the PALcode <BR>
environment. <BR>
<P>
<B>Table C– 18: Opcodes Reserved for Compaq <BR>
Mnemonic Mnemonic Mnemonic <BR>
</B>OPC01 01 OPC02 02 OPC03 03 <BR>
OPC04 04 OPC05 05 OPC06 06 <BR>
OPC07 07 
323
<BR>
<A href=#page323>323</A>
<strong><A name=page324> Page 324</A></strong>
<A href=#page325>325</A>
<BR>
<P>
<B>C– 22 </B>Alpha Architecture Handbook <BR>
<B>C. 15 ASCII Character Set <BR>
<A href="#page324">Table C– 19 </A>
shows the 7-bit ASCII character set and the corresponding hexadecimal value for <BR>
each character. <BR>
<P>
<B>Table C– 19: ASCII Character Set <BR>
</B><P>
<B>Char <BR>
Hex <BR>
Code Char <BR>
Hex <BR>
Code Char <BR>
Hex <BR>
Code Char <BR>
Hex <BR>
Code <BR>
</B><P>
NUL 0 SP 20 @ 40 '60 <BR>
SQH 1 ! 21 A 41 a 61 <BR>
STX 2 " 22 B 42 b 62 <BR>
ETX 3 # 23 C 43 c 63 <BR>
EOT 4 $ 24 D 44 d 64 <BR>
ENQ 5 % 25 E 45 e 65 <BR>
ACK 6 &amp; 26 F 46 f 66 <BR>
BEL 7 ' 27 G 47 g 67 <BR>
BS 8 ( 28 H 48 h 68 <BR>
HT 9 ) 29 I 49 i 69 <BR>
LF A * 2A J 4A j 6A <BR>
VT B + 2B K 4B k 6B <BR>
FF C , 2C L 4C l 6C <BR>
CR D -2D M 4D m 6D <BR>
SO E . 2E N 4E n 6E <BR>
SI F / 2F O 4F o 6F <BR>
DLE 10 0 30 P 50 p 70 <BR>
DC1 11 1 31 Q 51 q 71 <BR>
DC2 12 2 32 R 52 r 72 <BR>
DC3 13 3 33 S 53 s 73 <BR>
DC4 14 4 34 T 54 t 74 <BR>
NAK 15 5 35 U 55 u 75 <BR>
SYN16 636V56 v76 <BR>
ETB 17 7 37 W 57 w 77 <BR>
CAN18 838X58 x78 <BR>
EM 19 9 39 Y 59 y 79 <BR>
SUB1A :3AZ5A z7A <BR>
ESC 1B ; 3B [ 5B { 7B <BR>
FS 1C &lt; 3C \ 5C | 7C <BR>
GS 1D = 3D ] 5D } 7D <BR>
RS 1E &gt; 3E ^ 5E ~ 7E <BR>
US 1F ? 3F _ 5F DEL 7F 
324
<BR>
<A href=#page324>324</A>
<strong><A name=page325> Page 325</A></strong>
<A href=#page326>326</A>
<BR>
<B>D– 1 <BR>
Appendix D <BR>
Registered System and Processor Identifiers <BR>
</B>This appendix contains a table of the processor type assignments, PALcode implementation <BR>
information, and the architecture mask (AMASK) and implementation value (IMPLVER) <BR>
assignments. <BR>
<P>
<B>D. 1 Processor Type Assignments <BR>
</B>The following processor types are defined. <BR>
<P>
<B>Table D– 1: Processor Type Assignments <BR>
Major Type Minor Type <BR>
</B>1 = EV3 <BR>
2 = EV4 (21064) 0 = Pass 2 or 2.1 <BR>
1 = Pass 3 (also EV4s) <BR>
3 = Simulation <BR>
4 = LCA Family: <BR>
LCA4s (21066) <BR>
LCA4s embedded (21068) <BR>
LCA45 (21066A, 21068A) <BR>
<P>
0 = Reserved <BR>
1 = Pass 1 or 1.1 (21066) <BR>
2 = Pass 2 (21066) <BR>
3 = Pass 1 or 1.1 (21068) <BR>
4 = Pass 2 (21068) <BR>
5 = Pass 1 (21066A) <BR>
6 = Pass 1 (21068A) 
325
<BR>
<A href=#page325>325</A>
<strong><A name=page326> Page 326</A></strong>
<A href=#page327>327</A>
<BR>
<B>D– 2 </B>Alpha Architecture Handbook <BR>
For OpenVMS Alpha and DIGITAL UNIX, the processor types are stored in the Per-CPU Slot <BR>
Table (SLOT[ 176]), pointed to by HWRPB[ 160]. <BR>
<P>
<B>D. 2 PALcode Variation Assignments <BR>
</B>The PALcode variation assignments are as follows: <BR>
<P>
5 = EV5 (21164) 0 = Reserved (Pass 1) <BR>
1 = Pass 2, 2.2 (rev BA, CA) <BR>
2 = Pass 2. 3 (rev DA, EA) <BR>
3 = Pass 3 <BR>
4 = Pass 3.2 <BR>
5 = Pass 4 <BR>
6 = EV45 (21064A) 0 = Reserved <BR>
1 = Pass 1 <BR>
2 = Pass 1.1 <BR>
3 = Pass 2 <BR>
7 = EV56 (21164A) 0 = Reserved <BR>
1 = Pass 1 <BR>
2 = Pass 2 <BR>
8 = EV6 (21264) 0 = Reserved <BR>
1 = Pass 1 <BR>
2 = Pass 2, 2.1 <BR>
3 = Pass 2.2 <BR>
4 = Pass 2. 3 <BR>
5 = Pass 3 <BR>
9 = PCA56 (21164PC) 0 = Reserved <BR>
1 = Pass 1 <BR>
<P>
<B>Table D– 2: PALcode Variation Assignments <BR>
Token PALcode Type Summary Table <BR>
</B>0 Console N/ A <BR>
1 OpenVMS Alpha Console Interface (III), Chapter 3, in the <BR>
<I>Alpha Architecture Reference Manual. <BR>
</I><P>
<B>Table D– 1: Processor Type Assignments (Continued) <BR>
Major Type Minor Type </B>
326
<BR>
<A href=#page326>326</A>
<strong><A name=page327> Page 327</A></strong>
<A href=#page328>328</A>
<BR>
Registered System and Processor Identifiers <B>D– 3 <BR>
D. 3 Architecture Mask and Implementation Values <BR>
</B>The following bits are defined for the AMASK instruction. <BR>
<P>
The following values are defined for the IMPLVER instruction. <BR>
<P>
2 DIGITAL UNIX Console Interface (III), Chapter 3 in the <BR>
<I>Alpha Architecture Reference Manual <BR>
</I><P>
3– 127 Reserved to Compaq <BR>
128– 255 Reserved to non-Compaq <BR>
<P>
<B>Table D– 3: AMASK Bit Assignments <BR>
Bit Meaning <BR>
</B>0 Support for the byte/ word extension (BWX) <BR>
The instructions that comprise the BWX extension are LDBU, LDWU, SEXTB, <BR>
SEXTW, STB, and STW. <BR>
<P>
1 Support for the square-root and floating-point convert extension (FIX) <BR>
The instructions that comprise the FIX extension are FTOIS, FTOIT, ITOFF, <BR>
ITOFS, ITOFT, SQRTF, SQRTG, SQRTS, and SQRTT. <BR>
<P>
2 Support for the count extension (CIX) <BR>
The instructions that comprise the CIX extension are CTLZ, CTPOP, and CTTZ. <BR>
<P>
8 Support for the multimedia extension (MVI) <BR>
The instructions that comprise the MVI extension are MAXSB8, MAXSW4, <BR>
MAXUB8, MAXUW4, MINSB8, MINSW4, MINUB8, MINUW4, PERR, PKLB, <BR>
PKWB, UNPKBL, and UNPKBW. <BR>
<P>
9 Support for precise arithmetic trap reporting in hardware. The trap PC is the same <BR>
as the instruction PC after the trapping instruction is executed. <BR>
<P>
<B>Table D– 4: IMPLVER Value Assignments <BR>
Val ue Me ani ng <BR>
</B>0 21064 (EV4) <BR>
21064A (EV45) <BR>
21066A/ 21068A (LCA45) <BR>
<P>
1 21164 (EV5) <BR>
21164A (EV56) <BR>
21164PC (PCA56) <BR>
<P>
2 21264 (EV6) <BR>
<P>
<B>Table D– 2: PALcode Variation Assignments <BR>
Token PALcode Type Summary Table </B>
327
<BR>
<A href=#page327>327</A>
<strong><A name=page328> Page 328</A></strong>
<A href=#page329>329</A>
<BR>

328
<BR>
<A href=#page328>328</A>
<strong><A name=page329> Page 329</A></strong>
<A href=#page330>330</A>
<BR>
<B>E– 1 <BR>
Appendix E <BR>
Waivers and Implementation-Dependent <BR>
Functionality <BR>
</B><P>
This appendix describes waivers to the Alpha architecture and functionality that is specific to <BR>
particular hardware implementations. <BR>
<P>
<B>E. 1 Waivers <BR>
</B>The following waivers have been passed for the Alpha architecture. <BR>
<P>
<B>E. 1.1 DECchip 21064, DECchip 21066, and DECchip 21068 IEEE Divide <BR>
Instruction Violation <BR>
</B><P>
The DECchip 21064, DECchip 21066, and DECchip 21068 CPUs violate the architected han-dling <BR>
of IEEE divide instructions DIVS and DIVT with respect to reporting Inexact Result <BR>
exceptions. <BR>
<P>
<B>Note: <BR>
</B>The DECchip 21064A, DECchip 21066A, and DECchip 21068A CPUs are compliant and <BR>
require no waiver. The DECchip 21164 is also compliant. <BR>
<P>
As specified by the architecture, floating-point exceptions generated by the CPU are recorded <BR>
in two places for all IEEE floating-point instructions: <BR>
<P>
1. If an exception is detected and the corresponding trap is enabled (such as ADD/ U for <BR>
underflow), the CPU initiates a trap and records the exception in the exception sum-mary <BR>
register (EXC_ SUM). <BR>
<P>
2. The exceptions are also recorded as flags that can be tested in the floating-point control register (FPCR). The FPCR can only be accessed with MTPR/ MFPR instructions and <BR>
<P>
an explicit MT_ FPCR is required to clear the FPCR. The FPCR is updated irrespective of whether the trap is enabled or not. 
329
<BR>
<A href=#page329>329</A>
<strong><A name=page330> Page 330</A></strong>
<A href=#page331>331</A>
<BR>
<P>
<B>E– 2 </B>Alpha Architecture Handbook <BR>
The DECchip 21064, DECchip 21066, and DECchip 21068 implementations differ from the <BR>
above specification in handling the Inexact condition for the IEEE DIVS and DIVT instruc-tions <BR>
in two ways: <BR>
<P>
1. The DIVS and DIVT instructions with the /Inexact modifier trap unconditionally and <BR>
report the INE exception in the EXC_ SUM register (except for NaN, infinity, and <BR>
denormal inputs that result in INVs). This allows for a software calculation to deter-mine <BR>
the correct INE status. <BR>
<P>
2. The FPCR &lt;INE&gt; bit is <I>never </I>set by DIVS or DIVT. This is because the DECchip 21064, DECchip 21066, and DECchip 21068 do not include hardware to determine that <BR>
<P>
particular exactness. <BR>
<P>
<B>E. 1.2 DECchip 21064, DECchip 21066, and DECchip 21068 Write Buffer <BR>
Violation <BR>
</B><P>
The DECchip 21064, DECchip 21066, and DECchip 21068 CPUs can be made to violate the <BR>
architecture by, under one contrived case, indefinitely delaying a buffered off-chip write. <BR>
<P>
<B>Note: <BR>
</B>The DECchip 21064A, DECchip 21066A, and DECchip 21068A CPUs are compliant and <BR>
require no waiver. The DECchip 21164 is also compliant. <BR>
<P>
The CPUs in violation can send a buffered write off-chip when one of the following condi-tions <BR>
is met: <BR>
<P>
1. The write buffer contains at least two valid entries. <BR>
2. The write buffer contains one valid entry and 256 cycles have elapsed since the execu-tion of the last write. <BR>
<P>
3. The write buffer contains an MB or STx_ C instruction. <BR>
4. A load miss hits an entry in the write buffer. <BR>
The write can be delayed indefinitely under condition 2 above, when there is an indefinite <BR>
stream of writes to addresses within the same aligned 32-byte write buffer block. <BR>
<P>
<B>E. 1.3 DECchip 21264 LDx_ L/ STx_ C with WH64 Violation <BR>
</B>The DECchip 21264 violates the architected relationship between the LDx_ L and STx_ C <BR>
instructions when an intervening WH64 instruction is executed. <BR>
<P>
As specified in <A href="#page65">Section 4.2.4: <BR>
</A>
If any other memory access (ECB, LDx, LDQ_ U, STx, STQ_ U, WH64) is executed on the <BR>
given processor between the LDx_ L and the STx_ C, the sequence above may always fail <BR>
on some implementations; hence, no useful program should do this. 
330
<BR>
<A href=#page330>330</A>
<strong><A name=page331> Page 331</A></strong>
<A href=#page332>332</A>
<BR>
Waivers and Implementation-Dependent Functionality <B>E– 3 <BR>
</B>The DECchip 21264 varies from that description, with regard to the WH64 instruction, as <BR>
follows: <BR>
<P>
If any other memory access (ECB, LDx, LDQ_ U, STx, STQ_ U) is executed on the given <BR>
processor between the LDx_ L and the STx_ C, the sequence above may always fail on <BR>
some implementations; hence, no useful program should do this. <BR>
<P>
If a WH64 memory access is executed on any given 21264 processor between the LDx_ L <BR>
and STx_ C, and: <BR>
<P>
– The WH64 access is to the same aligned 64-byte block that STx_ C is accessing, <BR>
and <BR>
<P>
– No CALL_ PAL REI, rei, or rfe instruction has been executed since the most-recent <BR>
LDx_ L (ensuring that the sequence cannot occur as the result of unfortunate coin-cidences <BR>
with interrupts) <BR>
<P>
then, the load-locked/ store-conditional sequence may sometimes fail when it would <BR>
otherwise succeed and sometimes succeed when it otherwise would fail; hence no useful <BR>
program should do this. <BR>
<P>
<B>E. 2 Implementation-Specific Functionality <BR>
</B>The following functionality, although a documentated part of the Alpha architecture, is imple-mented <BR>
in a manner that is specific to the particular hardware implementation. <BR>
<P>
<B>E. 2.1 DECchip 21064/ 21066/ 21068 Performance Monitoring <BR>
</B><P>
<B>Note: <BR>
</B>All functions, arguments, and descriptions in this section apply to the DECchip <BR>
21064/ 21064A, 21066/ 21066A, and 21068/ 21068A. <BR>
<P>
PALcode instructions control the DECchip 21064/ 21066/ 21068 on-chip performance counters. <BR>
For OpenVMS Alpha, the instruction is MTPR_ PERFMON; for DIGITAL UNIX and Win-dows <BR>
NT Alpha, the instruction is wrperfmon. <BR>
<P>
The instruction arguments and results are described in the following sections. The scratch reg-ister <BR>
usage is operating system specific. <BR>
<P>
Two on-chip counters count events. The bit width of the counters (8, 12, or 16 bits) can be <BR>
selected and the event that they count can be switched among a number of available events. <BR>
One possible event is an "external" event. For example, the processor board can supply an <BR>
event that causes the counter to increment. In this manner, off-chip events can be counted. <BR>
<P>
The two counters can be switched independently. There is no hardware support for reading, <BR>
writing, or resetting the counters. The only way to monitor the counters is to enable them to <BR>
cause an interrupt on overflow. 
331
<BR>
<A href=#page331>331</A>
<strong><A name=page332> Page 332</A></strong>
<A href=#page333>333</A>
<BR>
<P>
<B>E– 4 </B>Alpha Architecture Handbook <BR>
The performance monitor functions, described in <A href="#page333">Section E. 2. 1. 2, </A>
can provide the following, <BR>
depending on implementation: <BR>
<P>
<B>° </B>Enable the performance counters to interrupt and trap into the performance monitoring vector in the operating system. <BR>
<P>
<B>° </B>Disable the performance counter from interrupting. This does not necessarily mean that the counters will stop counting. <BR>
<B>° </B>Select which events will be monitored and set the width of the two counters. <BR>
<B>° </B>In the case of OpenVMS Alpha and DIGITAL UNIX, implementations can choose to monitor selected processes. If that option is selected, the PME bit in the PCB controls <BR>
<P>
the enabling of the counters. Since the counters cannot be read/ written/ reset, if more <BR>
than one process is being monitored, the rounding error may become significant. <BR>
<P>
<B>E. 2.1.1 DECchip 21064/ 21066/ 21068 Performance Monitor Interrupt Mechanism <BR>
</B>The performance monitoring interrupt mechanism varies according to the particular operating <BR>
system. <BR>
<P>
<B>For the OpenVMS Alpha Operating System <BR>
</B>When a counter overflows and interrupt enabling conditions are correct, the counter causes an <BR>
interrupt to PALcode. The PALcode builds an appropriate stack frame. The PALcode then dis-patches <BR>
in the form of an exception (not in the form of an interrupt) to the operating system by <BR>
ve c toring to the SCB per f ormance monitor e ntry point through SCBB+ 650 <BR>
(HWSCB$ Q_ PERF_ MONITOR), at IPL 29, in kernel mode. <BR>
<P>
Two interrupts are generated if both counters overflow. For each interrupt, the status of each <BR>
counter overflow is indicated by register R4: <BR>
<P>
R4 = 0 if performance counter 0 caused the interrupt R4 = 1 if performance counter 1 caused the interrupt <BR>
<P>
When the interrupt is taken, the PC is saved on the stack frame as the old PC. <BR>
<B>For the DIGITAL UNIX Operating System <BR>
</B>When a counter overflows and interrupt enabling conditions are correct, the counter causes an <BR>
interrupt to PALcode. The PALcode builds an appropriate stack frame and dispatches to the <BR>
operating system by vectoring to the interrupt entry point entINT, at IPL 6, in kernel mode. <BR>
<P>
Two interrupts are generated if both counters overflow. For each interrupt, registers a0.. a2 are <BR>
as follows: <BR>
<P>
a0 = osfint$ c_ perf (4) a1 = scb$ v_ perfmon (650) <BR>
a2 = 0 if performance counter 0 caused the interrupt a2 = 1 if performance counter 1 caused the interrupt <BR>
<P>
When the interrupt is taken, the PC is saved on the stack frame as the old PC. <BR>
<B>For the Windows NT Alpha Operating System <BR>
</B>When a counter overflows and interrupt enabling conditions are correct, the counter causes an <BR>
interrupt to PALcode. The PALcode builds a frame on the kernel stack and dispatches to the <BR>
kernel at the interrupt entry point. 
332
<BR>
<A href=#page332>332</A>
<strong><A name=page333> Page 333</A></strong>
<A href=#page334>334</A>
<BR>
<P>
Waivers and Implementation-Dependent Functionality <B>E– 5 <BR>
E. 2.1.2 Functions and Arguments for the DECchip 21064/ 21066/ 21068 <BR>
</B>The functions execute on a single (the current running) processor only and are described in <BR>
<A href="#page333">Table E– 1. <BR>
</A>
<P>
<B>° </B>The OpenVMS Alpha MTPR_ PERFMON instruction is called with a function code in R16, a function-specific argument in R17, and status is returned in R0. <BR>
<B>° </B>The DIGITAL UNIX wrperfmon instruction is called with a function code in a0, a func-tion specific argument in a1, and status is returned in v0. <BR>
<B>° </B>The Windows NT Alpha wrperfmon instruction is called with input parameters a0 through a3, as shown <A href="#page333">in Table E– 1. <BR>
</A>
<P>
<B>Table E– 1: DECchip 21064/ 21066/ 21068 Performance Monitoring Functions <BR>
</B><P>
<B>Function Register Usage Comments <BR>
Enable performance monitoring </B>Enable takes effect at the next IPL change <BR>
DIGITAL UNIX <BR>
Input: a0 = 1 Function code <BR>
a1 = 0 Argument <BR>
Output: v0 = 1 Success <BR>
v0 = 0 Failure (not generated) <BR>
OpenVMS Alpha <BR>
Input: R16 = 1 Function code <BR>
R17 = 0 Argument <BR>
Output: R0 = 1 Success <BR>
R0 = 0 Failure (not generated) <BR>
Windows NT Alpha <BR>
Input: a0 = 0 Select counter 0 <BR>
a0 = 1 Select counter 1 <BR>
a1 = 1 Enable selected counter <BR>
<P>
<B>Disable performance monitoring </B>Disable takes effect at the next IPL change <BR>
DIGITAL UNIX <BR>
Input: a0 = 0 Function code <BR>
a1 = 0 Argument <BR>
Output: v0 = 1 Success <BR>
v0 = 0 Failure (not generated) <BR>
OpenVMS Alpha <BR>
Input: R16 = 0 Function code <BR>
R17 = 0 Argument <BR>
Output: R0 = 1 Success <BR>
R0 = 0 Failure (not generated) 
333
<BR>
<A href=#page333>333</A>
<strong><A name=page334> Page 334</A></strong>
<A href=#page335>335</A>
<BR>
<P>
<B>E– 6 </B>Alpha Architecture Handbook <BR>
Windows NT Alpha <BR>
Input: a0 = 0 Select counter 0 <BR>
a0 = 1 Select counter 1 <BR>
a1 = 0 Disable selected counter <BR>
<P>
<B>Select desired events (mux_ ctl) <BR>
</B>DIGITAL UNIX <BR>
Input: a0 = 2 Function code <BR>
a1 = mux_ ctl <I>mux_ ctl </I>is the exact contents of those fields <BR>
from the ICCSR register, in write format, <BR>
described in <A href="#page335">Table E– 2. <BR>
</A>
<P>
Output: v0 = 1 Success <BR>
v0 = 0 Failure (not generated) <BR>
OpenVMS Alpha <BR>
Input: R16 = 2 Function code <BR>
R17 = mux_ ctl <I>mux_ ctl </I>is the exact contents of those fields <BR>
from the ICCSR register, in write format, <BR>
described in <A href="#page335">Table E– 2. <BR>
</A>
<P>
Output: R0 = 1 Success <BR>
R0 = 0 Failure (not generated) <BR>
Windows NT Alpha <BR>
Input: a2 = PCMUX0 For ICCSR&lt; PCMUX0&gt; field when a0 = 0 <BR>
a2 = PCMUX1 For ICCSR&lt; PCMUX1&gt; field when a0 = 1 <BR>
a3 = PC0 For ICCSR&lt; PC0&gt; field when a0 = 0 <BR>
a3 = PC1 For ICCSR&lt; PC1&gt; field when a0 = 1 <BR>
<P>
<B>Select performance monitoring options <BR>
</B>DIGITAL UNIX <BR>
Input: a0 = 3 Function code <BR>
a1 = opt Function argument <I>opt </I>is: <BR>
&lt;0&gt; = log all processes if set <BR>
&lt;1&gt; = log only selected if set <BR>
<P>
Output: v0 = 1 Success <BR>
v0 = 0 Failure (not generated) <BR>
<P>
<B>Table E– 1: DECchip 21064/ 21066/ 21068 Performance Monitoring Functions <BR>
(Continued) <BR>
</B><P>
<B>Function Register Usage Comments </B>
334
<BR>
<A href=#page334>334</A>
<strong><A name=page335> Page 335</A></strong>
<A href=#page336>336</A>
<BR>
Waivers and Implementation-Dependent Functionality <B>E– 7 <BR>
</B>OpenVMS Alpha <BR>
Input: R16 = 3 Function code <BR>
R17 = opt Function argument <I>opt </I>is: <BR>
&lt;0&gt; = log all processes if set <BR>
&lt;1&gt; = log only selected if set <BR>
<P>
Output: R0 = 1 Success <BR>
R0 = 0 Failure (not generated) <BR>
<P>
<B>Table E– 2: DECchip 21064/ 21066/ 21068 MUX Control Fields in ICCSR Register <BR>
</B><P>
<B>Bits Option Description <BR>
</B>34: 32 PCMUX1 Event selection, counter 1: <BR>
<P>
<B>Table E– 1: DECchip 21064/ 21066/ 21068 Performance Monitoring Functions <BR>
(Continued) <BR>
</B><P>
<B>Function Register Usage Comments <BR>
</B><P>
<B>Value Description <BR>
</B>0 Total D-cache misses <BR>
1 Total I-cache misses <BR>
2 Cycles of dual issue <BR>
3 Branch mispredicts (conditional, JSR, HW_ REI) <BR>
4 FP operate instructions (not BR, LOAD, STORE) <BR>
5 Integer operates (including LDA, LDAH into R0– R30) <BR>
6 Total store instructions <BR>
7 External events supplied by pin 
335
<BR>
<A href=#page335>335</A>
<strong><A name=page336> Page 336</A></strong>
<A href=#page337>337</A>
<BR>
<B>E– 8 </B>Alpha Architecture Handbook <BR>
11: 8 PCMUX0 Event selection, counter 0: <BR>
3 PC0 Frequency setting, counter 0: <BR>
0 PC1 Frequency setting, counter 1: <BR>
<P>
<B>Table E– 2: DECchip 21064/ 21066/ 21068 MUX Control Fields in ICCSR Register <BR>
(Continued) <BR>
</B><P>
<B>Bits Option Description <BR>
</B><P>
<B>Value Description <BR>
</B>0 Total issues divided by 2 <BR>
1 Unused <BR>
2 Nothing issued, no valid I-stream data <BR>
3 Unused <BR>
4 All load instructions <BR>
5 Unused <BR>
6 Nothing issued, resource conflict <BR>
7 Unused <BR>
8 All branches (conditional, unconditional, JSR, HW_ REI) <BR>
9 Unused <BR>
10 Total cycles <BR>
11 Cycles while in PALcode environment <BR>
12 Total nonissues divided by 2 <BR>
13 Unused <BR>
14 External event supplied by pin. <BR>
15 Unused <BR>
<P>
<B>Value Description <BR>
</B>0 2** 16 (65536) events per interrupt <BR>
<P>
1 2** 12 (4096) events per interrupt <BR>
<P>
<B>Value Description <BR>
</B>0 2** 12 (4096) events per interrupt <BR>
1 2** 8 (256) events per interrupt 
336
<BR>
<A href=#page336>336</A>
<strong><A name=page337> Page 337</A></strong>
<A href=#page338>338</A>
<BR>
Waivers and Implementation-Dependent Functionality <B>E– 9 <BR>
E. 2.2 DECchip 21164/ 21164PC Performance Monitoring <BR>
</B>Unless otherwise stated, the term "21164" in this section means implementations of the 21164 <BR>
at all frequencies. <BR>
<P>
PALcode instructions control the DECchip 21164/ 21164PC on-chip performance counters. For <BR>
OpenVMS Alpha, the instruction is MTPR_ PERFMON; for DIGITAL UNIX and Windows <BR>
NT Alpha, the instruction is wrperfmon. <BR>
<P>
The instruction arguments and results are described in the following sections. The scratch reg-ister <BR>
usage is operating system specific. <BR>
<P>
Three on-chip counters count events. Counters 0 and 1 are 16-bit counters; counter 2 is a 14-bit <BR>
counter. Each counter can be individually programmed. Counters can be read and written and <BR>
are not required to interrupt. The counters can be collectively restricted according to the pro-cessor <BR>
mode. <BR>
<P>
Processes can be selectively monitored with the PME bit. <BR>
<B>E. 2.2.1 Performance Monitor Interrupt Mechanism <BR>
</B>The performance monitoring interrupt mechanism varies according to the particular operating <BR>
system. <BR>
<P>
<B>For the OpenVMS Alpha Operating System <BR>
</B>When a counter overflows and interrupt enabling conditions are correct, the counter causes an <BR>
interrupt to PALcode. The PALcode builds an appropriate stack frame. The PALcode then dis-patches <BR>
in the form of an exception (not in the form of an interrupt) to the operating system by <BR>
ve c toring to the SCB per f ormance monitor e ntry point through SCBB+ 650 <BR>
(HWSCB$ Q_ PERF_ MONITOR), at IPL 29, in kernel mode. <BR>
<P>
An interrupt is generated for each counter overflow. For each interrupt, the status of each <BR>
counter overflow is indicated by register R4: <BR>
<P>
R4 = 0 if performance counter 0 caused the interrupt R4 = 1 if performance counter 1 caused the interrupt <BR>
R4 = 2 if performance counter 2 caused the interrupt <BR>
When the interrupt is taken, the PC is saved on the stack frame as the old PC. <BR>
<B>For the DIGITAL UNIX Operating System <BR>
</B>When a counter overflows and interrupt enabling conditions are correct, the counter causes an <BR>
interrupt to PALcode. The PALcode builds an appropriate stack frame and dispatches to the <BR>
operating system by vectoring to the interrupt entry point entINT, at IPL 6, in kernel mode. <BR>
An interrupt is generated for each counter overflow. For each interrupt, registers a0.. a2 are as <BR>
follows: <BR>
a0 = osfint$ c_ perf (4) a1 = scb$ v_ perfmon (650) <BR>
<P>
a2 = 0 if performance counter 0 caused the interrupt a2 = 1 if performance counter 1 caused the interrupt 
337
<BR>
<A href=#page337>337</A>
<strong><A name=page338> Page 338</A></strong>
<A href=#page339>339</A>
<BR>
<P>
<B>E– 10 </B>Alpha Architecture Handbook <BR>
<B>For the Windows NT Alpha Operating System <BR>
</B>When a counter overflows and interrupt enabling conditions are correct, the counter causes an <BR>
interrupt to PALcode. The PALcode builds a frame on the kernel stack and dispatches to the <BR>
kernel at the interrupt entry point. <BR>
<P>
<B>E. 2.2.2 Windows NT Alpha Functions and Argument <BR>
</B>The functions for Windows NT Alpha execute on only a single (the current running) processor. <BR>
The wrperfmon instruction is called with the following input registers: <BR>
<P>
<B>Input <BR>
Register <BR>
Contents <BR>
(Bits) Meaning <BR>
</B><P>
a0 63– 0 The register in <A href="#page339">Table E– 3, </A>
which contains the value to be written to the hardware PMCTR register. <BR>
<P>
a1 0 When a1 = 0, write a0 to the hardware PMCTR register. <BR>
When a1 = 1, read the hardware PMCTR register. The returned <BR>
PMCTR register is written to register v0. <BR>
<P>
a2 2– 0 Has meaning when PCSEL1 in <A href="#page339">Table E– 3 </A>
has the value 0xF. Con-tents <BR>
are determined by processor type: <BR>
<P>
a3 2– 0 Has meaning when PCSEL2 in <A href="#page339">Table E– 3 </A>
has the value 0xF. Con-tents <BR>
are determined by processor type: <BR>
<P>
<B>Processor Contents Reference <BR>
</B>21164 CBOX1 <A href="#page349">Table E– 15 <BR>
</A>
21164PC PM0_ MUX <A href="#page350">Table E– 17 <BR>
</A>
<P>
<B>Processor Contents Reference <BR>
</B>21164 CBOX2 <A href="#page349">Table E– 16 <BR>
</A>
21164PC PM1_ MUX <A href="#page350">Table E– 18 
338
<BR>
<A href=#page338>338</A>
<strong><A name=page339> Page 339</A></strong>
<A href=#page340>340</A>
<BR>
<P>
</A>
Waivers and Implementation-Dependent Functionality <B>E– 11 <BR>
Table E– 3: Bit Summary of PMCTR Register for Windows NT Alpha <BR>
Bits Name Meaning <BR>
</B>63– 48 CTR0 Counter 0 value <BR>
47– 32 CTR1 Counter 1 value <BR>
31 PCSEL0 Counter 0 selection: <BR>
<P>
30 Must be set to <A href="#page340">one 1 <BR>
</A>
29– 16 CTR2 Counter 2 value <BR>
15– 14 CTL0 Counter 0 control: <BR>
<P>
13– 12 CTL1 Counter 1 control: <BR>
11– 10 CTL2 Counter 2 control: <BR>
<P>
<B>Value Meaning <BR>
</B>0 Cycles <BR>
1 Issues <BR>
<P>
<B>Value Meaning <BR>
</B>0 Counter disable, interrupt disable <BR>
1 Counter enable, interrupt disable <BR>
2 Counter enable, interrupt at count 65536 <BR>
3 Counter enable, interrupt at count 256 <BR>
<P>
<B>Value Meaning <BR>
</B>0 Counter disable, interrupt disable <BR>
1 Counter enable, interrupt disable <BR>
2 Counter enable, interrupt at count 65536 <BR>
3 Counter enable, interrupt at count 256 <BR>
<P>
<B>Value Meaning <BR>
</B>0 Counter disable, interrupt disable <BR>
1 Counter enable, interrupt disable <BR>
2 Counter enable, interrupt at count 16384 <BR>
3 Counter enable, interrupt at count 256 
339
<BR>
<A href=#page339>339</A>
<strong><A name=page340> Page 340</A></strong>
<A href=#page341>341</A>
<BR>
<P>
<B>E– 12 </B>Alpha Architecture Handbook <BR>
<B>E. 2.2.3 OpenVMS Alpha and DIGITAL UNIX Functions and Arguments <BR>
</B>The functions execute only on a single (the current running) processor and are described in <BR>
<A href="#page340">Table E– 4. <BR>
</A>
<P>
The OpenVMS Alpha MTPR_ PERFMON instruction is called with a function code in R16, a <BR>
function-specific argument in R17, and status is returned in R0. <BR>
<P>
The DIGITAL UNIX wrperfmon instruction is called with a function code in a0, a function <BR>
specific argument in a1, and status is returned in v0. <BR>
<P>
9– 8 MODE_ SELECT 1 Select modes in which to count: <BR>
7– 4 PCSEL1 Counter 1 selection. <A href="#page347">See Table E– 13 <BR>
</A>
3– 0 PCSEL2 Counter 2 selection. <A href="#page348">See Table E– 14 <BR>
</A>
1 Windows NT Alpha uses bits 30 and 9– 8 differently than as documented in the 21164 Hard-ware <BR>
Reference Manual; it uses the processor executive mode to run user (nonprivileged) <BR>
code. Therefore, bit 30 is always set to one and bits 9– 8 are used to select the mode. <BR>
<P>
<B>Table E– 4: OpenVMS Alpha and DIGITAL UNIX Performance Monitoring <BR>
Functions <BR>
</B><P>
<B>Function Register Usage Comments <BR>
Enable performance monitoring; do not reset counters <BR>
</B>DIGITAL UNIX <BR>
Input: a0 = 1 Function code value <BR>
a1 = arg Argument from <A href="#page343">Table E– 5 <BR>
</A>
Output: v0 = 1 Success <BR>
v0 = 0 Failure (not generated) <BR>
OpenVMS Alpha <BR>
Input: R16 = 1 Function code value <BR>
R17 = arg Argument from <A href="#page343">Table E– 5 <BR>
</A>
Output: R0 = 1 Success <BR>
R0 = 0 Failure (not generated) <BR>
<P>
<B>Table E– 3: Bit Summary of PMCTR Register for Windows NT Alpha <BR>
(Continued) <BR>
</B><P>
<B>Bits Name Meaning <BR>
</B><P>
<B>Value Meaning <BR>
</B>0 Count all modes <BR>
1 Count PALmode only <BR>
2 Count all modes except PALmode <BR>
3 Count only user mode 
340
<BR>
<A href=#page340>340</A>
<strong><A name=page341> Page 341</A></strong>
<A href=#page342>342</A>
<BR>
<P>
Waivers and Implementation-Dependent Functionality <B>E– 13 <BR>
Enable performance monitoring; start the counters from zero <BR>
</B>DIGITAL UNIX <BR>
Input: a0 = 7 Function code value <BR>
a1 = arg Argument from <A href="#page343">Table E– 5 <BR>
</A>
Output: v0 = 1 Success <BR>
v0 = 0 Failure (not generated) <BR>
OpenVMS Alpha <BR>
Input: R16 = 7 Function code value <BR>
R17 = arg Argument from <A href="#page343">Table E– 5 <BR>
</A>
Output: R0 = 1 Success <BR>
R0 = 0 Failure (not generated) <BR>
<P>
<B>Disable performance monitoring; do not reset counters <BR>
</B>DIGITAL UNIX <BR>
Input: a0 = 0 Function code value <BR>
a1 = arg Argument from <A href="#page343">Table E– 6 <BR>
</A>
Output: v0 = 1 Success <BR>
v0 = 0 Failure (not generated) <BR>
OpenVMS Alpha <BR>
Input: R16 = 0 Function code value <BR>
R17 = arg Argument from <A href="#page343">Table E– 6 <BR>
</A>
Output: R0 = 1 Success <BR>
R0 = 0 Failure (not generated) <BR>
<P>
<B>Select desired events (MUX_ SELECT) <BR>
</B>DIGITAL UNIX <BR>
Input: a0 = 2 Function code value <BR>
a1 = arg Argument from <A href="#page344">Table E– 7 </A>
<A href="#page344">or E– 8 <BR>
</A>
Output: v0 = 1 Success <BR>
v0 = 0 Failure (not generated) <BR>
OpenVMS Alpha <BR>
Input: R16 = 2 Function code value <BR>
R17 = arg Argument from <A href="#page344">Table E– 7 </A>
<A href="#page344">or E– 8 <BR>
</A>
Output: R0 = 1 Success <BR>
R0 = 0 Failure (not generated) <BR>
<P>
<B>Table E– 4: OpenVMS Alpha and DIGITAL UNIX Performance Monitoring <BR>
Functions (Continued) <BR>
</B><P>
<B>Function Register Usage Comments </B>
341
<BR>
<A href=#page341>341</A>
<strong><A name=page342> Page 342</A></strong>
<A href=#page343>343</A>
<BR>
<P>
<B>E– 14 </B>Alpha Architecture Handbook <BR>
<B>Select Processor Mode options <BR>
</B>DIGITAL UNIX <BR>
Input: a0 = 3 Function code value <BR>
a1 = arg Argument from <A href="#page345">Table E– 9 <BR>
</A>
Output: v0 = 1 Success <BR>
v0 = 0 Failure (not generated) <BR>
OpenVMS Alpha <BR>
Input: R16 = 3 Function code value <BR>
R17 = arg Argument from <A href="#page345">Table E– 9 <BR>
</A>
Output: R0 = 1 Success <BR>
R0 = 0 Failure (not generated) <BR>
<P>
<B>Select interrupt frequencies <BR>
</B>DIGITAL UNIX <BR>
Input: a0 = 4 Function code value <BR>
a1 = arg Argument from <A href="#page346">Table E– 10 <BR>
</A>
Output: v0 = 1 Success <BR>
v0 = 0 Failure (not generated) <BR>
OpenVMS Alpha <BR>
Input: R16 = 4 Function code value <BR>
R17 = arg Argument from <A href="#page346">Table E– 10 <BR>
</A>
Output: R0 = 1 Success <BR>
R0 = 0 Failure (not generated) <BR>
<P>
<B>Read the counters <BR>
</B>DIGITAL UNIX <BR>
Input: a0 = 5 Function code value <BR>
a1 = arg Argument from <A href="#page347">Table E– 11 <BR>
</A>
Output: v0 = val Return value <A href="#page347">from Table E– 11 <BR>
</A>
OpenVMS Alpha <BR>
Input: R16 = 5 Function code value <BR>
R17 = arg Argument from <A href="#page347">Table E– 11 <BR>
</A>
Output: R0 = val Return value <A href="#page347">from Table E– 11 <BR>
</A>
<P>
<B>Table E– 4: OpenVMS Alpha and DIGITAL UNIX Performance Monitoring <BR>
Functions (Continued) <BR>
</B><P>
<B>Function Register Usage Comments </B>
342
<BR>
<A href=#page342>342</A>
<strong><A name=page343> Page 343</A></strong>
<A href=#page344>344</A>
<BR>
<P>
Waivers and Implementation-Dependent Functionality <B>E– 15 <BR>
Write the counters <BR>
</B>DIGITAL UNIX <BR>
Input: a0 = 6 Function code value <BR>
a1 = arg Argument from <A href="#page347">Table E– 12 <BR>
</A>
Output: v0 = 1 Success <BR>
v0 = 0 Failure (not generated) <BR>
OpenVMS Alpha <BR>
Input: R16 = 6 Function code value <BR>
R17 = arg Argument from <A href="#page347">Table E– 12 <BR>
</A>
Output: R0 = 1 Success <BR>
R0 = 0 Failure (not generated) <BR>
<P>
<B>Table E– 5: 21164/ 21164PC Enable Counters for OpenVMS Alpha and DIGITAL <BR>
UNIX <BR>
</B><P>
<B>Bits Meaning When Set <BR>
</B>2 Operate on counter 2 <BR>
1 Operate on counter 1 <BR>
0 Operate on counter 0 <BR>
<P>
<B>Table E– 6: 21164/ 21164PC Disable Counters for OpenVMS Alpha and DIGITAL <BR>
UNIX <BR>
</B><P>
<B>Bits Meaning When Set <BR>
</B>2 Operate on counter 2 <BR>
1 Operate on counter 1 <BR>
0 Operate on counter 0 <BR>
<P>
<B>Table E– 4: OpenVMS Alpha and DIGITAL UNIX Performance Monitoring <BR>
Functions (Continued) <BR>
</B><P>
<B>Function Register Usage Comments </B>
343
<BR>
<A href=#page343>343</A>
<strong><A name=page344> Page 344</A></strong>
<A href=#page345>345</A>
<BR>
<P>
<B>E– 16 </B>Alpha Architecture Handbook <BR>
<B>Table E– 7: 21164 Select Desired Events for OpenVMS Alpha and DIGITAL <BR>
UNIX <BR>
</B><P>
<B>Bits Name Meaning <BR>
</B>63: 32 MBZ <BR>
31 PCSEL0 Counter 0 selection: <BR>
<P>
30: 25 MBZ <BR>
24: 22 CBOX2 CBOX2 event selection (only has meaning when event selection field <BR>
PCSEL2 is value &lt;15&gt;; otherwise MBZ). CBOX2 described in <A href="#page349">Table E– <BR>
</A>
<A href="#page349">16. <BR>
</A>
<P>
21: 19 CBOX1 CBOX1 event selection (only has meaning when event selection field <BR>
PCSEL1 is value &lt;15&gt;; otherwise MBZ). CBOX1 described in <A href="#page349">Table E– <BR>
</A>
<A href="#page349">15. <BR>
</A>
<P>
18: 8 MBZ <BR>
7: 4 PCSEL1 Counter 1 event selection. PCSEL1 described <A href="#page347">in Table E– 13. <BR>
</A>
3: 0 PCSEL2 Counter 2 event selection. PCSEL2 described <A href="#page348">in Table E– 14. <BR>
</A>
<P>
<B>Table E– 8: 21164PC Select Desired Events for OpenVMS Alpha and DIGITAL <BR>
UNIX <BR>
</B><P>
<B>Bits Name Meaning <BR>
</B>63: 32 MBZ <BR>
31 PCSEL0 Counter 0 selection: <BR>
<P>
30: 14 MBZ <BR>
13: 11 PM1_ MUX PM1_ MUX event selection (only has meaning when event selec-tion <BR>
field PCSEL2 is value &lt;15&gt;; otherwise MBZ). PM1_ MUX is <BR>
described in <A href="#page350">Table E– 18. <BR>
</A>
<P>
10: 8 PM0_ MUX PM0_ MUX event selection (only has meaning when event selec-tion <BR>
field PCSEL1 is value &lt;15&gt;; otherwise MBZ). PM0_ MUX is <BR>
described in <A href="#page350">Table E– 17. <BR>
</A>
<P>
<B>Value Meaning <BR>
</B>0 Cycles <BR>
1 Issues <BR>
<P>
<B>Value Meaning <BR>
</B>0 Cycles <BR>
1 Issues 
344
<BR>
<A href=#page344>344</A>
<strong><A name=page345> Page 345</A></strong>
<A href=#page346>346</A>
<BR>
<P>
Waivers and Implementation-Dependent Functionality <B>E– 17 <BR>
</B>Setting any of the "NOT" bits causes the counters to not count when the processor is running in <BR>
the specified mode. Under OpenVMS Alpha, "NOT_ KERNEL" also stops the count in execu-tive <BR>
and supervisor mode, except as noted below: <BR>
<P>
<B>Note: <BR>
</B>DIGITAL UNIX counts user mode by using the executive counter; that is, the count for <BR>
executive mode is returned as the user mode count. <BR>
<P>
7: 4 PCSEL1 Counter 1 event selection. PCSEL1 described <A href="#page347">in Table E– 13. <BR>
</A>
3: 0 PCSEL2 Counter 2 event selection. PCSEL2 described <A href="#page348">in Table E– 14. <BR>
</A>
<P>
<B>Table E– 9: 21164/ 21164PC Select Special Options for OpenVMS Alpha and <BR>
DIGITAL UNIX <BR>
</B><P>
<B>Bits Meaning <BR>
</B>63: 31 MBZ <BR>
30 Stop count in user mode <BR>
29: 10 MBZ <BR>
9 Stop count in PALmode <BR>
8 Stop count in kernel mode <BR>
7: 1 MBZ <BR>
0 Monitor selected processes (when clear monitor all processes) <BR>
<P>
<B>NOT_ BITS Counters Operate Under These Modes When Bits Set: <BR>
K U P <BR>
</B>0 0 0 K E S U P <BR>
0 0 1 K E S U <BR>
0 1 0 K E S P <BR>
0 1 1 K E S <BR>
1 0 0 U P <BR>
1 0 1 U <BR>
1 1 0 P <BR>
1 1 1 E S (here "NOT_ KERNEL" stops kernel counter only) <BR>
<P>
<B>Table E– 8: 21164PC Select Desired Events for OpenVMS Alpha and DIGITAL <BR>
UNIX (Continued) <BR>
</B><P>
<B>Bits Name Meaning </B>
345
<BR>
<A href=#page345>345</A>
<strong><A name=page346> Page 346</A></strong>
<A href=#page347>347</A>
<BR>
<P>
<B>E– 18 </B>Alpha Architecture Handbook <BR>
<B>Table E– 10: 21164/ 21164PC Select Desired Frequencies for OpenVMS Alpha and <BR>
DIGITAL UNIX <BR>
</B><P>
<A href="#page346">Table E– 10 </A>
contains the selection definitions for each of the three counters. All frequency <BR>
fields are two-bit fields with the following values defined: <BR>
<P>
<B>Bits Meaning When Set <BR>
</B>63: 10 MBZ <BR>
9: 8 Counter 0 frequency: <BR>
<P>
7: 6 Counter 1 frequency: <BR>
5: 4 Counter 2 frequency: <BR>
<P>
3: 0 MBZ <BR>
<P>
<B>Value Meaning <BR>
</B>0 Do not interrupt <BR>
1 Unused <BR>
2 Low frequency (2** 16 (65536) events per interrupt) <BR>
3 High frequency (2** 8 (256) events per interrupt) <BR>
<P>
<B>Value Meaning <BR>
</B>0 Do not interrupt <BR>
1 Unused <BR>
2 Low frequency (2** 16 (65536) events per interrupt) <BR>
3 High frequency (2** 8 (256) events per interrupt) <BR>
<P>
<B>Value Meaning <BR>
</B>0 Do not interrupt <BR>
1 Unused <BR>
2 Low frequency (2** 14 (16384) events per interrupt) <BR>
3 High frequency (2** 8 (256) events per interrupt) 
346
<BR>
<A href=#page346>346</A>
<strong><A name=page347> Page 347</A></strong>
<A href=#page348>348</A>
<BR>
Waivers and Implementation-Dependent Functionality <B>E– 19 <BR>
Table E– 11: 21164/ 21164PC Read Counters for OpenVMS Alpha and DIGITAL <BR>
UNIX <BR>
</B><P>
<B>Bits Meaning When Returned <BR>
</B>63: 48 Counter 0 returned value <BR>
47: 32 Counter 1 returned value <BR>
31: 30 MBZ <BR>
29: 16 Counter 2 returned value <BR>
15: 1 MBZ <BR>
0 Set means success; clear means failure <BR>
<P>
<B>Table E– 12: 21164/ 21164PC Write Counters for OpenVMS Alpha and DIGITAL <BR>
UNIX <BR>
</B><P>
<B>Bits Meaning <BR>
</B>63: 48 Counter 0 written value <BR>
47: 32 Counter 1 written value <BR>
31: 30 MBZ <BR>
29: 16 Counter 2 written value <BR>
15: 0 MBZ <BR>
<P>
<B>Table E– 13: 21164/ 21164PC Counter 1 (PCSEL1) Event Selection <BR>
</B>The following values choose the counter 1 (PCSEL1) event selection: <BR>
<P>
<B>Value Meaning <BR>
</B>0 Nothing issued, pipeline frozen <BR>
1 Some but not all issuable instructions issued <BR>
2 Nothing issued, pipeline dry <BR>
3 Replay traps (ldu, wb/ maf, litmus test) <BR>
4 Single issue cycles <BR>
5 Dual issue cycles <BR>
6 Triple issue cycles <BR>
7 Quad issue cycles <BR>
8 Flow change (all branches, jsr-ret, hw_ rei), where: <BR>
If PCSEL2 has value 3, flow change is a conditional branch <BR>
If PCSEL2 has value 2, flow change is a JSR-RET 
347
<BR>
<A href=#page347>347</A>
<strong><A name=page348> Page 348</A></strong>
<A href=#page349>349</A>
<BR>
<P>
<B>E– 20 </B>Alpha Architecture Handbook <BR>
9 Integer operate instructions <BR>
10 Floating point operate instructions <BR>
11 Load instructions <BR>
12 Store instructions <BR>
13 Instruction cache access <BR>
14 Data cache access <BR>
15 For the 21164, use CBOX1 event selection <A href="#page349">in Table E– 15. <BR>
</A>
For the 21164PC, use PM0_ MUX event selection <A href="#page350">in Table E– 17. <BR>
</A>
<P>
<B>Table E– 14: 21164/ 21164PC Counter 2 (PCSEL2) Event Selection <BR>
</B>The following values choose the counter 2 (PCSEL2) event selection: <BR>
<P>
<B>Value Meaning <BR>
</B>0 Long stalls (&gt; 15 cycles) <BR>
1 Unused value <BR>
2 PC mispredicts <BR>
3 Branch mispredicts <BR>
4 I-cache misses <BR>
5 ITB misses <BR>
6 D-cache misses <BR>
7 DTB misses <BR>
8 Loads merged in MAF <BR>
9 LDU replays <BR>
10 WB/ MAF full replays <BR>
11 Event from external pin <BR>
12 Cycles <BR>
13 Memory barrier instructions <BR>
14 LDx/ L instructions <BR>
15 For the 21164, use CBOX2 event selection <A href="#page349">in Table E– 16. <BR>
</A>
For the 21164PC, use PM1_ MUX event selection <A href="#page350">in Table E– 18. <BR>
</A>
<P>
<B>Table E– 13: 21164/ 21164PC Counter 1 (PCSEL1) Event Selection (Continued) <BR>
</B>The following values choose the counter 1 (PCSEL1) event selection: <BR>
<P>
<B>Value Meaning </B>
348
<BR>
<A href=#page348>348</A>
<strong><A name=page349> Page 349</A></strong>
<A href=#page350>350</A>
<BR>
Waivers and Implementation-Dependent Functionality <B>E– 21 <BR>
Table E– 15: 21164 CBOX1 Event Selection <BR>
</B>The following values choose the CBOX1 event selection. <BR>
<P>
<B>Val ue Me ani ng <BR>
</B>0 S-cache access <BR>
1 S-cache read <BR>
2 S-cache write <BR>
3 S-cache victim <BR>
4 Unused value <BR>
5 B-cache hit <BR>
6 B-cache victim <BR>
7 System request <BR>
<P>
<B>Table E– 16: 21164 CBOX2 Event Selection <BR>
</B>The following values choose the CBOX2 event selection. <BR>
<P>
<B>Value Meaning <BR>
</B>0 S-cache misses <BR>
1 S-cache read misses <BR>
2 S-cache write misses <BR>
3 S-cache shared writes <BR>
4 S-cache writes <BR>
5 B-cache misses <BR>
6 System invalidates <BR>
7 System read requests 
349
<BR>
<A href=#page349>349</A>
<strong><A name=page350> Page 350</A></strong>
<A href=#page351>351</A>
<BR>
<B>E– 22 </B>Alpha Architecture Handbook <BR>
<B>Table E– 17: 21164PC PM0_ MUX Event Selection <BR>
</B>The following values choose the PM0_ MUX event selection and perform the chosen operation <BR>
in Counter 0. <BR>
<P>
<B>Value Meaning <BR>
</B>0 B-cache read operations <BR>
1 B-cache D read hits <BR>
2 B-cache D read fills <BR>
3 B-cache write operations <BR>
4 Undefined <BR>
5 B-cache clean write hits <BR>
6 B-cache victims <BR>
7 Read miss 2 launched <BR>
<P>
<B>Table E– 18: 21164PC PM1_ MUX Event Selection <BR>
</B>The following values choose the PM1_ MUX event selection and perform the chosen operation <BR>
in Counter 1. <BR>
<P>
<B>Value Meaning <BR>
</B>0 B-cache D read operations <BR>
1 B-cache read hits <BR>
2 B-cache read fills <BR>
3 B-cache write hits <BR>
4 B-cache write fills <BR>
5 System read/ flush B-cache hits <BR>
6 System read/ flush B-cache misses <BR>
7 Read miss 3 launched 
350
<BR>
<A href=#page350>350</A>
<strong><A name=page351> Page 351</A></strong>
<A href=#page352>352</A>
<BR>
Waivers and Implementation-Dependent Functionality <B>E– 23 <BR>
E. 2.3 21264 Performance Monitoring <BR>
</B>PALcode instructions control the 21264 on-chip performance counters. For OpenVMS Alpha, <BR>
the instruction is MTPR_ PERFMON; for DIGITAL UNIX and Windows NT Alpha, the <BR>
instruction is wrperfmon. <BR>
<P>
The instruction arguments and results are described in the following sections. The scratch reg-ister <BR>
usage is operating system specific. <BR>
<P>
Two 20-bit on chip counters count events. Counters can be individually programmed, read, and <BR>
written. <BR>
<P>
Processes can be selectively monitored with the PME bit. <BR>
Profile monitoring for the 21264 is called aggregate mode profile monitoring because it pro-vides <BR>
an aggregate count. <BR>
<P>
<B>E. 2.3.1 Performance Monitor Interrupt Mechanism <BR>
</B>The performance monitoring interrupt mechanism varies according to the particular operating <BR>
system. <BR>
<P>
<B>For the OpenVMS Alpha Operating System <BR>
</B>When a counter overflows and interrupt enabling conditions are correct, the counter causes an <BR>
interrupt to PALcode. The PALcode builds an appropriate stack frame. The PALcode then dis-patches <BR>
in the form of an exception (not in the form of an interrupt) to the operating system by <BR>
ve c toring to the SCB per f ormance monitor e ntry point through SCBB+ 650 <BR>
(HWSCB$ Q_ PERF_ MONITOR), at IPL 29, in kernel mode. <BR>
<P>
An interrupt is generated for each counter overflow. For each interrupt, the status of each <BR>
counter overflow is indicated by register R4: <BR>
<P>
R4 = 0 if performance counter 0 caused the interrupt R4 = 1 if performance counter 1 caused the interrupt <BR>
<P>
When the interrupt is taken, the PC is saved on the stack frame as the old PC. <BR>
<B>For the DIGITAL UNIX Operating System <BR>
</B>When a counter overflows and interrupt enabling conditions are correct, the counter causes an <BR>
interrupt to PALcode. The PALcode builds an appropriate stack frame and dispatches to the <BR>
operating system by vectoring to the interrupt entry point entINT, at IPL 6, in kernel mode. <BR>
An interrupt is generated for each counter overflow. For each interrupt, registers a0.. a2 are as <BR>
follows: <BR>
a0 = osfint$ c_ perf (4) a1 = scb$ v_ perfmon (650) <BR>
<P>
a2 = 0 if performance counter 0 caused the interrupt a2 = 1 if performance counter 1 caused the interrupt 
351
<BR>
<A href=#page351>351</A>
<strong><A name=page352> Page 352</A></strong>
<A href=#page353>353</A>
<BR>
<P>
<B>E– 24 </B>Alpha Architecture Handbook <BR>
<B>For the Windows NT Alpha Operating System <BR>
</B>When a counter overflows and interrupt enabling conditions are correct, the counter causes an <BR>
interrupt to PALcode. The PALcode builds a frame on the kernel stack and dispatches to the <BR>
kernel at the interrupt entry point. <BR>
<P>
<B>E. 2.3.2 Windows NT Alpha Functions and Argument <BR>
</B>The functions for Windows NT Alpha execute on only a single (the current running) processor. <BR>
The wrperfmon instruction is called with the following input registers: <BR>
<P>
<B>Input <BR>
Register <BR>
Contents <BR>
(Bits) Meaning <BR>
</B><P>
a0 63– 0 The register in <A href="#page352">Table E– 19, </A>
which contains the value to be written to the hardware PCTR_ CTL register. <BR>
<P>
a1 0 When a1 = 0, write a0 to the hardware PCTR_ CTL register. <BR>
When a1 = 1, read the hardware PCTR_ CTL register. The <BR>
returned PCTR_ CTL register is written to register v0. <BR>
<P>
<B>Table E– 19: Bit Summary of PCTR_ CTL Register for Windows NT Alpha <BR>
Bits Name Meaning <BR>
</B>63– 48 SEXT[ PCTR0_ CTL[ 47] <BR>
47– 28 PCTR0 Counter 0 value. <BR>
Enabled by setting I_ CTL[ PCT0_ EN] and either <BR>
I_ CTL[ SPCE] or PCTX[ PPCE]. On overflow, an <BR>
interrupt is triggered at ISUM[ PC0], if enabled by <BR>
IER_ CM[ PCEN0]. <BR>
Mode is determined by SL0 and operation is <BR>
described in SL1. <BR>
<P>
27– 26 Reserved <BR>
25– 6 PCTR1 Counter 1 value. <BR>
Enabled by setting I_ CTL[ PCT1_ EN] and either <BR>
I_ CTL[ SPCE] or PCTX[ PPCE]. On overflow, an <BR>
interrupt is triggered at ISUM[ PC1], if enabled by <BR>
IER_ CM[ PCEN1]. <BR>
Operation is described in SL1. <BR>
<P>
5 Reserved <BR>
4 SL0 PCTR0 input selecter: <BR>
<B>Value Meaning <BR>
</B>0 Aggregate counting mode <BR>
1 Reserved 
352
<BR>
<A href=#page352>352</A>
<strong><A name=page353> Page 353</A></strong>
<A href=#page354>354</A>
<BR>
<P>
Waivers and Implementation-Dependent Functionality <B>E– 25 <BR>
E. 2.3.3 OpenVMS Alpha and DIGITAL UNIX Functions and Arguments <BR>
</B>The functions execute only on a single (the current running) processor and are described in <BR>
<A href="#page353">Table E– 20. <BR>
</A>
<P>
The OpenVMS Alpha MTPR_ PERFMON instruction is called with a function code in R16, a <BR>
function-specific argument in R17, and any output is returned in R0. <BR>
<P>
The DIGITAL UNIX wrperfmon instruction is called with a function code in a0, a function-specific <BR>
argument in a1, and any output is returned in v0. <BR>
<P>
3– 2 SL1 PCTR1 input selector. If SL0 value is 0: <BR>
1– 0 Reserved <BR>
<B>Table E– 20: OpenVMS Alpha and DIGITAL UNIX Performance Monitoring <BR>
Functions <BR>
</B><P>
<B>Function Register Usage Comments <BR>
Enable performance monitoring <BR>
</B>DIGITAL UNIX <BR>
Input: a0 = 1 Function code value <BR>
a1 = arg Argument from <A href="#page355">Table E– 21 <BR>
</A>
OpenVMS Alpha <BR>
Input: R16 = 1 Function code value <BR>
R17 = arg Argument from <A href="#page355">Table E– 21 <BR>
</A>
<P>
<B>Table E– 19: Bit Summary of PCTR_ CTL Register for Windows NT Alpha <BR>
Bits Name Meaning <BR>
</B><P>
<B>Bit value Meaning <BR>
</B>0000 Counter 1 counts cycles. <BR>
0001 Counter 1 counts retired conditional <BR>
branches. <BR>
<P>
0010 Counter 1 counts retired branch mispre-dicts. <BR>
<P>
0011 Counter 1 counts retired DTB single <BR>
misses * 2. <BR>
<P>
0100 Counter 1 counts retired DTB double <BR>
double misses. <BR>
<P>
0101 Counter 1 counts retired ITB misses. <BR>
0110 Counter 1 counts retired unaligned traps. <BR>
0111 Counter 1 counts replay traps. 
353
<BR>
<A href=#page353>353</A>
<strong><A name=page354> Page 354</A></strong>
<A href=#page355>355</A>
<BR>
<P>
<B>E– 26 </B>Alpha Architecture Handbook <BR>
<B>Disable performance monitoring <BR>
</B>DIGITAL UNIX <BR>
Input: a0 = 0 Function code value <BR>
a1 = arg Argument from <A href="#page355">Table E– 22 <BR>
</A>
OpenVMS Alpha <BR>
Input: R16 = 0 Function code value <BR>
R17 = arg Argument from <A href="#page355">Table E– 22 <BR>
</A>
<P>
<B>Select desired events (MUX_ SELECT) <BR>
</B>DIGITAL UNIX <BR>
Input: a0 = 2 Function code value <BR>
a1 = arg Argument from <A href="#page356">Table E– 23 <BR>
</A>
OpenVMS Alpha <BR>
Input: R16 = 2 Function code value <BR>
R17 = arg Argument from <A href="#page356">Table E– 23 <BR>
</A>
<P>
<B>Select logging options <BR>
</B>DIGITAL UNIX <BR>
Input: a0 = 3 Function code value <BR>
a1[ 0] = 1 <BR>
a1[ 0] = 0 <BR>
Log all processes <BR>
Log only selected processes <BR>
<P>
OpenVMS Alpha <BR>
Input: R16 = 3 Function code value <BR>
R17[ 0] = 1 <BR>
R17[ 0] = 0 <BR>
Log all processes <BR>
Log only selected processes <BR>
<P>
<B>Read the counters <BR>
</B>DIGITAL UNIX <BR>
Input: a0 = 5 Function code value <BR>
Output: v0 = contents of the counters; <A href="#page356">see Table E– 24 <BR>
</A>
OpenVMS Alpha <BR>
Input: R16 = 5 Function code value <BR>
Output: R0 = contents of the counters; <A href="#page356">see Table E– 24 <BR>
</A>
<P>
<B>Table E– 20: OpenVMS Alpha and DIGITAL UNIX Performance Monitoring <BR>
Functions <BR>
</B><P>
<B>Function Register Usage Comments </B>
354
<BR>
<A href=#page354>354</A>
<strong><A name=page355> Page 355</A></strong>
<A href=#page356>356</A>
<BR>
<P>
Waivers and Implementation-Dependent Functionality <B>E– 27 <BR>
Write the counters <BR>
</B>DIGITAL UNIX <BR>
Input: a0 = 6 Function code value <BR>
a1 = arg Argument from <A href="#page356">Table E– 25 <BR>
</A>
OpenVMS Alpha <BR>
Input: R16 = 6 Function code value <BR>
R17 = arg Argument from <A href="#page356">Table E– 25 <BR>
</A>
<P>
<B>Enable and write selected counters <BR>
</B>DIGITAL UNIX <BR>
Input: a0 = 7 Function code value <BR>
a1 = arg Argument from <A href="#page357">Table E– 26 <BR>
</A>
OpenVMS Alpha <BR>
Input: R16 = 7 Function code value <BR>
R17 = arg Argument from <A href="#page357">Table E– 26 <BR>
</A>
<P>
<B>Table E– 21: 21264 Enable Counters for OpenVMS Alpha and DIGITAL UNIX <BR>
R17/ a1 Bits Meaning When Set <BR>
</B>1 Set I_ CTL[ PCT1_ EN], which enables counter 1 <BR>
0 Set I_ CTL[ PCT0_ EN], which enables counter 0 <BR>
<P>
<B>Table E– 22: 21264 Disable Counters for OpenVMS Alpha and DIGITAL UNIX <BR>
R17/ a1 Bits Meaning When Set <BR>
</B>1 Clear I_ CTL[ PCT1_ EN], which disables counter 1 <BR>
0 Clear I_ CTL[ PCT0_ EN], which disables counter 0 <BR>
<P>
<B>Table E– 20: OpenVMS Alpha and DIGITAL UNIX Performance Monitoring <BR>
Functions <BR>
</B><P>
<B>Function Register Usage Comments </B>
355
<BR>
<A href=#page355>355</A>
<strong><A name=page356> Page 356</A></strong>
<A href=#page357>357</A>
<BR>
<B>E– 28 </B>Alpha Architecture Handbook <BR>
<B>Table E– 23: 21264 Select Desired Events for OpenVMS Alpha and DIGITAL <BR>
UNIX <BR>
</B><P>
<B>R17/ a1 Bits Meaning <BR>
</B>4 <BR>
<P>
3– 2 <BR>
<P>
<B>Table E– 24: 21264 Read Counters for OpenVMS Alpha and DIGITAL UNIX <BR>
R0/ v0 Bits Meaning When Returned <BR>
</B>63– 48 Reserved <BR>
47– 28 Counter 0 returned value <BR>
27– 26 Reserved <BR>
25– 6 Counter 1 returned value <BR>
5– 0 Reserved <BR>
<P>
<B>Table E– 25: 21264 Write Counters for OpenVMS Alpha and DIGITAL UNIX <BR>
R17/ a1 Bits Meaning <BR>
</B>63– 48 Reserved <BR>
47– 28 Counter 0 value to write <BR>
27– 26 Reserved <BR>
25– 6 Counter 1 value to write <BR>
<P>
<B>Bit value Meaning <BR>
</B>1 Counter 0 counts retired instructions. <BR>
0 Counter 0 counts cycles. <BR>
<P>
<B>Bit value Meaning <BR>
</B>0000 Counter 1 counts cycles. <BR>
0001 Counter 1 counts retired conditional branches. <BR>
0010 Counter 1 counts retired branch mispredicts. <BR>
0011 Counter 1 counts retired DTB single misses * 2. <BR>
0100 Counter 1 counts retired DTB double double misses. <BR>
0101 Counter 1 counts retired ITB misses. <BR>
0110 Counter 1 counts retired unaligned traps. <BR>
0111 Counter 1 counts replay traps. 
356
<BR>
<A href=#page356>356</A>
<strong><A name=page357> Page 357</A></strong>
<A href=#page358>358</A>
<BR>
Waivers and Implementation-Dependent Functionality <B>E– 29 <BR>
Table E– 26: 21264 Enable and Write Counters for OpenVMS Alpha and <BR>
DIGITAL UNIX <BR>
</B><P>
5– 2 Reserved <BR>
1 When set, write to Counter 1 <BR>
0 When set, write to Counter 0 <BR>
<P>
<B>R17/ a1 Bits Meaning <BR>
</B>63– 48 Reserved <BR>
47– 28 Counter 0 value to write; writing zeroes clears the counter <BR>
27– 26 Reserved <BR>
25– 6 Counter 1 value to write; writing zeroes clears the counter <BR>
5– 2 Reserved <BR>
1 When set, enable and write to Counter 1 <BR>
0 When set, enable and write to Counter 0 <BR>
<P>
<B>Table E– 25: 21264 Write Counters for OpenVMS Alpha and DIGITAL UNIX <BR>
R17/ a1 Bits Meaning </B>
357
<BR>
<A href=#page357>357</A>
<strong><A name=page358> Page 358</A></strong>
<A href=#page359>359</A>
<BR>

358
<BR>
<A href=#page358>358</A>
<strong><A name=page359> Page 359</A></strong>
<A href=#page360>360</A>
<BR>
<P>
<B>Index– 1 <BR>
Index <BR>
A <BR>
</B>Aborts, forcing, <A href="#page248">6– 6 <BR>
</A>
ACCESS( x, y) operator, <A href="#page47">3– 7 <BR>
</A>
Add instructions <BR>
add longword, <A href="#page81">4– 25 </A>
add quadword, 4– 27 <BR>
</A>
<P>
add scaled <A href="#page83">longword, 4– 26 </A>
<A href="#page158">add scaled quadword, </A>
<A href="#page82">4– 28 <BR>
</A>
<A href="#page158">See also Floating-</A>
<A href="#page84">point operate <BR>
</A>
ADDF instruction, <A href="#page166">4– 110 <BR>
</A>
<P>
ADDG instruction, <A href="#page166">4– 110 <BR>
</A>
ADDL instruction, <A href="#page81">4– 25 <BR>
</A>
ADDQ instruction, <A href="#page83">4– 27 <BR>
</A>
Address space match (ASM) <BR>
virtual cache coherency, <A href="#page216">5– 4 <BR>
</A>
<P>
Address space number <A href="#page216">(ASN) register <BR>
</A>
virtual cache coherency, 5– 4 <BR>
</A>
ADDS instruction, <A href="#page167">4– 111 <BR>
</A>
<P>
ADDT instruction, <A href="#page167">4– 111 <BR>
</A>
AFTER, defined for memory access, <A href="#page224">5– 12 <BR>
</A>
Aligned byte/ word memory accesses, <A href="#page283">A– 9 <BR>
</A>
ALIGNED data objects, <A href="#page24">1– 8 <BR>
</A>
Alignment <BR>
atomic byte, <A href="#page215">5– 3 </A>
atomic longword, 5– 2 <BR>
</A>
<P>
atomic <A href="#page32">quadword, </A>
<A href="#page214">5– 2 </A>
D_ floating, <A href="#page32">2– 6 <BR>
</A>
data considerations, A– 4 </A>
double-<A href="#page30">width data </A>
<A href="#page278">paths, A– 1 <BR>
</A>
F_ floating, <A href="#page30">2– 4 </A>
G_ floating, 2– 5 <BR>
</A>
instruction, <A href="#page31">A– 2 </A>
longword, <A href="#page276">2– 2 <BR>
</A>
longword <A href="#page28">integer, 2– 12 </A>
memory <A href="#page29">accesses, </A>
<A href="#page38">A– 9 <BR>
</A>
quadword, <A href="#page29">2– 3 </A>
quadword integer, 2– 12 <BR>
</A>
S_ floating, <A href="#page34">2– 8 </A>
T_ floating, 2– 9 <BR>
</A>
X_ floating, <A href="#page35">2– 10 <BR>
</A>
<P>
Alpha <A href="#page27">architecture <BR>
</A>
<A href="#page17">addressing, </A>
<A href="#page27">2– 1 </A>
overview, 1– 1 <BR>
</A>
<P>
porting <A href="#page17">operating systems to, 1– 1 </A>
<A href="#page41">programming implications, </A>
<A href="#page17">5– 1 <BR>
</A>
registers, <A href="#page41">3– 1 </A>
<A href="#page22">security, </A>
<A href="#page41">1– 7 <BR>
</A>
<A href="#page22">See also </A>
<A href="#page23">Conventions <BR>
</A>
<A href="#page243">Alpha privileged architecture library. See PALcode <BR>
</A>
<P>
AMASK (Architecture mask) instruction, <A href="#page189">4– 133 <BR>
</A>
AMASK bit assignments, <A href="#page327">D– 3 <BR>
</A>
AND instruction, <A href="#page98">4– 42 <BR>
</A>
AND operator, <A href="#page47">3– 7 <BR>
</A>
Architecture extensions, AMASK with, <A href="#page189">4– 133 <BR>
</A>
ARITH_ RIGHT_ SHIFT( x, y) operator, <A href="#page47">3– 7 <BR>
</A>
Arithmetic instructions, <A href="#page80">4– 24 <BR>
</A>
<A href="#page80">See also specific </A>
<A href="#page80">arithmetic instructions <BR>
</A>
<P>
Arithmetic left shift instruction, <A href="#page97">4– 41 <BR>
</A>
<P>
Arithmetic traps <BR>
denormal operand exception disabling, <A href="#page137">4– 81 </A>
denormal operand <A href="#page295">exception enabled </A>
<A href="#page137">for, B– 5 <BR>
</A>
<P>
denormal <A href="#page134">operand status of, </A>
<A href="#page295">B– 5 </A>
disabling, <A href="#page134">4– 78 <BR>
</A>
division by zero, 4– 77, 4– 81 </A>
division by zero, <A href="#page133">disabling, </A>
<A href="#page137">4– 81 <BR>
</A>
division by zero, enabling, <A href="#page137">B– 6 </A>
division by zero, status <A href="#page136">of, </A>
<A href="#page296">B– 5 <BR>
</A>
dynamic <A href="#page295">rounding mode, </A>
<A href="#page295">4– 80 </A>
enabling, <A href="#page295">B– 5 <BR>
</A>
inexact result, 4– 78, 4– 81 </A>
inexact result, <A href="#page134">disabling, </A>
<A href="#page137">4– 80 <BR>
</A>
inexact result, enabling, <A href="#page136">B– 6 </A>
inexact result, <A href="#page134">status of, </A>
<A href="#page296">B– 5 <BR>
</A>
integer overflow, <A href="#page134">4– </A>
<A href="#page295">78, 4– 81 </A>
integer overflow, <A href="#page134">disabling, </A>
<A href="#page137">B– 5 <BR>
</A>
integer overflow, <A href="#page132">enabling, </A>
<A href="#page295">B– 5 </A>
invalid operation, <A href="#page132">4– 76, </A>
<A href="#page295">4– 81 <BR>
</A>
invalid operation, <A href="#page132">disabling, </A>
<A href="#page137">4– 81 </A>
invalid operation, enabling, <A href="#page137">B– 6 <BR>
</A>
invalid <A href="#page133">operation, </A>
<A href="#page137">status of, </A>
<A href="#page296">B– 5 </A>
overflow, <A href="#page133">4– 77, </A>
<A href="#page137">4– 81 <BR>
</A>
overflow, <A href="#page133">disabling, </A>
<A href="#page137">4– 81 </A>
overflow, enabling, <A href="#page137">B– 6 <BR>
</A>
overflow, status of, <A href="#page296">B– 5 
359
<BR>
<A href=#page359>359</A>
<strong><A name=page360> Page 360</A></strong>
<A href=#page361>361</A>
<BR>
<P>
</A>
<B>Index– 2 <BR>
</B>programming <A href="#page200">implications for, </A>
<A href="#page242">5– 30 </A>
TRAPB <A href="#page134">instruction </A>
<A href="#page137">with, </A>
<A href="#page200">4– </A>
<A href="#page242">144 <BR>
</A>
underflow, <A href="#page134">4– 78, </A>
<A href="#page137">4– 81 </A>
underflow <A href="#page134">to zero, </A>
<A href="#page137">disabling, 4– 80 <BR>
</A>
underflow, disabling, <A href="#page136">4– 80 </A>
underflow, enabling, B– 6 <BR>
</A>
underflow, status of, <A href="#page296">B– 5 <BR>
</A>
ASCII character set, <A href="#page324">C– 22 <BR>
</A>
<P>
Atomic access, <A href="#page215">5– 3 <BR>
</A>
Atomic operations <BR>
accessing longword datum, <A href="#page214">5– 2 </A>
accessing quadword datum, 5– 2 <BR>
</A>
<P>
updating shared data <A href="#page214">structures, 5– 7 </A>
using load locked and store <A href="#page219">conditional, 5– 7 <BR>
</A>
<P>
Atomic sequences, <A href="#page290">A– 16 <BR>
</A>
<P>
<B>B <BR>
</B>BEFORE, defined for memory access, <A href="#page224">5– 12 <BR>
</A>
BEQ instruction, <A href="#page76">4– 20 <BR>
</A>
BGE instruction, <A href="#page76">4– 20 <BR>
</A>
BGT instruction, <A href="#page76">4– 20 <BR>
</A>
BIC instruction, <A href="#page98">4– 42 <BR>
</A>
Big-endian addressing, <A href="#page39">2– 13 <BR>
</A>
byte operation examples, 4– 54 </A>
byte swapping <A href="#page107">for, </A>
<A href="#page285">A– 11 <BR>
</A>
<P>
extract byte <A href="#page111">with, </A>
<A href="#page285">4– 51 </A>
insert byte with, <A href="#page107">4– 55 <BR>
</A>
load F_ floating <A href="#page111">with, 4– 91 </A>
load long/ quad <A href="#page147">locked with, 4– 9 <BR>
</A>
load S_ floating <A href="#page113">with, </A>
<A href="#page149">4– 93 </A>
mask byte with, <A href="#page113">4– </A>
<A href="#page149">57 <BR>
</A>
store byte/ word <A href="#page113">with, 4– 15 </A>
store F_ floating with, <A href="#page71">4– 95 <BR>
</A>
store long/ quad <A href="#page151">conditional with, 4– 12 </A>
store long/ quad with, <A href="#page71">4– 15 <BR>
</A>
store S_ floating with, 4– 97 <BR>
</A>
Big-endian data types, X_ floating, <A href="#page36">2– 10 <BR>
</A>
<P>
BIS instruction, <A href="#page98">4– 42 <BR>
</A>
BLBC instruction, <A href="#page76">4– 20 <BR>
</A>
BLBS instruction, <A href="#page76">4– 20 <BR>
</A>
BLE instruction, <A href="#page76">4– 20 <BR>
</A>
BLT instruction, <A href="#page76">4– 20 <BR>
</A>
BNE instruction, <A href="#page76">4– 20 <BR>
</A>
Boolean instructions, <A href="#page97">4– 41 <BR>
</A>
logical functions, 4– 42 <BR>
</A>
Boolean stylized code forms, <A href="#page287">A– 13 <BR>
</A>
<P>
BPT (PALcode) instruction <BR>
required recognition of, <A href="#page246">6– 4 <BR>
</A>
bpt (PALcode) instruction <BR>
required recognition of, <A href="#page246">6– 4 <BR>
</A>
<P>
BR instruction, <A href="#page77">4– 21 <BR>
</A>
Branch instructions, <A href="#page74">4– 18 <BR>
</A>
backward conditional, 4– 20 </A>
conditional branch, <A href="#page76">4– 20 <BR>
</A>
<P>
floating-<A href="#page52">point, </A>
<A href="#page76">summarized, 4– 99 </A>
format of, <A href="#page52">3– 12 <BR>
</A>
forward conditional, 4– 20 </A>
opcodes and format <A href="#page76">summarized, C– 1 <BR>
</A>
<A href="#page74">unconditional branch, </A>
<A href="#page77">4– 21 </A>
<A href="#page74">See also Control </A>
<A href="#page77">instructions <BR>
</A>
<P>
Branch prediction model, <A href="#page74">4– 18 <BR>
</A>
Branch prediction stack, with BSR instruction, <A href="#page77">4– 21 <BR>
</A>
BSR instruction, <A href="#page77">4– 21 <BR>
</A>
BUGCHK (PALcode) <A href="#page246">instruction <BR>
</A>
required recognition of, 6– 4 <BR>
</A>
bugchk (PALcode) <A href="#page246">instruction <BR>
</A>
required recognition of, 6– 4 <BR>
</A>
Byte data type, <A href="#page27">2– 1 <BR>
</A>
atomic access of, 5– 3 <BR>
</A>
<P>
Byte manipulation, <A href="#page18">1– 2 <BR>
</A>
<P>
Byte manipulation instructions, <A href="#page103">4– 47 <BR>
</A>
Byte swapping, <A href="#page285">A– 11 <BR>
</A>
BYTE_ ZAP( x, y) operator, <A href="#page47">3– 7 <BR>
</A>
<P>
<B>C <BR>
</B>/C opcode qualifier <BR>
IEEE floating-point, <A href="#page123">4– 67 <BR>
</A>
VAX floating-point, <A href="#page123">4– 67 <BR>
</A>
<P>
C opcode qualifier, <A href="#page123">4– 67 <BR>
</A>
Cache coherency <BR>
barrier <A href="#page214">instructions for, </A>
<A href="#page237">5– 25 </A>
defined, <A href="#page214">5– 2 <BR>
</A>
<P>
in multiprocessor environment, 5– 6 <BR>
</A>
Caches <BR>
design considerations, <A href="#page275">A– 1 </A>
I-stream considerations, A– 4 <BR>
</A>
<P>
MB and IMB <A href="#page278">instructions with, 5– 25 </A>
requirements for, <A href="#page217">5– 5 <BR>
</A>
translation buffer conflicts, A– 6 </A>
with powerfail/ recovery, <A href="#page280">5– 5 <BR>
</A>
<P>
CALL_ PAL (call <A href="#page191">privileged architecture library) <BR>
</A>
instruction, 4– 135 <BR>
</A>
<P>
CASE operator, <A href="#page48">3– 8 <BR>
</A>
Causal loops, <A href="#page227">5– 15 <BR>
</A>
CFLUSH (PALcode) <A href="#page194">instruction <BR>
</A>
ECB compared with, 4– 138 
360
<BR>
<A href=#page360>360</A>
<strong><A name=page361> Page 361</A></strong>
<A href=#page362>362</A>
<BR>
<P>
</A>
<B>Index– 3 <BR>
</B>Changed datum, <A href="#page218">5– 6 <BR>
</A>
Clear a register, <A href="#page286">A– 12 <BR>
</A>
CMOVEQ instruction, <A href="#page99">4– 43 <BR>
</A>
CMOVGE instruction, <A href="#page99">4– 43 <BR>
</A>
CMOVGT instruction, <A href="#page99">4– 43 <BR>
</A>
CMOVLBC instruction, <A href="#page99">4– 43 <BR>
</A>
CMOVLE instruction, <A href="#page99">4– 43 <BR>
</A>
CMOVLT instruction, <A href="#page99">4– 43 <BR>
</A>
CMOVNE instruction, <A href="#page99">4– 43 <BR>
</A>
CMPBGE instruction, <A href="#page105">4– 49 <BR>
</A>
CMPEQ instruction, <A href="#page85">4– 29 <BR>
</A>
CMPGLE instruction, <A href="#page168">4– 112 <BR>
</A>
CMPGLT instruction, <A href="#page168">4– 112 <BR>
</A>
CMPLE instruction, <A href="#page85">4– 29 <BR>
</A>
CMPLT instruction, <A href="#page85">4– 29 <BR>
</A>
CMPTEQ instruction, <A href="#page169">4– 113 <BR>
</A>
CMPTLE instruction, <A href="#page169">4– 113 <BR>
</A>
CMPTLT instruction, <A href="#page169">4– 113 <BR>
</A>
CMPTUN instruction, <A href="#page169">4– 113 <BR>
</A>
CMPULE instruction, <A href="#page86">4– 30 <BR>
</A>
CMPULT instruction, <A href="#page86">4– 30 <BR>
</A>
Code forms, <A href="#page287">stylized, </A>
<A href="#page285">A– 11 <BR>
</A>
Boolean, <A href="#page287">A– 13 </A>
load literal, A– 12 <BR>
</A>
<P>
<A href="#page285">negate, </A>
<A href="#page287">A– </A>
<A href="#page286">13 </A>
NOP, <A href="#page287">A– 11 <BR>
</A>
NOT, <A href="#page285">A– 13 </A>
<A href="#page287">register, clear, A– 12 <BR>
</A>
register-to-<A href="#page286">register move, A– 13 <BR>
</A>
Code scheduling <BR>
IMPLVER instruction with, <A href="#page197">4– 141 <BR>
</A>
<P>
Code sequences, <A href="#page283">A– 9 <BR>
</A>
<P>
CODEC, <A href="#page207">4– 151 <BR>
</A>
Coherency <BR>
cache, <A href="#page214">5– 2 memory, 5– 1 <BR>
</A>
<P>
Compare instructions <BR>
compare integer signed, <A href="#page85">4– 29 </A>
<A href="#page158">compare integer </A>
<A href="#page85">unsigned, 4– 30 <BR>
</A>
<P>
<A href="#page158">See also Floating-point </A>
<A href="#page86">operate <BR>
</A>
Conditional move instructions, <A href="#page99">4– 43 <BR>
</A>
<A href="#page158">See also Floating-point </A>
<A href="#page99">operate <BR>
</A>
Console overview, <A href="#page251">7– 1 <BR>
</A>
<P>
Control instructions, <A href="#page74">4– 18 <BR>
</A>
Conventions <BR>
code <A href="#page24">examples, </A>
<A href="#page25">1– 9 </A>
extents, <A href="#page24">1– 8 <BR>
</A>
<P>
figures, 1– 9 </A>
<A href="#page25">instruction format, 3– 10 <BR>
</A>
<P>
notation, <A href="#page50">3– 10 numbering, 1– 7 <BR>
</A>
ranges, <A href="#page24">1– 8 <BR>
</A>
Count instructions <BR>
Count leading <A href="#page88">zero, </A>
<A href="#page87">4– 31 </A>
Count population, 4– 32 <BR>
</A>
<P>
Count trailing <A href="#page88">zero, 4– 33 <BR>
</A>
CPYS instruction, <A href="#page161">4– 105 <BR>
</A>
<P>
CPYSE instruction, <A href="#page161">4– 105 <BR>
</A>
CPYSN instruction, <A href="#page161">4– 105 <BR>
</A>
CSERVE (PALcode) <A href="#page246">instruction <BR>
</A>
required recognition of, 6– 4 <BR>
</A>
cserve (PALcode) <A href="#page246">instruction <BR>
</A>
required recognition of, 6– 4 <BR>
</A>
<P>
CTLZ instruction, <A href="#page87">4– 31 <BR>
</A>
<P>
CTPOP instruction, <A href="#page88">4– 32 <BR>
</A>
CTTZ instruction, <A href="#page89">4– 33 <BR>
</A>
CVTDG instruction, <A href="#page172">4– 116 <BR>
</A>
CVTGD instruction, <A href="#page172">4– 116 <BR>
</A>
CVTGF instruction, <A href="#page172">4– 116 <BR>
</A>
CVTGQ instruction, <A href="#page170">4– 114 <BR>
</A>
CVTLQ instruction, <A href="#page162">4– 106 <BR>
</A>
CVTQF instruction, <A href="#page171">4– 115 <BR>
</A>
CVTQG instruction, <A href="#page171">4– 115 <BR>
</A>
CVTQL instruction, <A href="#page162">4– 106 <BR>
</A>
FP_ C quadword with, B– 5 <BR>
</A>
CVTQS instruction, <A href="#page174">4– 118 <BR>
</A>
<P>
CVTQT instruction, <A href="#page174">4– 118 <BR>
</A>
CVTST instruction, <A href="#page176">4– 120 <BR>
</A>
CVTTQ instruction, <A href="#page173">4– 117 <BR>
</A>
FP_ C quadword with, B– 5 <BR>
</A>
CVTTS instruction, <A href="#page175">4– 119 <BR>
</A>
<P>
<B>D <BR>
</B>/D opcode qualifier <BR>
FPCR (floating-point <A href="#page123">control register), </A>
<A href="#page135">4– 79 </A>
IEEE floating-point, <A href="#page123">4– 67 <BR>
</A>
<P>
D_ floating data <A href="#page32">type, </A>
<A href="#page31">2– 5 <BR>
</A>
alignment <A href="#page32">of, </A>
<A href="#page32">2– </A>
<A href="#page31">6 </A>
mapping, <A href="#page32">2– </A>
<A href="#page32">6 <BR>
</A>
<P>
restricted, <A href="#page32">2– 6 <BR>
</A>
Data alignment, <A href="#page278">A– 4 <BR>
</A>
<P>
Data caches <BR>
ECB instruction with, <A href="#page194">4– 136 </A>
WH64 instruction <A href="#page192">with, 4– 145 <BR>
</A>
<P>
Data format, overview, <A href="#page19">1– 3 <BR>
</A>
Data sharing (multiprocessor), <A href="#page279">A– 5 <BR>
</A>
synchonization requirement, 5– 6 
361
<BR>
<A href=#page361>361</A>
<strong><A name=page362> Page 362</A></strong>
<A href=#page363>363</A>
<BR>
<P>
</A>
<B>Index– 4 <BR>
</B>Data stream considerations, <A href="#page278">A– 4 <BR>
</A>
Data structures, shared, <A href="#page218">5– 6 <BR>
</A>
Data types <BR>
byte, <A href="#page27">2– 1 </A>
IEEE floating-point, 2– 6 <BR>
</A>
<P>
longword, <A href="#page28">2– 2 </A>
longword integer, 2– 11 <BR>
</A>
quadword, <A href="#page28">2– 2 </A>
quadword integer, 2– 12 <BR>
</A>
unsupported in <A href="#page38">hardware, 2– 12 </A>
VAX <A href="#page27">floating-point, </A>
<A href="#page29">2– 3 <BR>
</A>
word, <A href="#page27">2– 1 <BR>
</A>
Denormal, <A href="#page120">4– 64 <BR>
</A>
<P>
Denormal operand exception disable, <A href="#page137">4– 81 <BR>
</A>
Denormal operand <A href="#page295">exception enable (DNOE) <BR>
</A>
FP_ C quadword bit, B– 5 <BR>
</A>
Denormal operand status <A href="#page295">(DNOS) <BR>
</A>
FP_ C quadword bit, B– 5 <BR>
</A>
Denormal operands to zero, <A href="#page137">4– 81 <BR>
</A>
<P>
Depends order (DP), <A href="#page227">5– 15 <BR>
</A>
DIGITAL <A href="#page318">UNIX PALcode, instruction summary, <BR>
C– 16 <BR>
</A>
<P>
Dirty zero, <A href="#page120">4– 64 <BR>
</A>
DIV operator, <A href="#page48">3– 8 <BR>
</A>
DIVF instruction, <A href="#page177">4– 121 <BR>
</A>
DIVG instruction, <A href="#page177">4– 121 <BR>
</A>
Division <BR>
integer, <A href="#page284">A– 10 performance impact of, A– 10 <BR>
</A>
<P>
Division by zero enable <A href="#page296">(DZEE) <BR>
</A>
FP_ C quadword bit, B– 6 <BR>
</A>
<P>
Division by zero status <A href="#page295">(DZES) <BR>
</A>
FP_ C quadword bit, B– 5 <BR>
</A>
DIVS instruction, <A href="#page178">4– 122 <BR>
</A>
<P>
DIVT instruction, <A href="#page178">4– 122 <BR>
</A>
<A href="#page137">DNOD bit. See Denormal operand exception disable <BR>
</A>
<A href="#page137">DNZ. See Denormal operands to zero <BR>
</A>
<A href="#page227">DP. See Depends order <BR>
</A>
DRAINA <A href="#page247">(PALcode) instruction <BR>
</A>
required, 6– 5 <BR>
</A>
draina <A href="#page247">(PALcode) instruction <BR>
</A>
required, 6– 5 <BR>
</A>
<P>
<A href="#page136">DYN bit. See Arithmetic traps, dynamic rounding <BR>
mode <BR>
</A>
<P>
DZE bit <BR>
<A href="#page133">See also Arithmetic traps, division by zero <BR>
</A>
<P>
<A href="#page137">DZED bit. See Trap disable bits, division by zero <BR>
</A>
<B>E <BR>
</B>ECB (Evict data cache block) instruction, <A href="#page192">4– 136 <BR>
</A>
CFLUSH (PALcode) instruction with, 4– 138 <BR>
</A>
EQV instruction, <A href="#page98">4– 42 <BR>
</A>
<P>
EXCB <A href="#page140">(exception barrier) instruction, </A>
<A href="#page194">4– 138 <BR>
</A>
with FPCR, <A href="#page140">4– 84 <BR>
</A>
Exception handlers, <A href="#page293">B– 3 <BR>
</A>
TRAPB instruction with, 4– 144 <BR>
</A>
Exceptions <BR>
F31 with, <A href="#page42">3– 2 </A>
R31 with, 3– 1 <BR>
</A>
<P>
EXTBL instruction, <A href="#page107">4– 51 <BR>
</A>
EXTLH instruction, <A href="#page107">4– 51 <BR>
</A>
EXTLL instruction, <A href="#page107">4– 51 <BR>
</A>
EXTQH instruction, <A href="#page107">4– 51 <BR>
</A>
EXTQL instruction, <A href="#page107">4– 51 <BR>
</A>
Extract byte instructions, <A href="#page107">4– 51 <BR>
</A>
EXTWH instruction, <A href="#page107">4– 51 <BR>
</A>
EXTWL instruction, <A href="#page107">4– 51 <BR>
</A>
<P>
<B>F <BR>
</B>F_ floating data <A href="#page30">type, </A>
<A href="#page29">2– 3 <BR>
</A>
alignment of, 2– 4 </A>
compared to <A href="#page30">IEEE S_floating, 2– 8 <BR>
</A>
<P>
MAX/ MIN, <A href="#page121">4– 65 <BR>
</A>
FBEQ instruction, <A href="#page156">4– 100 <BR>
</A>
<P>
FBGE instruction, <A href="#page156">4– 100 <BR>
</A>
FBGT instruction, <A href="#page156">4– 100 <BR>
</A>
FBLE instruction, <A href="#page156">4– 100 <BR>
</A>
FBLT instruction, <A href="#page156">4– 100 <BR>
</A>
FBNE instruction, <A href="#page156">4– 100 <BR>
</A>
FCMOVEQ instruction, <A href="#page163">4– 107 <BR>
</A>
FCMOVGE instruction, <A href="#page163">4– 107 <BR>
</A>
FCMOVGT instruction, <A href="#page163">4– 107 <BR>
</A>
FCMOVLE instruction, <A href="#page163">4– 107 <BR>
</A>
FCMOVLT instruction, <A href="#page163">4– 107 <BR>
</A>
FCMOVNE instruction, <A href="#page163">4– 107 <BR>
</A>
FETCH (prefetch data) instruction, <A href="#page195">4– 139 <BR>
</A>
FETCH_ <A href="#page195">M (prefetch data, modify intent) instruction, <BR>
4– 139 <BR>
</A>
<P>
Finite number, Alpha, contrasted with VAX, <A href="#page119">4– 63 <BR>
</A>
Floating-point branch instructions, <A href="#page155">4– 99 <BR>
</A>
Floating-point <A href="#page138">control register </A>
<A href="#page218">(FPCR) <BR>
</A>
accessing, <A href="#page138">4– 82 
362
<BR>
<A href=#page362>362</A>
<strong><A name=page363> Page 363</A></strong>
<A href=#page364>364</A>
<BR>
<P>
</A>
<B>Index– 5 <BR>
</B>at processor <A href="#page136">initialization, </A>
<A href="#page139">4– 83 </A>
bit descriptions, <A href="#page136">4– 80 <BR>
</A>
instructions to read/ write, 4– 109 </A>
operate instructions <A href="#page139">that </A>
<A href="#page165">use, 4– 102 <BR>
</A>
saving and <A href="#page134">restoring, </A>
<A href="#page139">4– 83 </A>
trap disable bits in, 4– 78 <BR>
</A>
<P>
Floating-point convert <A href="#page54">instructions, </A>
<A href="#page54">3– 14 <BR>
</A>
Fa field requirements, <A href="#page54">3– 14 <BR>
</A>
Floating-<A href="#page284">point division, performance impact of, <BR>
A– 10 <BR>
</A>
<P>
Floating-point format, <A href="#page121">number representation <BR>
</A>
(encodings), 4– 65 <BR>
</A>
<P>
Floating-<A href="#page155">point instructions <BR>
</A>
<A href="#page118">branch, </A>
<A href="#page155">4– 99 </A>
faults, 4– 62 <BR>
</A>
<P>
<A href="#page118">function field format, 4– 84 </A>
introduced, <A href="#page118">4– 62 <BR>
</A>
memory format, 4– 90 </A>
opcodes <A href="#page158">and </A>
<A href="#page146">format summarized, C– 1 <BR>
</A>
operate, <A href="#page158">4– 102 </A>
rounding modes, 4– 66 <BR>
</A>
terminology, <A href="#page119">4– </A>
<A href="#page122">63 </A>
<A href="#page118">trapping </A>
<A href="#page119">modes, 4– 69 <BR>
</A>
traps, <A href="#page118">4– 62 <BR>
</A>
Floating-point load <A href="#page147">instructions, </A>
<A href="#page146">4– 90 <BR>
</A>
load F_ floating, <A href="#page147">4– 91 </A>
load G_ floating, 4– 92 <BR>
</A>
<P>
load S_ floating, <A href="#page148">4– 93 </A>
load T_ floating, <A href="#page149">4– 94 <BR>
</A>
with non-finite <A href="#page150">values, 4– 90 <BR>
</A>
Floating-point <A href="#page167">operate instructions, </A>
<A href="#page158">4– 102 <BR>
</A>
add (IEEE), <A href="#page167">4– 111 </A>
add (VAX), 4– 110 <BR>
</A>
<P>
compare <A href="#page166">(IEEE), 4– 113 </A>
compare (VAX), <A href="#page169">4– 112 <BR>
</A>
conditional move, <A href="#page168">4– 107 </A>
convert IEEE <A href="#page163">floating to integer, 4– 117 <BR>
</A>
convert integer to IEEE <A href="#page162">floating, </A>
<A href="#page173">4– 118 </A>
convert integer to integer, <A href="#page162">4– </A>
<A href="#page174">106 <BR>
</A>
convert integer to VAX <A href="#page162">floating, 4– 115 </A>
convert S_ floating to T_ floating, <A href="#page171">4– 119 <BR>
</A>
convert T_ floating to S_ floating, <A href="#page175">4– 120 </A>
convert VAX floating to integer, <A href="#page176">4– 114 <BR>
</A>
convert <A href="#page161">VAX floating to VAX </A>
<A href="#page170">floating, 4– 116 </A>
copy sign, <A href="#page161">4– 105 <BR>
</A>
divide (IEEE), 4– 122 </A>
divide <A href="#page53">(VAX), </A>
<A href="#page178">4– 121 <BR>
</A>
format of, <A href="#page53">3– </A>
<A href="#page177">13 </A>
from <A href="#page53">integer moves, 4– 124 <BR>
</A>
move from/ to <A href="#page183">FPCR, </A>
<A href="#page180">4– 109 </A>
multiply (IEEE), <A href="#page183">4– </A>
<A href="#page165">127 <BR>
</A>
multiply (VAX), <A href="#page183">4– 126 </A>
subtract (IEEE), <A href="#page182">4– 131 <BR>
</A>
subtract (VAX), <A href="#page187">4– 130 </A>
to integer moves, <A href="#page186">4– 123 <BR>
</A>
unused function <A href="#page179">codes with, 3– 14 <BR>
</A>
<P>
Floating-point registers, <A href="#page42">3– 2 <BR>
</A>
Floating-point single-precision operations, <A href="#page118">4– 62 <BR>
</A>
Floating-point store <A href="#page151">instructions, </A>
<A href="#page146">4– 90 <BR>
</A>
store F_ floating, <A href="#page151">4– 95 </A>
store G_ floating, 4– 96 <BR>
</A>
<P>
store S_ floating, <A href="#page152">4– 97 </A>
store T_ floating, <A href="#page153">4– 98 <BR>
</A>
with non-finite <A href="#page154">values, 4– 90 <BR>
</A>
Floating-point support <BR>
<A href="#page32">floating-point control (FP_C) quadword, </A>
<A href="#page294">B– 4 </A>
IEEE, <A href="#page32">2– 6 <BR>
</A>
<P>
IEEE standard 754-1985, 4– 88 </A>
instruction <A href="#page37">overview, </A>
<A href="#page118">4– </A>
<A href="#page144">62 <BR>
</A>
longword integer, <A href="#page37">2– </A>
<A href="#page118">11 </A>
operate <A href="#page37">instructions, 4– 102 <BR>
</A>
optional, <A href="#page58">4– 2 </A>
quadword integer, 2– 12 <BR>
</A>
rounding modes, <A href="#page38">4– 66 </A>
single-<A href="#page125">precision </A>
<A href="#page122">operations, 4– 62 <BR>
</A>
trap <A href="#page29">modes, </A>
<A href="#page125">4– 69 </A>
VAX, <A href="#page29">2– 3 <BR>
</A>
<P>
Floating-point to integer move, <A href="#page179">4– 123 <BR>
</A>
Floating-point to integer move instructions, <A href="#page54">3– 14 <BR>
</A>
Floating-point trapping modes, <A href="#page125">4– 69 <BR>
</A>
<A href="#page130">See also Arithmetic traps <BR>
</A>
FNOP code form, <A href="#page285">A– 11 <BR>
</A>
<P>
FP_ C quadword, <A href="#page294">B– 4 <BR>
</A>
<A href="#page136">FPCR. See Floating-point control register <BR>
</A>
FTOIS instruction, <A href="#page179">4– 123 <BR>
</A>
FTOIT instruction, <A href="#page179">4– 123 <BR>
</A>
Function codes <BR>
IEEE floating-<A href="#page312">point, </A>
<A href="#page308">C– 6 </A>
in numerical order, C– 10 <BR>
</A>
<P>
independent <A href="#page312">floating-point, C– 8 </A>
<A href="#page312">VAX floating-point, </A>
<A href="#page309">C– 7 <BR>
</A>
<A href="#page312">See also Opcodes <BR>
</A>
<P>
<B>G <BR>
</B>G_ floating data <A href="#page31">type, </A>
<A href="#page30">2– 4 <BR>
</A>
alignment <A href="#page31">of, </A>
<A href="#page31">2– </A>
<A href="#page30">5 </A>
mapping, <A href="#page31">2– </A>
<A href="#page31">5 <BR>
</A>
<P>
MAX/ <A href="#page31">MIN, 4– 65 <BR>
</A>
GENTRAP (PALcode) <A href="#page246">instruction <BR>
</A>
required recognition of, 6– 4 <BR>
</A>
<P>
gentrap (PALcode) <A href="#page246">instruction <BR>
</A>
required recognition of, 6– 4 <BR>
</A>
<P>
<B>H <BR>
</B>HALT <A href="#page249">(PALcode) instruction <BR>
</A>
required, 6– 7 <BR>
</A>
halt <A href="#page249">(PALcode) instruction <BR>
</A>
required, 6– 7 
363
<BR>
<A href=#page363>363</A>
<strong><A name=page364> Page 364</A></strong>
<A href=#page365>365</A>
<BR>
<P>
</A>
<B>Index– 6 <BR>
I <BR>
</B>I/ O devices, DMA <BR>
MB and WMB with, <A href="#page234">5– 22 </A>
reliably communicating with processor, 5– 27 <BR>
</A>
<P>
shared memory locations with, <A href="#page223">5– 11 <BR>
</A>
I/ O interface overview, <A href="#page253">8– 1 <BR>
</A>
<P>
IEEE floating-point <BR>
exception handlers, <A href="#page293">B– 3 </A>
floating-<A href="#page32">point </A>
<A href="#page293">control (FP_C) quadword, B– 4 <BR>
</A>
<P>
format, <A href="#page32">2– 6 </A>
FPCR (floating-point control register), 4– 79 <BR>
</A>
function field <A href="#page292">format, </A>
<A href="#page141">4– 85 </A>
<A href="#page32">hardware support, </A>
<A href="#page141">B– 2 <BR>
</A>
NaN, <A href="#page32">2– 6 options, B– 1 <BR>
</A>
S_ <A href="#page291">floating, 2– 7 </A>
standard <A href="#page33">charts, B– 12 <BR>
</A>
standard, <A href="#page302">mapping to, B– 6 </A>
T_ floating, <A href="#page34">2– 8 <BR>
</A>
trap handling, B– 6 </A>
<A href="#page32">X_floating, </A>
<A href="#page296">2– 9 <BR>
</A>
<A href="#page32">See also </A>
<A href="#page35">Floating-point instructions <BR>
</A>
IEEE floating-point control word, <A href="#page294">B– 4 <BR>
</A>
<P>
IEEE floating-point <A href="#page167">instructions <BR>
</A>
add instructions, 4– 111 </A>
compare instructions, 4– 113 <BR>
</A>
<P>
convert from integer <A href="#page169">instructions, 4– 118 </A>
convert S_ floating to T_ floating, <A href="#page174">4– 119 <BR>
</A>
convert T_ floating to S_ <A href="#page173">floating, </A>
<A href="#page175">4– 120 </A>
convert to integer <A href="#page178">instructions, </A>
<A href="#page176">4– 117 <BR>
</A>
divide instructions, <A href="#page178">4– 122 </A>
from integer moves, 4– 124 <BR>
</A>
function codes for, <A href="#page180">C– 6 </A>
multiply <A href="#page308">instructions, 4– 127 <BR>
</A>
operate instructions, <A href="#page183">4– 102 </A>
square root <A href="#page158">instructions, 4– 129 <BR>
</A>
subtract <A href="#page179">instructions, </A>
<A href="#page187">4– </A>
<A href="#page185">131 </A>
to register moves, <A href="#page179">4– </A>
<A href="#page187">123 <BR>
</A>
<P>
IEEE standard, <A href="#page144">4– 88 <BR>
conformance to, B– 1 </A>
mapping to, <A href="#page296">B– </A>
<A href="#page291">6 <BR>
</A>
<P>
IGN (ignore), <A href="#page25">1– 9 <BR>
</A>
IMB <A href="#page250">(PALcode) instruction, </A>
<A href="#page235">5– 23 <BR>
</A>
required, <A href="#page250">6– 8 </A>
virtual I-cache coherency, 5– 5 <BR>
</A>
<P>
imb <A href="#page250">(PALcode) instruction <BR>
</A>
required, 6– 8 <BR>
</A>
IMP (implementation dependent), <A href="#page25">1– 9 <BR>
</A>
<P>
<A href="#page197">IMPLVER (Implementation version) instruction, <BR>
4– 141 <BR>
</A>
<P>
IMPLVER value assignments, <A href="#page327">D– 3 <BR>
</A>
Independent floating-point function <A href="#page310">codes, C– 8 <BR>
</A>
INE bit <BR>
<A href="#page134">See also Arithmetic traps, inexact result <BR>
</A>
<P>
<A href="#page136">INED bit. See Trap disable bits, inexact result trap <BR>
</A>
Inexact result enable <A href="#page296">(INEE) <BR>
</A>
FP_ C quadword bit, B– 6 <BR>
</A>
Inexact result status <A href="#page295">(INES) <BR>
</A>
FP_ C quadword bit, B– 5 <BR>
</A>
Infinity, <A href="#page120">4– 64 <BR>
conversion to integer, 4– 88 <BR>
</A>
INSBL instruction, <A href="#page111">4– 55 <BR>
</A>
<P>
Insert byte instructions, <A href="#page111">4– 55 <BR>
</A>
INSLH instruction, <A href="#page111">4– 55 <BR>
</A>
INSLL instruction, <A href="#page111">4– 55 <BR>
</A>
INSQH instruction, <A href="#page111">4– 55 <BR>
</A>
INSQL instruction, <A href="#page111">4– 55 <BR>
</A>
Instruction encodings <BR>
common <A href="#page312">architecture, </A>
<A href="#page303">C– 1 </A>
numerical order, <A href="#page312">C– </A>
<A href="#page303">10 <BR>
</A>
<P>
opcodes and <A href="#page312">format summarized, C– 1 <BR>
</A>
Instruction fetches (memory), <A href="#page223">5– 11 <BR>
</A>
<P>
Instruction <A href="#page52">formats <BR>
</A>
branch, 3– 12 conventions, 3– 10 <BR>
</A>
<P>
floating-point <A href="#page50">convert, 3– 14 </A>
floating-point operate, <A href="#page54">3– 13 <BR>
</A>
floating-<A href="#page51">point to </A>
<A href="#page53">integer move, 3– 14 </A>
memory, <A href="#page51">3– 11 <BR>
</A>
memory jump, 3– 12 </A>
operand <A href="#page52">values, 3– 10 <BR>
</A>
operators, <A href="#page46">3– 6 </A>
overview, 1– 4 <BR>
</A>
PALcode, <A href="#page20">3– 14 </A>
registers, <A href="#page54">3– 1 <BR>
</A>
<P>
Instruction set <BR>
access <A href="#page97">type field, </A>
<A href="#page45">3– 5 </A>
<A href="#page74">Boolean, </A>
<A href="#page97">4– 41 <BR>
</A>
<P>
branch, 4– 18 </A>
byte <A href="#page74">manipulate, 4– 47 <BR>
</A>
conditional <A href="#page46">move </A>
<A href="#page103">(integer), 4– 43 </A>
data type field, <A href="#page46">3– 6 <BR>
</A>
floating-point subsetting, 4– 2 </A>
integer <A href="#page22">arithmetic, </A>
<A href="#page80">4– 24 <BR>
</A>
<A href="#page74">introduced, </A>
<A href="#page22">1– 6 </A>
jump, <A href="#page74">4– 18 <BR>
</A>
load memory integer, 4– 4 </A>
<A href="#page207">miscellaneous, </A>
<A href="#page188">4– </A>
<A href="#page60">132 <BR>
</A>
multimedia, <A href="#page188">4– 151 </A>
name field, <A href="#page207">3– 5 <BR>
</A>
opcode <A href="#page45">qualifiers, 4– 3 </A>
operand <A href="#page57">notation, </A>
<A href="#page59">3– 5 <BR>
</A>
overview, <A href="#page57">4– 1 </A>
shift, arithmetic, 4– 46 <BR>
</A>
software <A href="#page102">emulation rules, 4– 3 </A>
store memory <A href="#page205">integer, </A>
<A href="#page60">4– </A>
<A href="#page59">4 <BR>
</A>
<A href="#page158">VAX compatibility, </A>
<A href="#page60">4– 149 </A>
<A href="#page158">See also Floating-</A>
<A href="#page205">point instructions 
364
<BR>
<A href=#page364>364</A>
<strong><A name=page365> Page 365</A></strong>
<A href=#page366>366</A>
<BR>
<P>
</A>
<B>Index– 7 <BR>
<A href="#page278">Instruction stream. See I-stream <BR>
</A>
Instructions, overview, <A href="#page20">1– 4 <BR>
</A>
INSWH instruction, <A href="#page111">4– 55 <BR>
</A>
INSWL instruction, <A href="#page111">4– 55 <BR>
</A>
Integer division, <A href="#page284">A– 10 <BR>
</A>
Integer <A href="#page41">registers <BR>
</A>
defined, 3– 1 </A>
R31 restrictions, 3– 1 <BR>
</A>
<P>
INV bit <BR>
<A href="#page132">See also Arithmetic traps, invalid operation <BR>
</A>
Invalid operation enable <A href="#page296">(INVE) <BR>
</A>
FP_ C quadword bit, B– 6 <BR>
</A>
Invalid operation status <A href="#page295">(INVS) <BR>
</A>
FP_ C quadword bit, B– 5 <BR>
</A>
<P>
<A href="#page137">INVD bit. See Trap disable bits, invalid operation <BR>
</A>
<P>
IOV bit <BR>
<A href="#page134">See also Arithmetic traps, integer overflow <BR>
</A>
I-stream <BR>
coherency of, <A href="#page250">6– 8 </A>
design considerations, A– 2 <BR>
</A>
<P>
modifying <A href="#page217">physical, </A>
<A href="#page276">5– 5 </A>
modifying <A href="#page244">virtual, </A>
<A href="#page217">5– 5 <BR>
</A>
PALcode <A href="#page217">with, </A>
<A href="#page217">6– 2 </A>
with caches, <A href="#page244">5– 5 <BR>
</A>
<P>
ITOFF instruction, <A href="#page180">4– 124 <BR>
</A>
ITOFS instruction, <A href="#page180">4– 124 <BR>
</A>
ITOFT instruction, <A href="#page180">4– 124 <BR>
</A>
<P>
<B>J <BR>
</B>JMP instruction, <A href="#page78">4– 22 <BR>
</A>
JSR instruction, <A href="#page78">4– 22 <BR>
</A>
JSR_ COROUTINE instruction, <A href="#page78">4– 22 <BR>
</A>
Jump instructions, <A href="#page74">4– 18, </A>
<A href="#page78">4– 22 <BR>
</A>
branch <A href="#page74">prediction logic, </A>
<A href="#page78">4– 22 </A>
coroutine linkage, <A href="#page79">4– 23 <BR>
</A>
<P>
return from subroutine, 4– 22 </A>
<A href="#page74">unconditional long </A>
<A href="#page78">jump, 4– 23 <BR>
</A>
<A href="#page74">See also Control </A>
<A href="#page79">instructions <BR>
</A>
<P>
<B>L <BR>
</B>LDA instruction, <A href="#page61">4– 5 <BR>
</A>
LDAH instruction, <A href="#page61">4– 5 <BR>
</A>
LDBU instruction, <A href="#page62">4– 6 <BR>
</A>
LDF instruction, <A href="#page147">4– 91 <BR>
</A>
LDG instruction, <A href="#page148">4– 92 <BR>
</A>
LDL instruction, <A href="#page62">4– 6 <BR>
</A>
LDL_ L <A href="#page66">instruction, </A>
<A href="#page65">4– 9 <BR>
</A>
restrictions, <A href="#page66">4– </A>
<A href="#page65">10 </A>
with <A href="#page66">processor lock register/ flag, 4– 10 <BR>
</A>
<P>
with STx_ C instruction, <A href="#page65">4– 9 <BR>
</A>
LDQ instruction, <A href="#page62">4– 6 <BR>
</A>
<P>
LDQ_ L <A href="#page66">instruction, </A>
<A href="#page65">4– 9 <BR>
</A>
restrictions, <A href="#page66">4– </A>
<A href="#page65">10 </A>
with <A href="#page66">processor lock register/ flag, 4– 10 <BR>
</A>
<P>
with STx_ C instruction, <A href="#page66">4– 10 <BR>
</A>
LDQ_ U instruction, <A href="#page64">4– 8 <BR>
</A>
<P>
LDS instruction, <A href="#page149">4– 93 <BR>
</A>
with FPCR, 4– 84 <BR>
</A>
<P>
LDT instruction, <A href="#page150">4– 94 <BR>
</A>
<P>
LDWU instruction, <A href="#page62">4– 6 <BR>
</A>
LEFT_ SHIFT( x, y) operator, <A href="#page48">3– 8 <BR>
</A>
lg operator, <A href="#page48">3– 8 <BR>
</A>
Literals, operand notation, <A href="#page45">3– 5 <BR>
</A>
Litmus tests, shared data veracity, <A href="#page229">5– 17 <BR>
</A>
Load instructions <BR>
emulation of, <A href="#page59">4– 3 </A>
FETCH instruction, 4– 139 <BR>
</A>
<P>
Load address, <A href="#page61">4– 5 </A>
Load <A href="#page62">address </A>
<A href="#page61">high, 4– 5 <BR>
</A>
load byte, <A href="#page62">4– 6 </A>
load longword, 4– 6 <BR>
</A>
load quadword, <A href="#page62">4– 6 </A>
load quadword <A href="#page62">locked, 4– 10 <BR>
</A>
load sign-extended <A href="#page66">longword locked, 4– 9 </A>
load <A href="#page62">unaligned quadword, </A>
<A href="#page64">4– 8 <BR>
</A>
load word, <A href="#page62">4– 6 multiprocessor environment, 5– 6 <BR>
</A>
<A href="#page146">serialization, </A>
<A href="#page198">4– 142 </A>
<A href="#page146">See also </A>
<A href="#page198">Floating-point load instructions <BR>
</A>
<P>
Load literal, <A href="#page286">A– 12 <BR>
</A>
Load memory integer instructions, <A href="#page60">4– 4 <BR>
</A>
LOAD_ LOCKED operator, <A href="#page48">3– 8 <BR>
</A>
Load-locked, defined, <A href="#page228">5– 16 <BR>
</A>
Location, <A href="#page223">5– 11 <BR>
</A>
Location access constraints, <A href="#page226">5– 14 <BR>
</A>
Lock flag, <A href="#page42">per-processor <BR>
</A>
defined, 3– 2 </A>
when cleared, 4– 10 <BR>
</A>
<P>
with load <A href="#page66">locked instructions, 4– 10 <BR>
</A>
Lock <A href="#page42">registers, per-processor <BR>
</A>
defined, 3– 2 </A>
with load locked instructions, 4– 10 <BR>
</A>
<P>
Lock variables, with WMB instruction, <A href="#page204">4– 148 <BR>
</A>
<A href="#page97">Logical instructions. See Boolean instructions <BR>
</A>
Longword data <A href="#page38">type, </A>
<A href="#page28">2– 2 <BR>
</A>
alignment of, 2– 12 </A>
atomic access <A href="#page38">of, 5– 2 <BR>
</A>
<P>
<A href="#page158">LSB (least significant bit), defined for floating-point, 
365
<BR>
<A href=#page365>365</A>
<strong><A name=page366> Page 366</A></strong>
<A href=#page367>367</A>
<BR>
<P>
</A>
<B>Index– 8 <BR>
<A href="#page120">4– 64 <BR>
</A>
<B>M <BR>
</B>/M opcode qualifier, IEEE floating-point, <A href="#page123">4– 67 <BR>
</A>
MAP_ F function, <A href="#page30">2– 4 <BR>
</A>
MAP_ S function, <A href="#page33">2– 7 <BR>
</A>
MAP_ x operator, <A href="#page48">3– 8 <BR>
</A>
Mask byte instructions, <A href="#page113">4– 57 <BR>
</A>
MAX, defined for floating-point, <A href="#page121">4– 65 <BR>
</A>
MAXS( x, y) operator, <A href="#page48">3– 8 <BR>
</A>
MAXSB8 instruction, <A href="#page208">4– 152 <BR>
</A>
MAXSW4 instruction, <A href="#page208">4– 152 <BR>
</A>
MAXU( x, y) operator, <A href="#page48">3– 8 <BR>
</A>
MAXUB8 instruction, <A href="#page208">4– 152 <BR>
</A>
MAXUW4 instruction, <A href="#page208">4– 152 <BR>
</A>
MB (Memory barrier) <A href="#page204">instruction, </A>
<A href="#page198">4– 142 <BR>
</A>
compared with <A href="#page198">WMB, </A>
<A href="#page204">4– </A>
<A href="#page198">148 </A>
multiprocessors <A href="#page234">only, </A>
<A href="#page204">4– 142 <BR>
</A>
<P>
with DMA I/ O, <A href="#page234">5– 22 </A>
with LDx_ L/ STx_C, 4– 14 <BR>
</A>
with multiprocessor <A href="#page70">D-stream, 5– 22 </A>
<A href="#page198">with shared data structures, </A>
<A href="#page234">5– 9 <BR>
</A>
<A href="#page198">See also IMB, WMB <BR>
</A>
MBZ (must be zero), <A href="#page25">1– 9 <BR>
</A>
<P>
Memory access <BR>
aligned byte/ <A href="#page213">word, </A>
<A href="#page283">A– 9 </A>
coherency of, <A href="#page213">5– 1 <BR>
</A>
<P>
<A href="#page215">granularity of, </A>
<A href="#page213">5– 2 </A>
width of, <A href="#page215">5– 3 <BR>
</A>
with WMB instruction, 4– 147 <BR>
</A>
Memory alignment, requirement for, <A href="#page214">5– 2 <BR>
</A>
<P>
<A href="#page70">Memory barrier instructions. See MB, IMB <BR>
(PALcode), and WMB instructions <BR>
</A>
<P>
Memory barriers, <A href="#page234">5– 22 <BR>
</A>
Memory format instructions <BR>
opcodes and format summarized, <A href="#page303">C– 1 <BR>
</A>
Memory instruction format, <A href="#page51">3– 11 <BR>
</A>
<P>
Memory jump instruction format, <A href="#page52">3– 12 <BR>
</A>
Memory management <BR>
support in PALcode, <A href="#page244">6– 2 <BR>
</A>
Memory <A href="#page43">prefetch registers <BR>
</A>
defined, 3– 3 <BR>
</A>
<P>
Memory-like behavior, <A href="#page215">5– 3 <BR>
</A>
MF_ FPCR instruction, <A href="#page165">4– 109 <BR>
</A>
MIN, defined for floating-point, <A href="#page121">4– 65 <BR>
</A>
MINS( x, y) operator, <A href="#page48">3– 8 <BR>
</A>
MINSB8 instruction, <A href="#page208">4– 152 <BR>
</A>
MINSW4 instruction, <A href="#page208">4– 152 <BR>
</A>
MINU( x, y) operator, <A href="#page48">3– 8 <BR>
</A>
MINUB8 instruction, <A href="#page208">4– 152 <BR>
</A>
MINUW4 instruction, <A href="#page208">4– 152 <BR>
</A>
Miscellaneous instructions, <A href="#page188">4– 132 <BR>
</A>
<A href="#page99">Move instructions (conditional). See Conditional <BR>
move instructions <BR>
</A>
<P>
Move, register-to-register, <A href="#page287">A– 13 <BR>
</A>
MSKBL instruction, <A href="#page113">4– 57 <BR>
</A>
MSKLH instruction, <A href="#page113">4– 57 <BR>
</A>
MSKLL instruction, <A href="#page113">4– 57 <BR>
</A>
MSKQL instruction, <A href="#page113">4– 57 <BR>
</A>
MSKWH instruction, <A href="#page113">4– 57 <BR>
</A>
MSKWL instruction, <A href="#page113">4– 57 <BR>
</A>
MT_ FPCR instruction, <A href="#page165">4– 109 <BR>
</A>
synchronization requirement, 4– 82 <BR>
</A>
MULF instruction, <A href="#page182">4– 126 <BR>
</A>
<P>
MULG instruction, <A href="#page182">4– 126 <BR>
</A>
MULL <A href="#page90">instruction, </A>
<A href="#page90">4– 34 <BR>
</A>
with MULQ, 4– 34 <BR>
</A>
<P>
MULQ <A href="#page90">instruction, </A>
<A href="#page91">4– 35 <BR>
</A>
with MULL, 4– 34 </A>
with <A href="#page90">UMULH, 4– 35 <BR>
</A>
<P>
MULS instruction, <A href="#page183">4– 127 <BR>
</A>
MULT instruction, <A href="#page183">4– 127 <BR>
</A>
Multimedia instructions, <A href="#page207">4– 151 <BR>
</A>
Multiply instructions <BR>
multiply longword, <A href="#page90">4– 34 </A>
multiply quadword, 4– 35 <BR>
</A>
<P>
<A href="#page158">multiply unsigned </A>
<A href="#page91">quadward high, 4– 36 </A>
<A href="#page158">See also Floating-point operate <BR>
</A>
<P>
Multiprocessor <A href="#page218">environment <BR>
</A>
cache coherency <A href="#page236">in, </A>
<A href="#page218">5– 6 </A>
context switching, 5– 24 <BR>
</A>
<P>
I-stream <A href="#page236">reliability, 5– 23 </A>
MB and WMB <A href="#page235">with, 5– 22 <BR>
</A>
no implied barriers, <A href="#page234">5– 22 </A>
read/ write ordering, <A href="#page234">5– 10 <BR>
</A>
serialization <A href="#page222">requirements in, 4– 142 </A>
shared data, <A href="#page218">5– 6, </A>
<A href="#page279">A– 5 
366
<BR>
<A href=#page366>366</A>
<strong><A name=page367> Page 367</A></strong>
<A href=#page368>368</A>
<BR>
<P>
</A>
<B>Index– 9 <BR>
N <BR>
</B>NaN (Not-a-Number) <BR>
conversion to integer, <A href="#page144">4– 88 </A>
copying, <A href="#page32">generating, </A>
<A href="#page144">propograting, 4– 89 <BR>
</A>
<P>
<A href="#page120">defined, </A>
<A href="#page32">2– 6 </A>
quiet, 4– 64 <BR>
</A>
<A href="#page120">signaling, 4– 64 <BR>
</A>
NATURALLY ALIGNED data objects, <A href="#page24">1– 8 <BR>
</A>
<P>
Negate stylized code form, <A href="#page287">A– 13 <BR>
</A>
Non-finite number, <A href="#page120">4– 64 <BR>
</A>
Nonmemory-like behavior, <A href="#page215">5– 3 <BR>
</A>
NOP, universal (UNOP), <A href="#page285">A– 11 <BR>
</A>
NOT instruction, ORNOT with zero, <A href="#page98">4– 42 <BR>
</A>
NOT operator, <A href="#page49">3– 9 <BR>
</A>
NOT stylized code form, <A href="#page287">A– 13 <BR>
</A>
<P>
<B>O <BR>
</B>Opcode qualifiers <BR>
default <A href="#page59">values, </A>
<A href="#page59">4– 3 </A>
<A href="#page59">notation, </A>
<A href="#page59">4– 3 <BR>
</A>
<P>
<A href="#page59">See also </A>
<A href="#page59">specific qualifiers <BR>
</A>
Opcodes <BR>
common architecture, <A href="#page303">C– 1 </A>
DIGITAL UNIX PALcode, C– 16 <BR>
</A>
<P>
in numerical order, <A href="#page312">C– 10 </A>
OpenVMS Alpha PALcode, C– 14 <BR>
</A>
PALcode <A href="#page323">in numerical </A>
<A href="#page316">order, C– 18 </A>
reserved, <A href="#page323">C– 21 <BR>
</A>
summary, C– 8 </A>
unused <A href="#page310">function codes for, C– 21 <BR>
</A>
<A href="#page308">Windows NT Alpha </A>
<A href="#page323">PALcode, C– 17 </A>
<A href="#page308">See also Function codes <BR>
</A>
<P>
<A href="#page316">OpenVMS Alpha PALcode, instruction summary, <BR>
C– 14 <BR>
</A>
<P>
Operand expressions, <A href="#page44">3– 4 <BR>
</A>
Operand <A href="#page44">notation <BR>
</A>
defined, 3– 4 <BR>
</A>
<P>
Operand values, <A href="#page44">3– 4 <BR>
</A>
<P>
Operate instruction format <BR>
unused function codes with, <A href="#page53">3– 13 <BR>
</A>
Operate instructions <BR>
opcodes and format summarized, <A href="#page303">C– 1 <BR>
</A>
Operate <A href="#page134">instructions, convert with integer overflow, <BR>
4– 78 <BR>
</A>
<P>
Operators, instruction format, <A href="#page46">3– 6 <BR>
</A>
<A href="#page275">Optimization. See Performance optimizations <BR>
</A>
OR operator, <A href="#page49">3– 9 <BR>
</A>
ORNOT instruction, <A href="#page98">4– 42 <BR>
</A>
Overflow enable (OVFE) <BR>
FP_ C quadword bit, <A href="#page296">B– 6 <BR>
</A>
<P>
Overflow status (OVFS) <BR>
FP_ C quadword bit, <A href="#page295">B– 5 <BR>
</A>
Overlap <BR>
with location access constraints, <A href="#page226">5– 14 </A>
with processor <A href="#page226">issue constraints, </A>
<A href="#page226">5– 13 <BR>
</A>
<P>
with visibility, <A href="#page226">5– 14 <BR>
</A>
OVF bit <BR>
<A href="#page133">See also Arithmetic traps, overflow <BR>
</A>
<P>
<A href="#page137">OVFD bit. See Trap disable bits, overflow disable <BR>
</A>
<P>
<B>P <BR>
</B>Pack to bytes instructions, <A href="#page211">4– 155 <BR>
</A>
PALcode <BR>
barriers with, <A href="#page234">5– 22 </A>
CALL_ PAL instruction, 4– 135 <BR>
</A>
<P>
compared to hardware <A href="#page191">instructions, 6– 1 </A>
implementation-<A href="#page243">specific, </A>
<A href="#page244">6– 2 <BR>
</A>
instead of <A href="#page54">microcode, </A>
<A href="#page243">6– </A>
<A href="#page244">1 </A>
instruction <A href="#page243">format, </A>
<A href="#page243">3– 14 <BR>
</A>
overview, <A href="#page243">6– 1 </A>
recognized instructions, 6– 4 <BR>
</A>
replacing, <A href="#page245">6– 3 </A>
required, 6– 2 <BR>
</A>
required <A href="#page244">instructions, 6– 5 </A>
running environment, <A href="#page247">6– 2 <BR>
</A>
special functions <A href="#page244">function support, 6– 2 <BR>
</A>
PALcode instructions <BR>
opcodes <A href="#page322">and format summarized, </A>
<A href="#page303">C– 1 </A>
required, <A href="#page322">C– 20 <BR>
</A>
<P>
reserved, function codes for, C– 20 <BR>
</A>
PALcode instructions, required privileged, <A href="#page247">6– 5 <BR>
</A>
<P>
PALcode instructions, required unprivileged, <A href="#page247">6– 5 <BR>
</A>
PALcode opcodes in numerical order, <A href="#page320">C– 18 <BR>
</A>
PALcode variation assignments, <A href="#page326">D– 2 <BR>
</A>
PCC_ CNT, <A href="#page43">3– 3, </A>
<A href="#page199">4– 143 <BR>
</A>
PCC_ OFF, <A href="#page43">3– 3, </A>
<A href="#page199">4– 143 <BR>
</A>
Performance monitoring, <A href="#page331">E– 3, </A>
<A href="#page337">E– 9, </A>
<A href="#page351">E– 23 <BR>
</A>
Performance <A href="#page276">optimizations <BR>
</A>
branch <A href="#page283">prediction, </A>
<A href="#page276">A– 2 </A>
code <A href="#page278">sequences, </A>
<A href="#page276">A– 9 <BR>
</A>
<P>
data stream, <A href="#page278">A– </A>
<A href="#page283">4 </A>
for I-<A href="#page278">streams, A– 2 <BR>
</A>
instruction <A href="#page276">alignment, A– 2 </A>
instruction <A href="#page276">scheduling, A– 4 <BR>
</A>
I-stream <A href="#page279">density, </A>
<A href="#page278">A– 4 </A>
shared data, <A href="#page279">A– </A>
<A href="#page278">5 <BR>
</A>
<P>
Performance tuning <BR>
IMPLVER instruction with, <A href="#page197">4– 141 <BR>
</A>
PERR (Pixel error) <A href="#page279">instruction, 4– 154 <BR>
</A>
<P>
Physical <A href="#page213">address space <BR>
</A>
described, 5– 1 <BR>
</A>
PHYSICAL_ ADDRESS operator, <A href="#page49">3– 9 <BR>
</A>
<P>
Pipelined implementations, using EXCB instruction 
367
<BR>
<A href=#page367>367</A>
<strong><A name=page368> Page 368</A></strong>
<A href=#page369>369</A>
<BR>
<P>
<B>Index– 10 <BR>
</B>with, <A href="#page194">4– 138 <BR>
</A>
Pixel error instruction, <A href="#page210">4– 154 <BR>
</A>
PKLB (Pack longwords to bytes) instruction, <A href="#page211">4– 155 <BR>
</A>
PKWB (Pack words to bytes) instruction, <A href="#page211">4– 155 <BR>
</A>
Prefetch data (FETCH instruction), <A href="#page195">4– 139 <BR>
</A>
PRIORITY_ ENCODE operator, <A href="#page49">3– 9 <BR>
</A>
<A href="#page54">Privileged Architecture Library. See PALcode <BR>
</A>
Processor communication, <A href="#page227">5– 15 <BR>
</A>
Processor cycle counter <A href="#page199">(PCC) register, </A>
<A href="#page43">3– 3 <BR>
</A>
RPCC instruction with, <A href="#page199">4– 143 <BR>
</A>
Processor issue constraints, <A href="#page224">5– 12 <BR>
</A>
<P>
Processor issue sequence, <A href="#page224">5– 12 <BR>
</A>
Processor type assignments, <A href="#page325">D– 1 <BR>
</A>
Program counter (PC) <A href="#page194">register, </A>
<A href="#page41">3– 1 <BR>
</A>
with EXCB instruction, 4– 138 <BR>
</A>
Pseudo-ops, <A href="#page288">A– 14 <BR>
</A>
<P>
<B>Q <BR>
</B>Quadword data <A href="#page29">type, </A>
<A href="#page28">2– 2 <BR>
</A>
alignment of, 2– 3, 2– 12 </A>
atomic access <A href="#page29">of, </A>
<A href="#page38">5– 2 <BR>
</A>
<P>
integer floating-<A href="#page214">point format, 2– 12 </A>
T_ floating with, <A href="#page38">2– 12 <BR>
</A>
<P>
<B>R <BR>
</B>R31 <BR>
restrictions, <A href="#page41">3– 1 <BR>
</A>
<P>
RAZ (read as zero), <A href="#page25">1– 9 <BR>
</A>
<P>
RC (read and clear) instruction, <A href="#page206">4– 150 <BR>
</A>
RDUNIQUE (PALcode) <A href="#page246">instruction <BR>
</A>
required recognition of, 6– 4 <BR>
</A>
Read/ write ordering <A href="#page222">(multiprocessor), </A>
<A href="#page222">5– 10 <BR>
</A>
determining requirements, <A href="#page222">5– 10 </A>
hardware implications <A href="#page223">for, </A>
<A href="#page222">5– 29 <BR>
</A>
<P>
memory location defined, <A href="#page241">5– 11 <BR>
</A>
Read/ write, sequential, <A href="#page282">A– 8 <BR>
</A>
<P>
Regions in physical address space, <A href="#page213">5– 1 <BR>
</A>
Registers, <A href="#page41">3– 1 <BR>
floating-point, 3– 2 </A>
<A href="#page42">integer, </A>
<A href="#page41">3– 1 <BR>
</A>
<P>
lock, 3– 2 </A>
<A href="#page42">memory prefetch, 3– 3 <BR>
</A>
optional, <A href="#page43">3– 3 </A>
processor cycle counter, 3– 3 <BR>
</A>
program counter <A href="#page50">(PC), </A>
<A href="#page43">3– 1 </A>
value when unused, <A href="#page41">3– 10 <BR>
</A>
<A href="#page41">VAX compatibility, </A>
<A href="#page50">3– 3 </A>
<A href="#page41">See also specific </A>
<A href="#page43">registers <BR>
</A>
<P>
Register-to-register move, <A href="#page287">A– 13 <BR>
</A>
Relational Operators, <A href="#page49">3– 9 <BR>
</A>
Representative result, <A href="#page120">4– 64 <BR>
</A>
Reserved instructions, opcodes for, <A href="#page323">C– 21 <BR>
</A>
Result latency, <A href="#page278">A– 4 <BR>
</A>
RET instruction, <A href="#page78">4– 22 <BR>
</A>
RIGHT_ SHIFT( x, y) operator, <A href="#page49">3– 9 <BR>
</A>
<A href="#page122">Rounding modes. See Floating-point rounding modes <BR>
</A>
RPCC <A href="#page199">(read processor cycle counter) instruction, <BR>
4– 143 <BR>
</A>
<P>
RS (read and set) instruction, <A href="#page206">4– 150 <BR>
</A>
<P>
<B>S <BR>
</B>S_ floating data <A href="#page34">type <BR>
</A>
alignment of, 2– 8 </A>
compared to F_floating, 2– 8 <BR>
</A>
<P>
<A href="#page33">exceptions, </A>
<A href="#page34">2– 8 </A>
mapping, 2– 7 <BR>
</A>
MAX/ <A href="#page33">MIN, 4– 65 </A>
NaN with <A href="#page118">T_</A>
<A href="#page121">floating convert, 4– 88 <BR>
</A>
operations, <A href="#page118">4– 62 <BR>
</A>
S4ADDL instruction, <A href="#page82">4– 26 <BR>
</A>
<P>
S4ADDQ instruction, <A href="#page84">4– 28 <BR>
</A>
S4SUBL instruction, <A href="#page94">4– 38 <BR>
</A>
S4SUBQ instruction, <A href="#page96">4– 40 <BR>
</A>
S8ADDL instruction, <A href="#page82">4– 26 <BR>
</A>
S8ADDQ instruction, <A href="#page84">4– 28 <BR>
</A>
S8SUBL instruction, <A href="#page94">4– 38 <BR>
</A>
S8SUBQ instruction, <A href="#page96">4– 40 <BR>
</A>
SBZ (should be zero), <A href="#page25">1– 9 <BR>
</A>
Security holes, <A href="#page23">1– 7 <BR>
</A>
with UNPREDICTABLE results, 1– 8 <BR>
</A>
Sequential read/ write, <A href="#page282">A– 8 <BR>
</A>
<P>
Serialization, MB instruction with, <A href="#page198">4– 142 <BR>
</A>
SEXT( x) operator, <A href="#page49">3– 9 <BR>
</A>
Shared data (multiprocessor), <A href="#page279">A– 5 <BR>
</A>
changed vs. updated datum, 5– 6 <BR>
</A>
Shared data <A href="#page219">structures <BR>
</A>
atomic update, 5– 7 </A>
ordering considerations, 5– 9 <BR>
</A>
<P>
using memory barrier <A href="#page221">(MB) instruction, 5– 9 <BR>
</A>
Shared memory <BR>
<A href="#page222">accessing, </A>
<A href="#page223">5– 11 </A>
defined, 5– 10 
368
<BR>
<A href=#page368>368</A>
<strong><A name=page369> Page 369</A></strong>
<A href=#page370>370</A>
<BR>
<P>
</A>
<B>Index– 11 <BR>
</B>Shift arithmetic instructions, <A href="#page102">4– 46 <BR>
</A>
Sign extend instructions, <A href="#page116">4– 60 <BR>
</A>
Single-precision floating-point, <A href="#page118">4– 62 <BR>
</A>
SLL instruction, <A href="#page101">4– 45 <BR>
</A>
Software considerations, <A href="#page275">A– 1 <BR>
</A>
<A href="#page275">See also </A>
<A href="#page275">Performance optimizations <BR>
</A>
SQRTF instruction, <A href="#page184">4– 128 <BR>
</A>
<P>
SQRTG instruction, <A href="#page184">4– 128 <BR>
</A>
SQRTS instruction, <A href="#page185">4– 129 <BR>
</A>
SQRTT instruction, <A href="#page185">4– 129 <BR>
</A>
Square root <A href="#page185">instructions <BR>
</A>
IEEE, 4– 129 </A>
VAX, 4– 128 <BR>
</A>
<P>
SRA instruction, <A href="#page102">4– 46 <BR>
</A>
SRL instruction, <A href="#page101">4– 45 <BR>
</A>
STB instruction, <A href="#page71">4– 15 <BR>
</A>
STF instruction, <A href="#page151">4– 95 <BR>
</A>
STG instruction, <A href="#page152">4– 96 <BR>
</A>
STL instruction, <A href="#page71">4– 15 <BR>
</A>
STL_ C instruction, <A href="#page68">4– 12 <BR>
</A>
when guaranteed ordering with LDL_L, 4– 14 </A>
with LDx_ L instruction, <A href="#page68">4– 12 <BR>
</A>
<P>
with processor lock register/ flag, 4– 12 <BR>
</A>
Storage, defined, <A href="#page226">5– 14 <BR>
</A>
<P>
Store instructions <BR>
emulation of, <A href="#page59">4– 3 </A>
FETCH instruction, 4– 139 <BR>
</A>
<P>
<A href="#page198">multiprocessor </A>
<A href="#page195">environment, 5– 6 </A>
<A href="#page71">serialization, </A>
<A href="#page198">4– 142 <BR>
</A>
Store byte, 4– 15 </A>
store <A href="#page71">longword, 4– 15 <BR>
</A>
store longword <A href="#page71">conditional, 4– 12 </A>
store quadword, <A href="#page71">4– 15 <BR>
</A>
store <A href="#page71">quadword </A>
<A href="#page71">conditional, 4– 12 </A>
Store <A href="#page73">word, </A>
<A href="#page71">4– 15 <BR>
</A>
<A href="#page146">STQ_U, </A>
<A href="#page73">4– </A>
<A href="#page71">17 </A>
<A href="#page146">See also </A>
<A href="#page73">Floating-point store instructions <BR>
</A>
<P>
Store memory integer instructions, <A href="#page60">4– 4 <BR>
</A>
STORE_ CONDITIONAL operator, <A href="#page49">3– 9 <BR>
</A>
Store-conditional, defined, <A href="#page228">5– 16 <BR>
</A>
STQ instruction, <A href="#page71">4– 15 <BR>
</A>
STQ_ C instruction, <A href="#page68">4– 12 <BR>
</A>
when guaranteed ordering with LDQ_L, 4– 14 </A>
with LDx_ L instruction, <A href="#page68">4– 12 <BR>
</A>
<P>
with processor lock register/ flag, 4– 12 <BR>
</A>
STQ_ U instruction, <A href="#page73">4– 17 <BR>
</A>
<P>
STS instruction, <A href="#page153">4– 97 <BR>
</A>
with FPCR, 4– 84 <BR>
</A>
<P>
STT instruction, <A href="#page154">4– 98 <BR>
</A>
STW instruction, <A href="#page71">4– 15 <BR>
</A>
SUBF instruction, <A href="#page186">4– 130 <BR>
</A>
SUBG instruction, <A href="#page186">4– 130 <BR>
</A>
SUBL instruction, <A href="#page93">4– 37 <BR>
</A>
SUBQ instruction, <A href="#page95">4– 39 <BR>
</A>
SUBS instruction, <A href="#page187">4– 131 <BR>
</A>
SUBT instruction, <A href="#page187">4– 131 <BR>
</A>
Subtract instructions <BR>
subtract longword, <A href="#page93">4– 37 </A>
subtract quadword, 4– 39 <BR>
</A>
<P>
subtract scaled <A href="#page95">longword, 4– 38 </A>
<A href="#page158">subtract scaled quadword, </A>
<A href="#page94">4– 40 <BR>
</A>
<A href="#page158">See also Floating-point </A>
<A href="#page96">operate <BR>
</A>
<A href="#page136">SUM bit. See Summary bit <BR>
</A>
<P>
Summary bit, in FPCR, <A href="#page136">4– 80 <BR>
</A>
SWPPAL (PALcode) <A href="#page246">instruction <BR>
</A>
required recognition of, 6– 4 <BR>
</A>
swppal (PALcode) <A href="#page246">instruction <BR>
</A>
required recognition of, 6– 4 <BR>
</A>
<P>
<B>T <BR>
</B>T_ floating data <A href="#page35">type <BR>
</A>
alignment <A href="#page35">of, </A>
<A href="#page35">2– 9 </A>
<A href="#page35">exceptions, </A>
<A href="#page35">2– 9 <BR>
</A>
<P>
format, <A href="#page35">2– 9 </A>
MAX/ MIN, 4– 65 <BR>
</A>
NaN with S_ <A href="#page121">floating convert, 4– 88 <BR>
</A>
TEST( x, cond) operator, <A href="#page50">3– 10 <BR>
</A>
<P>
Timeliness of location access, <A href="#page229">5– 17 <BR>
</A>
Timing considerations, atomic sequences, <A href="#page290">A– 16 <BR>
</A>
Trap disable bits, <A href="#page134">4– 78 <BR>
</A>
denormal operand exception, 4– 81 </A>
division by zero, <A href="#page137">4– 81 <BR>
</A>
<P>
DZED with DZE arithmetic trap, 4– 77 </A>
DZED with INV <A href="#page294">arithmetic trap, </A>
<A href="#page133">4– 76 <BR>
</A>
IEEE <A href="#page136">compliance and, </A>
<A href="#page294">B– 4 </A>
inexact result, <A href="#page136">4– 80 <BR>
</A>
invalid operation, 4– 81 </A>
overflow <A href="#page136">disable, </A>
<A href="#page137">4– 81 <BR>
</A>
underflow, <A href="#page136">4– 80 </A>
underflow to zero, 4– 80 <BR>
</A>
when <A href="#page136">unimplemented, 4– 78 <BR>
</A>
Trap enable bits, <A href="#page295">B– 5 <BR>
</A>
<P>
Trap <A href="#page130">handler, with non-finite arithmetic operands, <BR>
4– 74 <BR>
</A>
<P>
Trap <A href="#page222">handling, IEEE floating-point, B– 6 <BR>
</A>
Trap modes <BR>
floating-point, <A href="#page125">4– 69 <BR>
</A>
Trap shadow <BR>
defined for floating-point, <A href="#page120">4– 64 </A>
programming implications for, 5– 30 
369
<BR>
<A href=#page369>369</A>
<strong><A name=page370> Page 370</A></strong>
<A href=#page371>371</A>
<BR>
<P>
</A>
<B>Index– 12 <BR>
</B>TRAPB (trap <A href="#page200">barrier) instruction <BR>
</A>
described, 4– 144 </A>
with FPCR, 4– 84 <BR>
</A>
<P>
True result, <A href="#page120">4– 64 <BR>
</A>
True zero, <A href="#page121">4– 65 <BR>
</A>
<P>
<B>U <BR>
</B>UMULH <A href="#page91">instruction, </A>
<A href="#page92">4– 36 <BR>
</A>
with MULQ, <A href="#page91">4– </A>
<A href="#page92">35 <BR>
</A>
<P>
UNALIGNED data objects, <A href="#page24">1– 8 <BR>
</A>
<P>
Unconditional long jump, <A href="#page79">4– 23 <BR>
</A>
UNDEFINED operations, <A href="#page23">1– 7 <BR>
</A>
Underflow enable <A href="#page296">(UNFE) <BR>
</A>
FP_ C quadword bit, B– 6 <BR>
</A>
Underflow status (UNFS) <BR>
FP_ C quadword bit, <A href="#page295">B– 5 <BR>
</A>
<A href="#page136">UNDZ bit. See Trap disable bits, underflow to zero <BR>
</A>
<P>
UNF bit <BR>
<A href="#page134">See also Arithmetic traps, underflow <BR>
</A>
<A href="#page136">UNFD bit. See Trap disable bits, underflow <BR>
</A>
<P>
UNOP code form, <A href="#page285">A– 11 <BR>
</A>
UNORDERED memory references, <A href="#page222">5– 10 <BR>
</A>
Unpack to bytes instructions, <A href="#page212">4– 156 <BR>
</A>
UNPKBL <A href="#page212">(Unpack bytes to longwords) instruction, <BR>
4– 156 <BR>
</A>
<P>
<A href="#page212">UNPKBW (Unpack bytes to words) instruction, <BR>
4– 156 <BR>
</A>
<P>
UNPREDICTABLE results, <A href="#page23">1– 7 <BR>
</A>
Updated datum, <A href="#page218">5– 6 <BR>
</A>
<P>
<B>V <BR>
</B>VAX <A href="#page205">compatibility instructions, restrictions for, <BR>
4– 149 <BR>
</A>
<P>
VAX compatibility register, <A href="#page43">3– 3 <BR>
</A>
VAX floating-<A href="#page31">point <BR>
</A>
D_ floating, 2– 5 </A>
F_ floating, 2– 3 <BR>
</A>
<P>
<A href="#page31">G_floating, </A>
<A href="#page29">2– 4 </A>
<A href="#page31">See also </A>
<A href="#page30">Floating-point instructions <BR>
</A>
<P>
VAX floating-point <A href="#page166">instructions <BR>
</A>
add instructions, 4– 110 </A>
compare instructionsCMPGEQ instruction, <BR>
</A>
<P>
<A href="#page168">4– 112 </A>
convert from integer instructions, 4– 115 <BR>
</A>
convert to integer instructions, <A href="#page171">4– 114 </A>
convert <A href="#page172">VAX floating format </A>
<A href="#page170">instructions, <BR>
</A>
<A href="#page172">4– 116 </A>
divide instructions, 4– 121 <BR>
</A>
from integer move, <A href="#page177">4– 124 </A>
function codes for, <A href="#page180">C– 7 <BR>
</A>
<P>
function field format, <A href="#page143">4– 87 </A>
multiply <A href="#page158">instructions, </A>
<A href="#page143">4– 126 <BR>
</A>
operate instructions, <A href="#page182">4– 102 </A>
square root <A href="#page158">instructions, 4– 128 <BR>
</A>
subtract instructions, <A href="#page186">4– </A>
<A href="#page184">130 <BR>
</A>
VAX rounding modes, <A href="#page122">4– 66 <BR>
</A>
<P>
Vector instructions <BR>
byte and word maximum, <A href="#page208">4– 152 </A>
byte and word minimum, 4– 152 <BR>
</A>
<P>
Virtual D-cache, <A href="#page216">5– 4 <BR>
</A>
Virtual I-cache, <A href="#page216">5– 4 <BR>
</A>
maintaining coherency of, 5– 5 <BR>
</A>
Visibility, defined, <A href="#page226">5– 14 <BR>
</A>
<P>
<B>W <BR>
</B>Waivers, <A href="#page329">E– 1 <BR>
</A>
WH64 (Write hint) instruction, <A href="#page201">4– 145 <BR>
</A>
WH64 instruction <BR>
lock_ flag with, <A href="#page66">4– 10 <BR>
</A>
Windows <A href="#page319">NT Alpha PALcode, instruction summary, <BR>
C– 17 <BR>
</A>
<P>
WMB (Write memory <A href="#page220">barrier) instruction, </A>
<A href="#page203">4– 147 <BR>
</A>
atomic operations <A href="#page204">with, </A>
<A href="#page220">5– 8 </A>
compared with MB, <A href="#page204">4– </A>
<A href="#page220">148 <BR>
</A>
<P>
with shared data <A href="#page204">structures, 5– 9 <BR>
</A>
Word data type, <A href="#page27">2– 1 <BR>
</A>
atomic access of, 5– 3 <BR>
</A>
Write buffers, requirements for, <A href="#page217">5– 5 <BR>
</A>
<P>
Write-back caches, requirements for, <A href="#page217">5– 5 <BR>
</A>
wrunique (PALcode) <A href="#page246">instruction <BR>
</A>
required recognition of, 6– 4 <BR>
</A>
<P>
<B>X <BR>
</B>x MOD y operator, <A href="#page48">3– 8 <BR>
</A>
X_ floating data <A href="#page36">type, </A>
<A href="#page35">2– 9 <BR>
</A>
alignment of, <A href="#page36">2– </A>
<A href="#page35">10 </A>
big-endian <A href="#page36">format, 2– 10 <BR>
</A>
<P>
MAX/ MIN, <A href="#page121">4– 65 
370
<BR>
<A href=#page370>370</A>
<strong><A name=page371> Page 371</A></strong>
<BR>
<P>
</A>
<B>Index– 13 <BR>
</B>XOR instruction, <A href="#page98">4– 42 <BR>
</A>
XOR operator, <A href="#page50">3– 10 <BR>
</A>
<P>
<B>Y <BR>
</B>YUV coordinates, interleaved, <A href="#page207">4– 151 <BR>
</A>
<P>
<B>Z <BR>
</B>ZAP instruction, <A href="#page117">4– 61 <BR>
</A>
ZAPNOT instruction, <A href="#page117">4– 61 <BR>
</A>
Zero byte instructions, <A href="#page117">4– 61 <BR>
</A>
ZEXT( x) operator, <A href="#page50">3– 10 
371
<H1> <A name=PageLinks>Page Navigation Panel </H1>
<A href=#page1>1</A>
<A href=#page2>2</A>
<A href=#page3>3</A>
<A href=#page4>4</A>
<A href=#page5>5</A>
<A href=#page6>6</A>
<A href=#page7>7</A>
<A href=#page8>8</A>
<A href=#page9>9</A>
<BR>
<A href=#page10>10</A>
<A href=#page11>11</A>
<A href=#page12>12</A>
<A href=#page13>13</A>
<A href=#page14>14</A>
<A href=#page15>15</A>
<A href=#page16>16</A>
<A href=#page17>17</A>
<A href=#page18>18</A>
<A href=#page19>19</A>
<BR>
<A href=#page20>20</A>
<A href=#page21>21</A>
<A href=#page22>22</A>
<A href=#page23>23</A>
<A href=#page24>24</A>
<A href=#page25>25</A>
<A href=#page26>26</A>
<A href=#page27>27</A>
<A href=#page28>28</A>
<A href=#page29>29</A>
<BR>
<A href=#page30>30</A>
<A href=#page31>31</A>
<A href=#page32>32</A>
<A href=#page33>33</A>
<A href=#page34>34</A>
<A href=#page35>35</A>
<A href=#page36>36</A>
<A href=#page37>37</A>
<A href=#page38>38</A>
<A href=#page39>39</A>
<BR>
<A href=#page40>40</A>
<A href=#page41>41</A>
<A href=#page42>42</A>
<A href=#page43>43</A>
<A href=#page44>44</A>
<A href=#page45>45</A>
<A href=#page46>46</A>
<A href=#page47>47</A>
<A href=#page48>48</A>
<A href=#page49>49</A>
<BR>
<A href=#page50>50</A>
<A href=#page51>51</A>
<A href=#page52>52</A>
<A href=#page53>53</A>
<A href=#page54>54</A>
<A href=#page55>55</A>
<A href=#page56>56</A>
<A href=#page57>57</A>
<A href=#page58>58</A>
<A href=#page59>59</A>
<BR>
<A href=#page60>60</A>
<A href=#page61>61</A>
<A href=#page62>62</A>
<A href=#page63>63</A>
<A href=#page64>64</A>
<A href=#page65>65</A>
<A href=#page66>66</A>
<A href=#page67>67</A>
<A href=#page68>68</A>
<A href=#page69>69</A>
<BR>
<A href=#page70>70</A>
<A href=#page71>71</A>
<A href=#page72>72</A>
<A href=#page73>73</A>
<A href=#page74>74</A>
<A href=#page75>75</A>
<A href=#page76>76</A>
<A href=#page77>77</A>
<A href=#page78>78</A>
<A href=#page79>79</A>
<BR>
<A href=#page80>80</A>
<A href=#page81>81</A>
<A href=#page82>82</A>
<A href=#page83>83</A>
<A href=#page84>84</A>
<A href=#page85>85</A>
<A href=#page86>86</A>
<A href=#page87>87</A>
<A href=#page88>88</A>
<A href=#page89>89</A>
<BR>
<A href=#page90>90</A>
<A href=#page91>91</A>
<A href=#page92>92</A>
<A href=#page93>93</A>
<A href=#page94>94</A>
<A href=#page95>95</A>
<A href=#page96>96</A>
<A href=#page97>97</A>
<A href=#page98>98</A>
<A href=#page99>99</A>
<BR>
<A href=#page100>100</A>
<A href=#page101>101</A>
<A href=#page102>102</A>
<A href=#page103>103</A>
<A href=#page104>104</A>
<A href=#page105>105</A>
<A href=#page106>106</A>
<A href=#page107>107</A>
<A href=#page108>108</A>
<A href=#page109>109</A>
<BR>
<A href=#page110>110</A>
<A href=#page111>111</A>
<A href=#page112>112</A>
<A href=#page113>113</A>
<A href=#page114>114</A>
<A href=#page115>115</A>
<A href=#page116>116</A>
<A href=#page117>117</A>
<A href=#page118>118</A>
<A href=#page119>119</A>
<BR>
<A href=#page120>120</A>
<A href=#page121>121</A>
<A href=#page122>122</A>
<A href=#page123>123</A>
<A href=#page124>124</A>
<A href=#page125>125</A>
<A href=#page126>126</A>
<A href=#page127>127</A>
<A href=#page128>128</A>
<A href=#page129>129</A>
<BR>
<A href=#page130>130</A>
<A href=#page131>131</A>
<A href=#page132>132</A>
<A href=#page133>133</A>
<A href=#page134>134</A>
<A href=#page135>135</A>
<A href=#page136>136</A>
<A href=#page137>137</A>
<A href=#page138>138</A>
<A href=#page139>139</A>
<BR>
<A href=#page140>140</A>
<A href=#page141>141</A>
<A href=#page142>142</A>
<A href=#page143>143</A>
<A href=#page144>144</A>
<A href=#page145>145</A>
<A href=#page146>146</A>
<A href=#page147>147</A>
<A href=#page148>148</A>
<A href=#page149>149</A>
<BR>
<A href=#page150>150</A>
<A href=#page151>151</A>
<A href=#page152>152</A>
<A href=#page153>153</A>
<A href=#page154>154</A>
<A href=#page155>155</A>
<A href=#page156>156</A>
<A href=#page157>157</A>
<A href=#page158>158</A>
<A href=#page159>159</A>
<BR>
<A href=#page160>160</A>
<A href=#page161>161</A>
<A href=#page162>162</A>
<A href=#page163>163</A>
<A href=#page164>164</A>
<A href=#page165>165</A>
<A href=#page166>166</A>
<A href=#page167>167</A>
<A href=#page168>168</A>
<A href=#page169>169</A>
<BR>
<A href=#page170>170</A>
<A href=#page171>171</A>
<A href=#page172>172</A>
<A href=#page173>173</A>
<A href=#page174>174</A>
<A href=#page175>175</A>
<A href=#page176>176</A>
<A href=#page177>177</A>
<A href=#page178>178</A>
<A href=#page179>179</A>
<BR>
<A href=#page180>180</A>
<A href=#page181>181</A>
<A href=#page182>182</A>
<A href=#page183>183</A>
<A href=#page184>184</A>
<A href=#page185>185</A>
<A href=#page186>186</A>
<A href=#page187>187</A>
<A href=#page188>188</A>
<A href=#page189>189</A>
<BR>
<A href=#page190>190</A>
<A href=#page191>191</A>
<A href=#page192>192</A>
<A href=#page193>193</A>
<A href=#page194>194</A>
<A href=#page195>195</A>
<A href=#page196>196</A>
<A href=#page197>197</A>
<A href=#page198>198</A>
<A href=#page199>199</A>
<BR>
<A href=#page200>200</A>
<A href=#page201>201</A>
<A href=#page202>202</A>
<A href=#page203>203</A>
<A href=#page204>204</A>
<A href=#page205>205</A>
<A href=#page206>206</A>
<A href=#page207>207</A>
<A href=#page208>208</A>
<A href=#page209>209</A>
<BR>
<A href=#page210>210</A>
<A href=#page211>211</A>
<A href=#page212>212</A>
<A href=#page213>213</A>
<A href=#page214>214</A>
<A href=#page215>215</A>
<A href=#page216>216</A>
<A href=#page217>217</A>
<A href=#page218>218</A>
<A href=#page219>219</A>
<BR>
<A href=#page220>220</A>
<A href=#page221>221</A>
<A href=#page222>222</A>
<A href=#page223>223</A>
<A href=#page224>224</A>
<A href=#page225>225</A>
<A href=#page226>226</A>
<A href=#page227>227</A>
<A href=#page228>228</A>
<A href=#page229>229</A>
<BR>
<A href=#page230>230</A>
<A href=#page231>231</A>
<A href=#page232>232</A>
<A href=#page233>233</A>
<A href=#page234>234</A>
<A href=#page235>235</A>
<A href=#page236>236</A>
<A href=#page237>237</A>
<A href=#page238>238</A>
<A href=#page239>239</A>
<BR>
<A href=#page240>240</A>
<A href=#page241>241</A>
<A href=#page242>242</A>
<A href=#page243>243</A>
<A href=#page244>244</A>
<A href=#page245>245</A>
<A href=#page246>246</A>
<A href=#page247>247</A>
<A href=#page248>248</A>
<A href=#page249>249</A>
<BR>
<A href=#page250>250</A>
<A href=#page251>251</A>
<A href=#page252>252</A>
<A href=#page253>253</A>
<A href=#page254>254</A>
<A href=#page255>255</A>
<A href=#page256>256</A>
<A href=#page257>257</A>
<A href=#page258>258</A>
<A href=#page259>259</A>
<BR>
<A href=#page260>260</A>
<A href=#page261>261</A>
<A href=#page262>262</A>
<A href=#page263>263</A>
<A href=#page264>264</A>
<A href=#page265>265</A>
<A href=#page266>266</A>
<A href=#page267>267</A>
<A href=#page268>268</A>
<A href=#page269>269</A>
<BR>
<A href=#page270>270</A>
<A href=#page271>271</A>
<A href=#page272>272</A>
<A href=#page273>273</A>
<A href=#page274>274</A>
<A href=#page275>275</A>
<A href=#page276>276</A>
<A href=#page277>277</A>
<A href=#page278>278</A>
<A href=#page279>279</A>
<BR>
<A href=#page280>280</A>
<A href=#page281>281</A>
<A href=#page282>282</A>
<A href=#page283>283</A>
<A href=#page284>284</A>
<A href=#page285>285</A>
<A href=#page286>286</A>
<A href=#page287>287</A>
<A href=#page288>288</A>
<A href=#page289>289</A>
<BR>
<A href=#page290>290</A>
<A href=#page291>291</A>
<A href=#page292>292</A>
<A href=#page293>293</A>
<A href=#page294>294</A>
<A href=#page295>295</A>
<A href=#page296>296</A>
<A href=#page297>297</A>
<A href=#page298>298</A>
<A href=#page299>299</A>
<BR>
<A href=#page300>300</A>
<A href=#page301>301</A>
<A href=#page302>302</A>
<A href=#page303>303</A>
<A href=#page304>304</A>
<A href=#page305>305</A>
<A href=#page306>306</A>
<A href=#page307>307</A>
<A href=#page308>308</A>
<A href=#page309>309</A>
<BR>
<A href=#page310>310</A>
<A href=#page311>311</A>
<A href=#page312>312</A>
<A href=#page313>313</A>
<A href=#page314>314</A>
<A href=#page315>315</A>
<A href=#page316>316</A>
<A href=#page317>317</A>
<A href=#page318>318</A>
<A href=#page319>319</A>
<BR>
<A href=#page320>320</A>
<A href=#page321>321</A>
<A href=#page322>322</A>
<A href=#page323>323</A>
<A href=#page324>324</A>
<A href=#page325>325</A>
<A href=#page326>326</A>
<A href=#page327>327</A>
<A href=#page328>328</A>
<A href=#page329>329</A>
<BR>
<A href=#page330>330</A>
<A href=#page331>331</A>
<A href=#page332>332</A>
<A href=#page333>333</A>
<A href=#page334>334</A>
<A href=#page335>335</A>
<A href=#page336>336</A>
<A href=#page337>337</A>
<A href=#page338>338</A>
<A href=#page339>339</A>
<BR>
<A href=#page340>340</A>
<A href=#page341>341</A>
<A href=#page342>342</A>
<A href=#page343>343</A>
<A href=#page344>344</A>
<A href=#page345>345</A>
<A href=#page346>346</A>
<A href=#page347>347</A>
<A href=#page348>348</A>
<A href=#page349>349</A>
<BR>
<A href=#page350>350</A>
<A href=#page351>351</A>
<A href=#page352>352</A>
<A href=#page353>353</A>
<A href=#page354>354</A>
<A href=#page355>355</A>
<A href=#page356>356</A>
<A href=#page357>357</A>
<A href=#page358>358</A>
<A href=#page359>359</A>
<BR>
<A href=#page360>360</A>
<A href=#page361>361</A>
<A href=#page362>362</A>
<A href=#page363>363</A>
<A href=#page364>364</A>
<A href=#page365>365</A>
<A href=#page366>366</A>
<A href=#page367>367</A>
<A href=#page368>368</A>
<A href=#page369>369</A>
<BR>
<A href=#page370>370</A>
<A href=#page371>371</A>
</BODy></HTML>

