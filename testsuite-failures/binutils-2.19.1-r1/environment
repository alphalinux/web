ALLOWED_FLAGS=$'-pipe -O -O0 -O1 -O2 -mcpu -march -mtune -fstack-protector -fstack-protector-all -fbounds-checking -fno-strict-overflow -fno-PIE -fno-pie -fno-unit-at-a-time -g -g[0-9] -ggdb -ggdb[0-9] -gstabs -gstabs+ -fno-ident -W* -w -fno-stack-protector -fno-stack-protector-all \t\t-fno-strict-aliasing -fno-bounds-checking -fstrict-overflow -fno-omit-frame-pointer -mregparm -mno-app-regs -mapp-regs \t\t-mno-mmx -mno-sse -mno-sse2 -mno-sse3 -mno-ssse3 -mno-sse4 -mno-sse4.1 \t\t-mno-sse4.2 -mno-avx -mno-aes -mno-pclmul -mno-sse4a -mno-3dnow \t\t-mno-popcnt -mno-abm \t\t-mips1 -mips2 -mips3 -mips4 -mips32 -mips64 -mips16 -mplt \t\t-msoft-float -mno-soft-float -mhard-float -mno-hard-float -mfpu \t\t-mieee -mieee-with-inexact -mschedule \t\t-mtls-direct-seg-refs -mno-tls-direct-seg-refs \t\t-mflat -mno-flat -mno-faster-structs -mfaster-structs \t\t-m32 -m64 -mabi -mlittle-endian -mbig-endian -EL -EB -fPIC \t\t-mlive-g0 -mcmodel -mstack-bias -mno-stack-bias \t\t-msecure-plt -m*-toc -D* -U*'
ALSA_CARDS=
ALSA_PCM_PLUGINS='adpcm alaw asym copy dmix dshare dsnoop empty extplug file hooks iec958 ioplug ladspa lfloat linear meter mmap_emul mulaw multi null plug rate route share shm softvol'
APACHE2_MODULES='actions alias auth_basic authn_alias authn_anon authn_dbm authn_default authn_file authz_dbm authz_default authz_groupfile authz_host authz_owner authz_user autoindex cache dav dav_fs dav_lock deflate dir disk_cache env expires ext_filter file_cache filter headers include info log_config logio mem_cache mime mime_magic negotiation rewrite setenvif speling status unique_id userdir usertrack vhost_alias'
ARCH=alpha
BINPATH=/usr/alpha-unknown-linux-gnu/binutils-bin/2.19.1
BTYPE=rel
BVER=2.19.1
CBUILD=alpha-unknown-linux-gnu
CCFLAGS='-O3 -host'
CCXXFLAGS='-O3 -host'
CDEFINE_default=__unix__
CFLAGS=' -g3 -O2 -mcpu=ev67 -mieee -pipe'
CFLAGS_default=
CHOST=alpha-unknown-linux-gnu
CHOST_default=alpha-unknown-linux-gnu
CROSSCOMPILE_OPTS=
CTARGET=alpha-unknown-linux-gnu
CTARGET_default=alpha-unknown-linux-gnu
CVS_RSH=ssh
CXXFLAGS=' -g3 -O2 -mcpu=ev67 -mieee -pipe'
DATAPATH=/usr/share/binutils-data/alpha-unknown-linux-gnu/2.19.1
DCCC_PATH=/usr/lib/distcc/bin
DEFAULT_ABI=default
DEFINED_PHASES=' compile install postinst postrm test unpack'
DEPEND=$'  sys-devel/gnuconfig >=sys-devel/binutils-config-1.9\n\ttest? ( dev-util/dejagnu )\n\tnls? ( sys-devel/gettext )\n\tsys-devel/flex'
DESCRIPTION='Tools necessary to build programs'
DESTTREE=/usr
DIROPTIONS=-m0755
EAPI=0
ELF2FLT_VER=
ELIBC=glibc
ELIBTOOL_VERSION=2.0.2
ELT_APPLIED_PATCHES=' 1.5.4 2.2 1.5.6 2.2.6'
ELT_LTMAIN_SH=/var/tmp/portage/sys-devel/binutils-2.19.1-r1/work/binutils-2.19.1/ltmain.sh
ELT_PATCH_DIR=/usr/portage/eclass/ELT-patches
EPATCH_EXCLUDE=
EPATCH_FORCE=no
EPATCH_MULTI_MSG='Applying various patches (bugfixes/updates) ...'
EPATCH_OPTS='-g0 -E --no-backup-if-mismatch'
EPATCH_SINGLE_MSG=
EPATCH_SOURCE=/var/tmp/portage/sys-devel/binutils-2.19.1-r1/work/patch
EPATCH_SUFFIX=patch
EXEOPTIONS=-m0755
FCFLAGS=
FEATURES='ccache distlocks fixpackages parallel-fetch protect-owned sandbox sfperms splitdebug strict test unmerge-orphans userfetch'
FFLAGS=
GCC_SPECS=
GDK_USE_XFT=1
HOMEPAGE=http://sources.redhat.com/binutils/
INCPATH=/usr/lib/binutils/alpha-unknown-linux-gnu/2.19.1/include
INHERITED='toolchain-funcs portability flag-o-matic versionator multilib toolchain-binutils libtool gnuconfig eutils'
INPUT_DEVICES=
INSDESTTREE=
INSOPTIONS=-m0644
IUSE='  gold nls multitarget multislot test vanilla'
KERNEL=linux
KERNEL_ABI=default
KEYWORDS='~alpha ~amd64 ~arm ~hppa ~ia64 ~mips ~ppc ~ppc64 s390 ~sh ~sparc ~x86 ~sparc-fbsd ~x86-fbsd'
KV=2.6.31-rc9
LCD_DEVICES=
LDFLAGS=-Wl,-O1
LDFLAGS_default=
LIBDIR_default=lib
LIBOPTIONS=-m0644
LIBPATH=/usr/lib/binutils/alpha-unknown-linux-gnu/2.19.1
LICENSE='|| ( GPL-3 LGPL-3 )'
LINGUAS=
MAKEOPTS=-j2
MULTILIB_ABIS=default
MY_BUILDDIR=/var/tmp/portage/sys-devel/binutils-2.19.1-r1/work/build
NETBEANS='apisupport cnd groovy gsf harness ide identity j2ee java mobility nb php profiler soa visualweb webcommon websvccommon xml'
OPENGL_PROFILE=xorg-x11
PATCHVER=1.2
PDEPEND=' '
PORTAGE_COMPRESS_EXCLUDE_SUFFIXES='css gif htm[l]? jp[e]?g js pdf png'
PROFILE_ONLY_VARIABLES='ARCH ELIBC KERNEL USERLAND'
PROPERTIES=
PROVIDE=
RDEPEND='  >=sys-devel/binutils-config-1.9'
RESTRICT=
S=/var/tmp/portage/sys-devel/binutils-2.19.1-r1/work/binutils-2.19.1
SANDBOX_DEBUG=0
SANDBOX_DENY=/etc/ld.so.preload
SANDBOX_PID=3437
SANDBOX_PREDICT=/dev/console:/dev/crypto:/dev/random:/proc/self/maps:/var/tmp/portage/sys-devel/binutils-2.19.1-r1/homedir
SANDBOX_READ=/:/dev/shm:/dev/stdin:/var/tmp:/var/tmp/ccache:/var/tmp/ccache
SANDBOX_VERBOSE=1
SANDBOX_WRITE=:/dev/console:/dev/fd:/dev/full:/dev/null:/dev/pts/:/dev/pty:/dev/shm:/dev/stderr:/dev/stdout:/dev/tts:/dev/tty:/dev/vc/:/dev/zero:/proc/self/fd:/tmp/:/usr/lib/cf:/usr/lib/conftest:/usr/lib32/cf:/usr/lib32/conftest:/usr/lib64/cf:/usr/lib64/conftest:/usr/tmp/cf:/usr/tmp/conftest:/var/tmp:/var/tmp/:/var/tmp/ccache:/var/tmp/portage/sys-devel/binutils-2.19.1-r1/homedir/.bash_history:/var/tmp/ccache
SLOT=0
SRC_URI=$'mirror://kernel/linux/devel/binutils/binutils-2.19.1.tar.bz2\n\t\t\tmirror://kernel/linux/devel/binutils/test/binutils-2.19.1.tar.bz2\n\t\t\tmirror://gnu/binutils/binutils-2.19.1.tar.bz2 mirror://gentoo/binutils-2.19.1-patches-1.2.tar.bz2 http://dev.gentoo.org/~vapier/dist/binutils-2.19.1-patches-1.2.tar.bz2'
SSH_CLIENT='10.113.10.85 43712 22'
SSH_CONNECTION='10.113.10.85 43712 10.113.10.251 22'
SSH_TTY=/dev/pts/0
UNSTABLE_FLAGS='-Os -O3 -freorder-blocks'
USE='alpha elibc_glibc kernel_linux test userland_GNU'
USERLAND=GNU
VERSIONATOR_OLD_EXTGLOB='shopt -u extglob'
VERSIONATOR_RECURSION=0
VIDEO_CARDS=
_=PKG_INSTALL_MASK
_E_DOCDESTTREE_=
_E_EXEDESTTREE_=
___ECLASS_RECUR_MULTILIB=yes
___ECLASS_RECUR_TOOLCHAIN_FUNCS=yes
_pipestatus='0 0'
conf=binutils-2.19.1-r1
extra_eclass=
ELT_find_ltmain_sh () 
{ 
    local x=;
    local dirlist=;
    for x in $(find "${S}" -name 'ltmain.sh');
    do
        dirlist="${dirlist} ${x%/*}";
    done;
    echo "${dirlist}"
}
ELT_libtool_version () 
{ 
    local ltmain_sh=$1;
    local version=;
    version=$(eval $(grep -e '^[[:space:]]*VERSION=' "${ltmain_sh}"); 	                 echo "${VERSION}");
    [[ -z ${version} ]] && version="0";
    echo "${version}"
}
ELT_try_and_apply_patch () 
{ 
    local ret=0;
    local file=$1;
    local patch=$2;
    if patch -p0 --dry-run "${file}" "${patch}" &>"${T}/elibtool.log"; then
        einfo "  Applying $(basename "$(dirname "${patch}")")-${patch##*/}.patch ...";
        patch -p0 -g0 --no-backup-if-mismatch "${file}" "${patch}" &>"${T}/elibtool.log";
        ret=$?;
        export ELT_APPLIED_PATCHES="${ELT_APPLIED_PATCHES} ${patch##*/}";
    else
        ret=1;
    fi;
    return "${ret}"
}
ELT_walk_patches () 
{ 
    local x=;
    local y=;
    local ret=1;
    local file=$1;
    local patch_set=$2;
    local patch_dir=;
    local rem_int_dep=$3;
    if [[ -n ${patch_set} ]]; then
        if [[ -d ${ELT_PATCH_DIR}/${patch_set} ]]; then
            patch_dir="${ELT_PATCH_DIR}/${patch_set}";
        else
            return "${ret}";
        fi;
        for x in $(ls -d "${patch_dir}"/* 2> /dev/null | grep -v 'CVS' | sort -r);
        do
            if [[ -n ${x} && -f ${x} ]]; then
                if [[ -n ${rem_int_dep} ]]; then
                    sed -e "s|@REM_INT_DEP@|${rem_int_dep}|g" ${x} > "${T}/$$.rem_int_deps.patch";
                    x="${T}/$$.rem_int_deps.patch";
                fi;
                if ELT_try_and_apply_patch "${file}" "${x}"; then
                    ret=0;
                    break;
                fi;
            fi;
        done;
    fi;
    return "${ret}"
}
VER_major () 
{ 
    [[ -z $1 ]] && return 1;
    local VER=$@;
    echo "${VER%%[^[:digit:]]*}"
}
VER_micro () 
{ 
    [[ -z $1 ]] && return 1;
    local VER=$@;
    VER=${VER#*.*.};
    echo "${VER%%[^[:digit:]]*}"
}
VER_minor () 
{ 
    [[ -z $1 ]] && return 1;
    local VER=$@;
    VER=${VER#*.};
    echo "${VER%%[^[:digit:]]*}"
}
VER_to_int () 
{ 
    [[ -z $1 ]] && return 1;
    local VER_MAJOR=$(VER_major "$1");
    local VER_MINOR=$(VER_minor "$1");
    local VER_MICRO=$(VER_micro "$1");
    local VER_int=$(( VER_MAJOR * 65536 + VER_MINOR * 256 + VER_MICRO ));
    if [[ ${VER_int} -ge 65536 ]]; then
        echo "${VER_int}";
        return 0;
    fi;
    echo 1;
    return 1
}
__versionator__test_version_compare () 
{ 
    __versionator_shopt_toggle on;
    local lt=1 eq=2 gt=3 p q;
    function __versionator__test_version_compare_t () 
    { 
        version_compare "${1}" "${3}";
        local r=$?;
        [[ ${r} -eq ${2} ]] || echo "FAIL: ${@} (got ${r} exp ${2})"
    };
    echo "
		0             $lt 1
		1             $lt 2
		2             $gt 1
		2             $eq 2
		0             $eq 0
		10            $lt 20
		68            $eq 068
		068           $gt 67
		068           $lt 69

		1.0           $lt 2.0
		2.0           $eq 2.0
		2.0           $gt 1.0

		1.0           $gt 0.0
		0.0           $eq 0.0
		0.0           $lt 1.0

		0.1           $lt 0.2
		0.2           $eq 0.2
		0.3           $gt 0.2

		1.2           $lt 2.1
		2.1           $gt 1.2

		1.2.3         $lt 1.2.4
		1.2.4         $gt 1.2.3

		1.2.0         $eq 1.2
		1.2.1         $gt 1.2
		1.2           $lt 1.2.1

		1.2b          $eq 1.2b
		1.2b          $lt 1.2c
		1.2b          $gt 1.2a
		1.2b          $gt 1.2
		1.2           $lt 1.2a

		1.3           $gt 1.2a
		1.3           $lt 1.3a

		1.0_alpha7    $lt 1.0_beta7
		1.0_beta      $lt 1.0_pre
		1.0_pre5      $lt 1.0_rc2
		1.0_rc2       $lt 1.0

		1.0_p1        $gt 1.0
		1.0_p1-r1     $gt 1.0_p1

		1.0_alpha6-r1 $gt 1.0_alpha6
		1.0_beta6-r1  $gt 1.0_alpha6-r2

		1.0_pre1      $lt 1.0-p1

		1.0p          $gt 1.0_p1
		1.0r          $gt 1.0-r1
		1.6.15        $gt 1.6.10-r2
		1.6.10-r2     $lt 1.6.15

	" | while read a b c; do
        [[ -z "${a}${b}${c}" ]] && continue;
        __versionator__test_version_compare_t "${a}" "${b}" "${c}";
    done;
    for q in "alpha beta pre rc=${lt};${gt}" "p r=${gt};${lt}";
    do
        for p in ${q%%=*};
        do
            local c=${q##*=};
            local alt=${c%%;*} agt=${c##*;};
            __versionator__test_version_compare_t "1.0" $agt "1.0_${p}";
            __versionator__test_version_compare_t "1.0" $agt "1.0_${p}1";
            __versionator__test_version_compare_t "1.0" $agt "1.0_${p}068";
            __versionator__test_version_compare_t "2.0_${p}" $alt "2.0";
            __versionator__test_version_compare_t "2.0_${p}1" $alt "2.0";
            __versionator__test_version_compare_t "2.0_${p}068" $alt "2.0";
            __versionator__test_version_compare_t "1.0_${p}" $eq "1.0_${p}";
            __versionator__test_version_compare_t "0.0_${p}" $lt "0.0_${p}1";
            __versionator__test_version_compare_t "666_${p}3" $gt "666_${p}";
            __versionator__test_version_compare_t "1_${p}7" $lt "1_${p}8";
            __versionator__test_version_compare_t "1_${p}7" $eq "1_${p}7";
            __versionator__test_version_compare_t "1_${p}7" $gt "1_${p}6";
            __versionator__test_version_compare_t "1_${p}09" $eq "1_${p}9";
        done;
    done;
    for p in "-r" "_p";
    do
        __versionator__test_version_compare_t "7.2${p}1" $lt "7.2${p}2";
        __versionator__test_version_compare_t "7.2${p}2" $gt "7.2${p}1";
        __versionator__test_version_compare_t "7.2${p}3" $gt "7.2${p}2";
        __versionator__test_version_compare_t "7.2${p}2" $lt "7.2${p}3";
    done;
    __versionator_shopt_toggle off
}
__versionator_shopt_toggle () 
{ 
    VERSIONATOR_RECURSION=${VERSIONATOR_RECURSION:-0};
    case "$1" in 
        "on")
            if [[ $VERSIONATOR_RECURSION -lt 1 ]]; then
                VERSIONATOR_OLD_EXTGLOB=$(shopt -p extglob);
                shopt -s extglob;
            fi;
            VERSIONATOR_RECURSION=$(( $VERSIONATOR_RECURSION + 1 ))
        ;;
        "off")
            VERSIONATOR_RECURSION=$(( $VERSIONATOR_RECURSION - 1 ));
            if [[ $VERSIONATOR_RECURSION -lt 1 ]]; then
                eval $VERSIONATOR_OLD_EXTGLOB;
            fi
        ;;
    esac;
    return 0
}
_cdrom_locate_file_on_cd () 
{ 
    local mline="";
    local showedmsg=0 showjolietmsg=0;
    while [[ -z ${CDROM_ROOT} ]]; do
        local i=0;
        local -a cdset=(${*//:/ });
        if [[ -n ${CDROM_SET} ]]; then
            cdset=(${cdset[${CDROM_SET}]});
        fi;
        while [[ -n ${cdset[${i}]} ]]; do
            local dir=$(dirname ${cdset[${i}]});
            local file=$(basename ${cdset[${i}]});
            local point= node= fs= foo=;
            while read point node fs foo; do
                [[ " cd9660 iso9660 udf " != *" ${fs} "* ]] && ! [[ ${fs} == "subfs" && ",${opts}," == *",fs=cdfss,"* ]] && continue;
                point=${point//\040/ };
                [[ ! -d ${point}/${dir} ]] && continue;
                [[ -z $(find "${point}/${dir}" -maxdepth 1 -iname "${file}") ]] && continue;
                export CDROM_ROOT=${point};
                export CDROM_SET=${i};
                export CDROM_MATCH=${cdset[${i}]};
                return;
            done <<< "$(get_mounts)";
            ((++i));
        done;
        echo;
        if [[ ${showedmsg} -eq 0 ]]; then
            if [[ ${CDROM_TOTAL_CDS} -eq 1 ]]; then
                if [[ -z ${CDROM_NAME} ]]; then
                    einfo "Please insert+mount the cdrom for ${PN} now !";
                else
                    einfo "Please insert+mount the ${CDROM_NAME} cdrom now !";
                fi;
            else
                if [[ -z ${CDROM_NAME_1} ]]; then
                    einfo "Please insert+mount cd #${CDROM_CURRENT_CD} for ${PN} now !";
                else
                    local var="CDROM_NAME_${CDROM_CURRENT_CD}";
                    einfo "Please insert+mount the ${!var} cdrom now !";
                fi;
            fi;
            showedmsg=1;
        fi;
        einfo "Press return to scan for the cd again";
        einfo "or hit CTRL+C to abort the emerge.";
        echo;
        if [[ ${showjolietmsg} -eq 0 ]]; then
            showjolietmsg=1;
        else
            ewarn "If you are having trouble with the detection";
            ewarn "of your CD, it is possible that you do not have";
            ewarn "Joliet support enabled in your kernel.  Please";
            ewarn "check that CONFIG_JOLIET is enabled in your kernel.";
            ebeep 5;
        fi;
        read || die "something is screwed with your system";
    done
}
_epatch_assert () 
{ 
    local _pipestatus=${PIPESTATUS[*]};
    [[ ${_pipestatus// /} -eq 0 ]]
}
_epatch_draw_line () 
{ 
    [[ -z $1 ]] && set "$(printf "%65s" '')";
    echo "${1//?/=}"
}
_filter-hardened () 
{ 
    local f;
    for f in "$@";
    do
        case "${f}" in 
            -fPIC | -fpic | -fPIE | -fpie | -Wl,pie | -pie)
                gcc-specs-pie || continue;
                is-flagq -nopie || append-flags -nopie
            ;;
            -fstack-protector)
                gcc-specs-ssp || continue;
                is-flagq -fno-stack-protector || append-flags $(test-flags -fno-stack-protector)
            ;;
            -fstack-protector-all)
                gcc-specs-ssp-to-all || continue;
                is-flagq -fno-stack-protector-all || append-flags $(test-flags -fno-stack-protector-all)
            ;;
            -fno-strict-overflow)
                gcc-specs-nostrict || continue;
                is-flagq -fstrict-overflow || append-flags $(test-flags -fstrict-overflow)
            ;;
        esac;
    done
}
_filter-var () 
{ 
    local f x VAR VAL;
    declare -a new;
    VAR=$1;
    shift;
    eval VAL=\${${VAR}};
    for f in ${VAL};
    do
        for x in "$@";
        do
            [[ ${f} == ${x} ]] && continue 2;
        done;
        eval new\[\${\#new\[@]}]=\${f};
    done;
    eval export ${VAR}=\${new\[*]}
}
_gcc-install-dir () 
{ 
    echo "$(LC_ALL=C $(tc-getCC) -print-search-dirs 2> /dev/null |		awk '$1=="install:" {print $2}')"
}
_gcc-specs-directive_raw () 
{ 
    local cc=$(tc-getCC);
    local specfiles=$(LC_ALL=C ${cc} -v 2>&1 | awk '$1=="Reading" {print $NF}');
    ${cc} -dumpspecs 2> /dev/null | cat - ${specfiles} | awk -v directive=$1 'BEGIN	{ pspec=""; spec=""; outside=1 }
$1=="*"directive":"  { pspec=spec; spec=""; outside=0; next }
	outside || NF==0 || ( substr($1,1,1)=="*" && substr($1,length($1),1)==":" ) { outside=1; next }
	spec=="" && substr($0,1,1)=="+" { spec=pspec " " substr($0,2); next }
	{ spec=spec $0 }
END	{ print spec }';
    return 0
}
_gcc-specs-exists () 
{ 
    [[ -f $(_gcc-install-dir)/$1 ]]
}
_is_flagq () 
{ 
    local x;
    for x in ${!1};
    do
        [[ ${x} == $2 ]] && return 0;
    done;
    return 1
}
_unpack_tar () 
{ 
    if [ "${y}" == "tar" ]; then
        $1 -dc "$srcdir$x" | tar xof -;
        _pipestatus="${PIPESTATUS[*]}";
        [[ "${_pipestatus// /}" -eq 0 ]] || die "$myfail";
    else
        $1 -dc "${srcdir}${x}" > ${x%.*} || die "$myfail";
    fi
}
add_src_uri () 
{ 
    [[ -z $2 ]] && return;
    local a=$1;
    set -- mirror://gentoo http://dev.gentoo.org/~vapier/dist;
    SRC_URI="${SRC_URI} ${@/%//${a}}"
}
append-cflags () 
{ 
    [[ -z $* ]] && return 0;
    export CFLAGS="${CFLAGS} $*";
    return 0
}
append-cppflags () 
{ 
    [[ -z $* ]] && return 0;
    export CPPFLAGS="${CPPFLAGS} $*";
    return 0
}
append-cxxflags () 
{ 
    [[ -z $* ]] && return 0;
    export CXXFLAGS="${CXXFLAGS} $*";
    return 0
}
append-fflags () 
{ 
    [[ -z $* ]] && return 0;
    export FFLAGS="${FFLAGS} $*";
    export FCFLAGS="${FCFLAGS} $*";
    return 0
}
append-flags () 
{ 
    [[ -z $* ]] && return 0;
    append-cflags "$@";
    append-cxxflags "$@";
    append-fflags "$@";
    return 0
}
append-ldflags () 
{ 
    [[ -z $* ]] && return 0;
    local flag;
    for flag in "$@";
    do
        [[ ${flag} == -l* ]] && ewarn "Appending a library link instruction (${flag}); libraries to link to should not be passed through LDFLAGS";
    done;
    export LDFLAGS="${LDFLAGS} $*";
    return 0
}
append-lfs-flags () 
{ 
    [[ -n $@ ]] && die "append-lfs-flags takes no arguments";
    append-cppflags -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE
}
bindnow-flags () 
{ 
    eerror "QA: stop using the bindnow-flags function ... simply drop it from your ebuild";
    die "Stop using bindnow-flags."
}
built_with_use () 
{ 
    local hidden="no";
    if [[ $1 == "--hidden" ]]; then
        hidden="yes";
        shift;
    fi;
    local missing_action="die";
    if [[ $1 == "--missing" ]]; then
        missing_action=$2;
        shift;
        shift;
        case ${missing_action} in 
            true | false | die)

            ;;
            *)
                die "unknown action '${missing_action}'"
            ;;
        esac;
    fi;
    local opt=$1;
    [[ ${opt:0:1} = "-" ]] && shift || opt="-a";
    local PKG=$(best_version $1);
    [[ -z ${PKG} ]] && die "Unable to resolve $1 to an installed package";
    shift;
    local USEFILE=${ROOT}/var/db/pkg/${PKG}/USE;
    local IUSEFILE=${ROOT}/var/db/pkg/${PKG}/IUSE;
    if [[ ! -e ${USEFILE} ]] || [[ ! -e ${IUSEFILE} && ${hidden} == "no" ]]; then
        case ${missing_action} in 
            true)
                return 0
            ;;
            false)
                return 1
            ;;
            die)
                die "Unable to determine what USE flags $PKG was built with"
            ;;
        esac;
    fi;
    if [[ ${hidden} == "no" ]]; then
        local IUSE_BUILT=($(<"${IUSEFILE}"));
        local expand;
        for expand in $(echo ${USE_EXPAND} | tr '[:upper:]' '[:lower:]');
        do
            if [[ $1 == ${expand}_* ]]; then
                expand="";
                break;
            fi;
        done;
        if [[ -n ${expand} ]]; then
            if ! has $1 ${IUSE_BUILT[@]#[-+]}; then
                case ${missing_action} in 
                    true)
                        return 0
                    ;;
                    false)
                        return 1
                    ;;
                    die)
                        die "$PKG does not actually support the $1 USE flag!"
                    ;;
                esac;
            fi;
        fi;
    fi;
    local USE_BUILT=$(<${USEFILE});
    while [[ $# -gt 0 ]]; do
        if [[ ${opt} = "-o" ]]; then
            has $1 ${USE_BUILT} && return 0;
        else
            has $1 ${USE_BUILT} || return 1;
        fi;
        shift;
    done;
    [[ ${opt} = "-a" ]]
}
cdrom_get_cds () 
{ 
    local cdcnt=0;
    local f=;
    for f in "$@";
    do
        ((++cdcnt));
        export CDROM_CHECK_${cdcnt}="$f";
    done;
    export CDROM_TOTAL_CDS=${cdcnt};
    export CDROM_CURRENT_CD=1;
    if [[ -n ${CD_ROOT}${CD_ROOT_1} ]]; then
        local var=;
        cdcnt=0;
        while [[ ${cdcnt} -lt ${CDROM_TOTAL_CDS} ]]; do
            ((++cdcnt));
            var="CD_ROOT_${cdcnt}";
            [[ -z ${!var} ]] && var="CD_ROOT";
            if [[ -z ${!var} ]]; then
                eerror "You must either use just the CD_ROOT";
                eerror "or specify ALL the CD_ROOT_X variables.";
                eerror "In this case, you will need ${CDROM_TOTAL_CDS} CD_ROOT_X variables.";
                die "could not locate CD_ROOT_${cdcnt}";
            fi;
        done;
        export CDROM_ROOT=${CD_ROOT_1:-${CD_ROOT}};
        einfo "Found CD #${CDROM_CURRENT_CD} root at ${CDROM_ROOT}";
        export CDROM_SET=-1;
        for f in ${CDROM_CHECK_1//:/ };
        do
            ((++CDROM_SET));
            [[ -e ${CD_ROOT}/${f} ]] && break;
        done;
        export CDROM_MATCH=${f};
        return;
    fi;
    if [[ ${CDROM_TOTAL_CDS} -eq 1 ]]; then
        einfo "This ebuild will need the ${CDROM_NAME:-cdrom for ${PN}}";
        echo;
        einfo "If you do not have the CD, but have the data files";
        einfo "mounted somewhere on your filesystem, just export";
        einfo "the variable CD_ROOT so that it points to the";
        einfo "directory containing the files.";
        echo;
        einfo "For example:";
        einfo "export CD_ROOT=/mnt/cdrom";
        echo;
    else
        if [[ -n ${CDROM_NAME_SET} ]]; then
            cdcnt=0;
            while [[ ${cdcnt} -lt ${CDROM_TOTAL_CDS} ]]; do
                ((++cdcnt));
                export CDROM_NAME_${cdcnt}="${CDROM_NAME_SET[$((${cdcnt}-1))]}";
            done;
        fi;
        einfo "This package will need access to ${CDROM_TOTAL_CDS} cds.";
        cdcnt=0;
        while [[ ${cdcnt} -lt ${CDROM_TOTAL_CDS} ]]; do
            ((++cdcnt));
            var="CDROM_NAME_${cdcnt}";
            [[ ! -z ${!var} ]] && einfo " CD ${cdcnt}: ${!var}";
        done;
        echo;
        einfo "If you do not have the CDs, but have the data files";
        einfo "mounted somewhere on your filesystem, just export";
        einfo "the following variables so they point to the right place:";
        einfon "";
        cdcnt=0;
        while [[ ${cdcnt} -lt ${CDROM_TOTAL_CDS} ]]; do
            ((++cdcnt));
            echo -n " CD_ROOT_${cdcnt}";
        done;
        echo;
        einfo "Or, if you have all the files in the same place, or";
        einfo "you only have one cdrom, you can export CD_ROOT";
        einfo "and that place will be used as the same data source";
        einfo "for all the CDs.";
        echo;
        einfo "For example:";
        einfo "export CD_ROOT_1=/mnt/cdrom";
        echo;
    fi;
    export CDROM_SET="";
    export CDROM_CURRENT_CD=0;
    cdrom_load_next_cd
}
cdrom_load_next_cd () 
{ 
    local var;
    ((++CDROM_CURRENT_CD));
    unset CDROM_ROOT;
    var=CD_ROOT_${CDROM_CURRENT_CD};
    [[ -z ${!var} ]] && var="CD_ROOT";
    if [[ -z ${!var} ]]; then
        var="CDROM_CHECK_${CDROM_CURRENT_CD}";
        _cdrom_locate_file_on_cd ${!var};
    else
        export CDROM_ROOT=${!var};
    fi;
    einfo "Found CD #${CDROM_CURRENT_CD} root at ${CDROM_ROOT}"
}
check_license () 
{ 
    local lic=$1;
    if [ -z "${lic}" ]; then
        lic="${PORTDIR}/licenses/${LICENSE}";
    else
        if [ -e "${PORTDIR}/licenses/${lic}" ]; then
            lic="${PORTDIR}/licenses/${lic}";
        else
            if [ -e "${PWD}/${lic}" ]; then
                lic="${PWD}/${lic}";
            else
                if [ -e "${lic}" ]; then
                    lic="${lic}";
                fi;
            fi;
        fi;
    fi;
    [ ! -f "${lic}" ] && die "Could not find requested license ${lic}";
    local l="`basename ${lic}`";
    local shopts=$-;
    local alic;
    set -o noglob;
    for alic in ${ACCEPT_LICENSE};
    do
        if [[ ${alic} == ${l} ]]; then
            set +o noglob;
            set -${shopts};
            return 0;
        fi;
    done;
    set +o noglob;
    set -$shopts;
    local licmsg=$(emktemp);
    cat > ${licmsg}  <<-EOF
**********************************************************
The following license outlines the terms of use of this
package.  You MUST accept this license for installation to
continue.  When you are done viewing, hit 'q'.	If you
CTRL+C out of this, the install will not run!
**********************************************************

EOF

    cat ${lic} >> ${licmsg};
    ${PAGER:-less} ${licmsg} || die "Could not execute pager (${PAGER}) to accept ${lic}";
    einfon "Do you accept the terms of this license (${l})? [yes/no] ";
    read alic;
    case ${alic} in 
        yes | Yes | y | Y)
            return 0
        ;;
        *)
            echo;
            echo;
            echo;
            eerror "You MUST accept the license to continue!  Exiting!";
            die "Failed to accept license"
        ;;
    esac
}
create_ml_includes () 
{ 
    local dest=$1;
    shift;
    local basedirs=$(create_ml_includes-listdirs "$@");
    create_ml_includes-makedestdirs ${dest} ${basedirs};
    local file;
    for file in $(create_ml_includes-allfiles ${basedirs});
    do
        ( echo "/* Autogenerated by create_ml_includes() in multilib.eclass */";
        local dir;
        for dir in ${basedirs};
        do
            if [[ -f ${D}/${dir}/${file} ]]; then
                echo "";
                local sym=$(create_ml_includes-sym_for_dir ${dir} "$@");
                if [[ ${sym/=} != "${sym}" ]]; then
                    echo "#if ${sym}";
                else
                    if [[ ${sym::1} == "!" ]]; then
                        echo "#ifndef ${sym:1}";
                    else
                        echo "#ifdef ${sym}";
                    fi;
                fi;
                echo "# include <$(create_ml_includes-absolute ${dir}/${file})>";
                echo "#endif /* ${sym} */";
            fi;
        done ) > "${D}/${dest}/${file}";
    done
}
create_ml_includes-absolute () 
{ 
    local dst="$(create_ml_includes-tidy_path $1)";
    dst=(${dst//\// });
    local i;
    for ((i=0; i<${#dst[*]}; i++))
    do
        [ "${dst[i]}" == "include" ] && break;
    done;
    local strip_upto=$i;
    for ((i=strip_upto+1; i<${#dst[*]}-1; i++))
    do
        echo -n ${dst[i]}/;
    done;
    echo -n ${dst[i]}
}
create_ml_includes-allfiles () 
{ 
    [[ -z ${ED} ]] && local ED=${D};
    local basedir file;
    for basedir in "$@";
    do
        for file in $(find "${ED}"/${basedir} -type f);
        do
            echo ${file/${ED}\/${basedir}\//};
        done;
    done | sort | uniq
}
create_ml_includes-listdirs () 
{ 
    local dirs;
    local data;
    for data in "$@";
    do
        dirs="${dirs} ${data/*:/}";
    done;
    echo ${dirs:1}
}
create_ml_includes-makedestdirs () 
{ 
    local dest=$1;
    shift;
    local basedirs=$@;
    [[ -z ${ED} ]] && local ED=${D};
    dodir ${dest};
    local basedir;
    for basedir in ${basedirs};
    do
        local dir;
        for dir in $(find "${ED}"/${basedir} -type d);
        do
            dodir ${dest}/${dir/${ED}\/${basedir}/};
        done;
    done
}
create_ml_includes-sym_for_dir () 
{ 
    local dir=$1;
    shift;
    local data;
    for data in "$@";
    do
        if [[ ${data} == *:${dir} ]]; then
            echo ${data/:*/};
            return 0;
        fi;
    done;
    echo "Shouldn't be here -- create_ml_includes-sym_for_dir $1 $@";
    exit 1
}
create_ml_includes-tidy_path () 
{ 
    local removed=$1;
    if [ -n "${removed}" ]; then
        while [ "${removed}" != "${removed/\/\//\/}" ]; do
            removed=${removed/\/\//\/};
        done;
        while [ "${removed}" != "${removed//\/.\//\/}" ]; do
            removed=${removed//\/.\//\/};
        done;
        [ "${removed##*/}" = "." ] && removed=${removed%/*};
        while [ "${removed}" != "${removed//\/..\/}" ]; do
            local p1="${removed%%\/..\/*}";
            local p2="${removed#*\/..\/}";
            removed="${p1%\/*}/${p2}";
        done;
        [ "${removed##*/}" = ".." ] && removed=${removed%/*/*};
        [ "${removed##*/}" = "" ] && removed=${removed%/*};
        echo ${removed};
    fi
}
darwintoolize () 
{ 
    ewarn "darwintoolize() is deprecated, please just use elibtoolize()!";
    elibtoolize
}
delete_all_version_separators () 
{ 
    __versionator_shopt_toggle on;
    replace_all_version_separators "" "${1}";
    __versionator_shopt_toggle off
}
delete_version_separator () 
{ 
    __versionator_shopt_toggle on;
    replace_version_separator "${1}" "" "${2}";
    __versionator_shopt_toggle off
}
dlopen_lib () 
{ 
    if [[ ${CHOST} == *-linux-gnu || ${CHOST} == *-linux-uclibc ]]; then
        echo "-ldl";
    fi
}
doicon () 
{ 
    ( local i j ret;
    insinto /usr/share/pixmaps;
    for i in "$@";
    do
        if [[ -f ${i} ]]; then
            doins "${i}";
            ((ret+=$?));
        else
            if [[ -d ${i} ]]; then
                for j in "${i}"/*.png;
                do
                    doins "${j}";
                    ((ret+=$?));
                done;
            else
                ((++ret));
            fi;
        fi;
    done;
    exit ${ret} )
}
domenu () 
{ 
    ( local i j ret=0;
    insinto /usr/share/applications;
    for i in "$@";
    do
        if [[ -f ${i} ]]; then
            doins "${i}";
            ((ret+=$?));
        else
            if [[ -d ${i} ]]; then
                for j in "${i}"/*.desktop;
                do
                    doins "${j}";
                    ((ret+=$?));
                done;
            else
                ((++ret));
            fi;
        fi;
    done;
    exit ${ret} )
}
ebeep () 
{ 
    local n;
    if [[ -z ${EBEEP_IGNORE} ]]; then
        for ((n=1 ; n <= ${1:-5} ; n++))
        do
            echo -ne "\a";
            sleep 0.1 &>/dev/null;
            sleep 0,1 &>/dev/null;
            echo -ne "\a";
            sleep 1;
        done;
    fi
}
ecvs_clean () 
{ 
    [[ -z $* ]] && set -- .;
    find "$@" -type d -name 'CVS' -prune -print0 | xargs -0 rm -rf;
    find "$@" -type f -name '.cvs*' -print0 | xargs -0 rm -rf
}
edos2unix () 
{ 
    echo "$@" | xargs sed -i 's/\r$//'
}
egetent () 
{ 
    case ${CHOST} in 
        *-darwin[678])
            case "$2" in 
                *[!0-9]*)
                    nidump $1 . | awk -F":" "{ if (\$1 ~ /^$2$/) {print \$0;exit;} }"
                ;;
                *)
                    nidump $1 . | awk -F":" "{ if (\$3 == $2) {print \$0;exit;} }"
                ;;
            esac
        ;;
        *-darwin*)
            local mytype=$1;
            [[ "passwd" == $mytype ]] && mytype="Users";
            [[ "group" == $mytype ]] && mytype="Groups";
            case "$2" in 
                *[!0-9]*)
                    dscl . -read /$mytype/$2 2> /dev/null | grep RecordName
                ;;
                *)
                    local mykey="UniqueID";
                    [[ $mytype == "Groups" ]] && mykey="PrimaryGroupID";
                    dscl . -search /$mytype $mykey $2 2> /dev/null
                ;;
            esac
        ;;
        *-freebsd* | *-dragonfly*)
            local opts action="user";
            [[ $1 == "passwd" ]] || action="group";
            if [[ $2 == [[:digit:]]* ]]; then
                [[ ${action} == "user" ]] && opts="-u" || opts="-g";
            fi;
            pw show ${action} ${opts} "$2" -q
        ;;
        *-netbsd* | *-openbsd*)
            grep "$2:\*:" /etc/$1
        ;;
        *)
            type -p nscd &>/dev/null && nscd -i "$1";
            getent "$1" "$2"
        ;;
    esac
}
egethome () 
{ 
    ent=$(egetent passwd $1);
    case ${CHOST} in 
        *-darwin* | *-freebsd* | *-dragonfly*)
            echo ${ent} | cut -d: -f9
        ;;
        *)
            echo ${ent} | cut -d: -f6
        ;;
    esac
}
egetshell () 
{ 
    ent=$(egetent passwd "$1");
    case ${CHOST} in 
        *-darwin* | *-freebsd* | *-dragonfly*)
            echo ${ent} | cut -d: -f10
        ;;
        *)
            echo ${ent} cut -d: -f7
        ;;
    esac
}
elibtoolize () 
{ 
    local x=;
    local y=;
    local do_portage="no";
    local do_reversedeps="no";
    local do_only_patches="no";
    local do_uclibc="yes";
    local deptoremove=;
    local my_dirlist=;
    local elt_patches="install-sh ltmain portage relink max_cmd_len sed test tmp cross as-needed";
    local start_dir=${PWD};
    my_dirlist=$(ELT_find_ltmain_sh);
    for x in "$@";
    do
        case "${x}" in 
            "--portage")
                do_portage="yes"
            ;;
            "--reverse-deps")
                do_reversedeps="yes";
                elt_patches="${elt_patches} fix-relink"
            ;;
            "--patch-only")
                do_only_patches="yes"
            ;;
            "^--remove-internal-dep="*)
                deptoremove=$(echo "${x}" | sed -e 's|--remove-internal-dep=||');
                [[ -n ${deptoremove} ]] && elt_patches="${elt_patches} rem-int-dep"
            ;;
            "--shallow")
                if [[ -f ${S}/ltmain.sh ]]; then
                    my_dirlist=${S};
                else
                    my_dirlist=;
                fi
            ;;
            "--no-uclibc")
                do_uclibc="no"
            ;;
            *)
                eerror "Invalid elibtoolize option: ${x}";
                die "elibtoolize called with ${x} ??"
            ;;
        esac;
    done;
    [[ ${do_uclibc} == "yes" ]] && elt_patches="${elt_patches} uclibc-conf uclibc-ltconf";
    [[ ${CHOST} == *"-freebsd"* ]] && elt_patches="${elt_patches} fbsd-conf fbsd-ltconf";
    [[ ${CHOST} == *"-darwin"* ]] && elt_patches="${elt_patches} darwin-ltconf darwin-ltmain";
    for x in ${my_dirlist};
    do
        local tmp=$(echo "${x}" | sed -e "s|${WORKDIR}||");
        export ELT_APPLIED_PATCHES=;
        export ELT_LTMAIN_SH="${x}/ltmain.sh";
        [[ -f ${x}/.elibtoolized ]] && continue;
        cd ${x};
        einfo "Running elibtoolize in: $(echo "/${tmp}" | sed -e 's|//|/|g; s|^/||')";
        for y in ${elt_patches};
        do
            local ret=0;
            case "${y}" in 
                "portage")
                    if [[ -z $(grep 'We do not want portage' "${x}/ltmain.sh") ]]; then
                        ELT_walk_patches "${x}/ltmain.sh" "${y}";
                        ret=$?;
                    fi
                ;;
                "rem-int-dep")
                    ELT_walk_patches "${x}/ltmain.sh" "${y}" "${deptoremove}";
                    ret=$?
                ;;
                "fix-relink")
                    if [[ -n $(grep 'inst_prefix_dir' "${x}/ltmain.sh") ]]; then
                        ELT_walk_patches "${x}/ltmain.sh" "${y}";
                        ret=$?;
                    fi
                ;;
                "max_cmd_len")
                    if [[ -n $(grep 'max_cmd_len' "${x}/ltmain.sh") ]]; then
                        ELT_walk_patches "${x}/ltmain.sh" "${y}";
                        ret=$?;
                    fi
                ;;
                "as-needed")
                    ELT_walk_patches "${x}/ltmain.sh" "${y}";
                    ret=$?
                ;;
                "uclibc-conf")
                    if [[ -e ${x}/configure && -n $(grep 'Transform linux' "${x}/configure") ]]; then
                        ELT_walk_patches "${x}/configure" "${y}";
                        ret=$?;
                    else
                        if [[ ! -e ${x}/configure && -e ${x}/../configure && -n $(grep 'Transform linux' "${x}/../configure") ]]; then
                            ELT_walk_patches "${x}/../configure" "${y}";
                            ret=$?;
                        fi;
                    fi
                ;;
                "uclibc-ltconf")
                    if [[ -s ${x}/ltconfig ]]; then
                        ELT_walk_patches "${x}/ltconfig" "${y}";
                        ret=$?;
                    fi
                ;;
                "fbsd-conf")
                    if [[ -e ${x}/configure && -n $(grep 'version_type=freebsd-' "${x}/configure") ]]; then
                        ELT_walk_patches "${x}/configure" "${y}";
                        ret=$?;
                    else
                        if [[ ! -e ${x}/configure && -e ${x}/../configure && -n $(grep 'version_type=freebsd-' "${x}/../configure") ]]; then
                            ELT_walk_patches "${x}/../configure" "${y}";
                            ret=$?;
                        fi;
                    fi
                ;;
                "fbsd-ltconf")
                    if [[ -s ${x}/ltconfig ]]; then
                        ELT_walk_patches "${x}/ltconfig" "${y}";
                        ret=$?;
                    fi
                ;;
                "darwin-ltconf")
                    if [[ -s ${x}/ltconfig ]]; then
                        ELT_walk_patches "${x}/ltconfig" "${y}";
                        ret=$?;
                    fi
                ;;
                "install-sh")
                    ELT_walk_patches "${x}/install-sh" "${y}";
                    ret=$?
                ;;
                "cross")
                    if tc-is-cross-compiler; then
                        ELT_walk_patches "${x}/ltmain.sh" "${y}";
                        ret=$?;
                    fi
                ;;
                *)
                    ELT_walk_patches "${x}/ltmain.sh" "${y}";
                    ret=$?
                ;;
            esac;
            if [[ ${ret} -ne 0 ]]; then
                case ${y} in 
                    "relink")
                        local version=$(ELT_libtool_version "${x}/ltmain.sh");
                        if [[ -z $(grep 'inst_prefix_dir' "${x}/ltmain.sh") && $(VER_to_int "${version}") -ge $(VER_to_int "1.4.0") ]]; then
                            ewarn "  Could not apply relink.patch!";
                        fi
                    ;;
                    "portage")
                        if [[ ${do_portage} == "yes" ]]; then
                            if [[ -z $(grep 'We do not want portage' "${x}/ltmain.sh") ]]; then
                                echo;
                                eerror "Portage patch requested, but failed to apply!";
                                eerror "Please bug azarah or vapier to add proper patch.";
                                die "Portage patch requested, but failed to apply!";
                            fi;
                        else
                            if [[ -n $(grep 'We do not want portage' "${x}/ltmain.sh") ]]; then
                                :;
                            else
                                local version=$( 									eval $(grep -e '^[[:space:]]*VERSION=' "${x}/ltmain.sh"); 									echo "${VERSION}");
                                echo;
                                eerror "Portage patch failed to apply (ltmain.sh version ${version})!";
                                eerror "Please bug azarah or vapier to add proper patch.";
                                die "Portage patch failed to apply!";
                            fi;
                            ELT_APPLIED_PATCHES="portage";
                        fi
                    ;;
                    "uclibc-"*)
                        [[ ${CHOST} == *"-uclibc" ]] && ewarn "  uClibc patch set '${y}' failed to apply!"
                    ;;
                    "fbsd-"*)
                        if [[ ${CHOST} == *"-freebsd"* ]]; then
                            if [[ -z $(grep 'Handle Gentoo/FreeBSD as it was Linux' 								"${x}/configure" "${x}/../configure" 2>/dev/null) ]]; then
                                eerror "  FreeBSD patch set '${y}' failed to apply!";
                                die "FreeBSD patch set '${y}' failed to apply!";
                            fi;
                        fi
                    ;;
                    "darwin-"*)
                        [[ ${CHOST} == *"-darwin"* ]] && ewarn "  Darwin patch set '${y}' failed to apply!"
                    ;;
                esac;
            fi;
        done;
        if [[ -z ${ELT_APPLIED_PATCHES} ]]; then
            if [[ ${do_portage} == "no" && ${do_reversedeps} == "no" && ${do_only_patches} == "no" && ${deptoremove} == "" ]]; then
                ewarn "Cannot apply any patches, please file a bug about this";
                die;
            fi;
        fi;
        [[ -f ${x}/libtool ]] && rm -f "${x}/libtool";
         >> "${x}/.elibtoolized";
    done;
    cd "${start_dir}"
}
emktemp () 
{ 
    local exe="touch";
    [[ $1 == -d ]] && exe="mkdir" && shift;
    local topdir=$1;
    if [[ -z ${topdir} ]]; then
        [[ -z ${T} ]] && topdir="/tmp" || topdir=${T};
    fi;
    if ! type -P mktemp > /dev/null; then
        local tmp=/;
        while [[ -e ${tmp} ]]; do
            tmp=${topdir}/tmp.${RANDOM}.${RANDOM}.${RANDOM};
        done;
        ${exe} "${tmp}" || ${exe} -p "${tmp}";
        echo "${tmp}";
    else
        if [[ ${exe} == "touch" ]]; then
            TMPDIR="${topdir}" mktemp -t tmp.XXXXXXXXXX;
        else
            TMPDIR="${topdir}" mktemp -dt tmp.XXXXXXXXXX;
        fi;
    fi
}
enewgroup () 
{ 
    case ${EBUILD_PHASE} in 
        unpack | compile | test | install)
            eerror "'enewgroup()' called from '${EBUILD_PHASE}()' which is not a pkg_* function.";
            eerror "Package fails at QA and at life.  Please file a bug.";
            die "Bad package!  enewgroup is only for use in pkg_* functions!"
        ;;
    esac;
    local egroup="$1";
    shift;
    if [ -z "${egroup}" ]; then
        eerror "No group specified !";
        die "Cannot call enewgroup without a group";
    fi;
    if [[ -n $(egetent group "${egroup}") ]]; then
        return 0;
    fi;
    einfo "Adding group '${egroup}' to your system ...";
    local opts=;
    local egid="$1";
    shift;
    if [ ! -z "${egid}" ]; then
        if [ "${egid}" -gt 0 ]; then
            if [ -z "`egetent group ${egid}`" ]; then
                if [[ "${CHOST}" == *-darwin* ]]; then
                    opts="${opts} ${egid}";
                else
                    opts="${opts} -g ${egid}";
                fi;
            else
                egid="next available; requested gid taken";
            fi;
        else
            eerror "Groupid given but is not greater than 0 !";
            die "${egid} is not a valid GID";
        fi;
    else
        egid="next available";
    fi;
    einfo " - Groupid: ${egid}";
    local eextra="$@";
    opts="${opts} ${eextra}";
    local oldsandbox="${SANDBOX_ON}";
    export SANDBOX_ON="0";
    case ${CHOST} in 
        *-darwin*)
            if [ ! -z "${eextra}" ]; then
                einfo "Extra options are not supported on Darwin/OS X yet";
                einfo "Please report the ebuild along with the info below";
                einfo "eextra: ${eextra}";
                die "Required function missing";
            fi;
            case ${egid} in 
                *[!0-9]*)
                    for ((egid = 101; egid <= 999; egid++))
                    do
                        [[ -z $(egetent group ${egid}) ]] && break;
                    done
                ;;
            esac;
            dscl . create /groups/${egroup} gid ${egid};
            dscl . create /groups/${egroup} passwd '*'
        ;;
        *-freebsd* | *-dragonfly*)
            case ${egid} in 
                *[!0-9]*)
                    for ((egid = 101; egid <= 999; egid++))
                    do
                        [[ -z $(egetent group ${egid}) ]] && break;
                    done
                ;;
            esac;
            pw groupadd ${egroup} -g ${egid} || die "enewgroup failed"
        ;;
        *-netbsd*)
            case ${egid} in 
                *[!0-9]*)
                    for ((egid = 101; egid <= 999; egid++))
                    do
                        [[ -z $(egetent group ${egid}) ]] && break;
                    done
                ;;
            esac;
            groupadd -g ${egid} ${egroup} || die "enewgroup failed"
        ;;
        *)
            groupadd ${opts} ${egroup} || die "enewgroup failed"
        ;;
    esac;
    export SANDBOX_ON="${oldsandbox}"
}
enewuser () 
{ 
    case ${EBUILD_PHASE} in 
        unpack | compile | test | install)
            eerror "'enewuser()' called from '${EBUILD_PHASE}()' which is not a pkg_* function.";
            eerror "Package fails at QA and at life.  Please file a bug.";
            die "Bad package!  enewuser is only for use in pkg_* functions!"
        ;;
    esac;
    local euser=$1;
    shift;
    if [[ -z ${euser} ]]; then
        eerror "No username specified !";
        die "Cannot call enewuser without a username";
    fi;
    if [[ -n $(egetent passwd "${euser}") ]]; then
        return 0;
    fi;
    einfo "Adding user '${euser}' to your system ...";
    local opts=;
    local euid=$1;
    shift;
    if [[ -n ${euid} && ${euid} != -1 ]]; then
        if [[ ${euid} -gt 0 ]]; then
            if [[ -n $(egetent passwd ${euid}) ]]; then
                euid="next";
            fi;
        else
            eerror "Userid given but is not greater than 0 !";
            die "${euid} is not a valid UID";
        fi;
    else
        euid="next";
    fi;
    if [[ ${euid} == "next" ]]; then
        for ((euid = 101; euid <= 999; euid++))
        do
            [[ -z $(egetent passwd ${euid}) ]] && break;
        done;
    fi;
    opts="${opts} -u ${euid}";
    einfo " - Userid: ${euid}";
    local eshell=$1;
    shift;
    if [[ ! -z ${eshell} ]] && [[ ${eshell} != "-1" ]]; then
        if [[ ! -e ${ROOT}${eshell} ]]; then
            eerror "A shell was specified but it does not exist !";
            die "${eshell} does not exist in ${ROOT}";
        fi;
        if [[ ${eshell} == */false || ${eshell} == */nologin ]]; then
            eerror "Do not specify ${eshell} yourself, use -1";
            die "Pass '-1' as the shell parameter";
        fi;
    else
        for shell in /sbin/nologin /usr/sbin/nologin /bin/false /usr/bin/false /dev/null;
        do
            [[ -x ${ROOT}${shell} ]] && break;
        done;
        if [[ ${shell} == "/dev/null" ]]; then
            eerror "Unable to identify the shell to use, proceeding with userland default.";
            case ${USERLAND} in 
                GNU)
                    shell="/bin/false"
                ;;
                BSD)
                    shell="/sbin/nologin"
                ;;
                Darwin)
                    shell="/usr/sbin/nologin"
                ;;
                *)
                    die "Unable to identify the default shell for userland ${USERLAND}"
                ;;
            esac;
        fi;
        eshell=${shell};
    fi;
    einfo " - Shell: ${eshell}";
    opts="${opts} -s ${eshell}";
    local ehome=$1;
    shift;
    if [[ -z ${ehome} ]] || [[ ${ehome} == "-1" ]]; then
        ehome="/dev/null";
    fi;
    einfo " - Home: ${ehome}";
    opts="${opts} -d ${ehome}";
    local egroups=$1;
    shift;
    if [[ ! -z ${egroups} ]]; then
        local oldifs=${IFS};
        local defgroup="" exgroups="";
        export IFS=",";
        for g in ${egroups};
        do
            export IFS=${oldifs};
            if [[ -z $(egetent group "${g}") ]]; then
                eerror "You must add group ${g} to the system first";
                die "${g} is not a valid GID";
            fi;
            if [[ -z ${defgroup} ]]; then
                defgroup=${g};
            else
                exgroups="${exgroups},${g}";
            fi;
            export IFS=",";
        done;
        export IFS=${oldifs};
        opts="${opts} -g ${defgroup}";
        if [[ ! -z ${exgroups} ]]; then
            opts="${opts} -G ${exgroups:1}";
        fi;
    else
        egroups="(none)";
    fi;
    einfo " - Groups: ${egroups}";
    local oldsandbox=${SANDBOX_ON};
    export SANDBOX_ON="0";
    case ${CHOST} in 
        *-darwin*)
            if [[ -z $@ ]]; then
                dscl . create /users/${euser} uid ${euid};
                dscl . create /users/${euser} shell ${eshell};
                dscl . create /users/${euser} home ${ehome};
                dscl . create /users/${euser} realname "added by portage for ${PN}";
                local oldifs=${IFS};
                export IFS=",";
                for g in ${egroups};
                do
                    dscl . merge /groups/${g} users ${euser};
                done;
                export IFS=${oldifs};
            else
                einfo "Extra options are not supported on Darwin yet";
                einfo "Please report the ebuild along with the info below";
                einfo "eextra: $@";
                die "Required function missing";
            fi
        ;;
        *-freebsd* | *-dragonfly*)
            if [[ -z $@ ]]; then
                pw useradd ${euser} ${opts} -c "added by portage for ${PN}" die "enewuser failed";
            else
                einfo " - Extra: $@";
                pw useradd ${euser} ${opts} "$@" || die "enewuser failed";
            fi
        ;;
        *-netbsd*)
            if [[ -z $@ ]]; then
                useradd ${opts} ${euser} || die "enewuser failed";
            else
                einfo " - Extra: $@";
                useradd ${opts} ${euser} "$@" || die "enewuser failed";
            fi
        ;;
        *-openbsd*)
            if [[ -z $@ ]]; then
                useradd -u ${euid} -s ${eshell} -d ${ehome} -c "Added by portage for ${PN}" -g ${egroups} ${euser} || die "enewuser failed";
            else
                einfo " - Extra: $@";
                useradd -u ${euid} -s ${eshell} -d ${ehome} -c "Added by portage for ${PN}" -g ${egroups} ${euser} "$@" || die "enewuser failed";
            fi
        ;;
        *)
            if [[ -z $@ ]]; then
                useradd ${opts} ${euser} -c "added by portage for ${PN}" || die "enewuser failed";
            else
                einfo " - Extra: $@";
                useradd ${opts} ${euser} "$@" || die "enewuser failed";
            fi
        ;;
    esac;
    if [[ ! -e ${ROOT}/${ehome} ]]; then
        einfo " - Creating ${ehome} in ${ROOT}";
        mkdir -p "${ROOT}/${ehome}";
        chown ${euser} "${ROOT}/${ehome}";
        chmod 755 "${ROOT}/${ehome}";
    fi;
    export SANDBOX_ON=${oldsandbox}
}
epatch () 
{ 
    function _epatch_draw_line () 
    { 
        [[ -z $1 ]] && set "$(printf "%65s" '')";
        echo "${1//?/=}"
    };
    function _epatch_assert () 
    { 
        local _pipestatus=${PIPESTATUS[*]};
        [[ ${_pipestatus// /} -eq 0 ]]
    };
    local PIPE_CMD="";
    local STDERR_TARGET="${T}/$$.out";
    local PATCH_TARGET="${T}/$$.patch";
    local PATCH_SUFFIX="";
    local SINGLE_PATCH="no";
    local x="";
    unset P4CONFIG P4PORT P4USER;
    if [ "$#" -gt 1 ]; then
        local m="";
        for m in "$@";
        do
            epatch "${m}";
        done;
        return 0;
    fi;
    if [ -n "$1" -a -f "$1" ]; then
        SINGLE_PATCH="yes";
        local EPATCH_SOURCE="$1";
        local EPATCH_SUFFIX="${1##*\.}";
    else
        if [ -n "$1" -a -d "$1" ]; then
            if [ "${EPATCH_FORCE}" = "yes" ] && [ -z "${EPATCH_SUFFIX}" ]; then
                local EPATCH_SOURCE="$1/*";
            else
                local EPATCH_SOURCE="$1/*.${EPATCH_SUFFIX}";
            fi;
        else
            if [[ ! -d ${EPATCH_SOURCE} ]] || [[ -n $1 ]]; then
                if [ -n "$1" -a "${EPATCH_SOURCE}" = "${WORKDIR}/patch" ]; then
                    EPATCH_SOURCE="$1";
                fi;
                echo;
                eerror "Cannot find \$EPATCH_SOURCE!  Value for \$EPATCH_SOURCE is:";
                eerror;
                eerror "  ${EPATCH_SOURCE}";
                eerror "  ( ${EPATCH_SOURCE##*/} )";
                echo;
                die "Cannot find \$EPATCH_SOURCE!";
            fi;
            local EPATCH_SOURCE="${EPATCH_SOURCE}/*.${EPATCH_SUFFIX}";
        fi;
    fi;
    case ${EPATCH_SUFFIX##*\.} in 
        xz)
            PIPE_CMD="xz -dc";
            PATCH_SUFFIX="xz"
        ;;
        lzma)
            PIPE_CMD="lzma -dc";
            PATCH_SUFFIX="lzma"
        ;;
        bz2)
            PIPE_CMD="bzip2 -dc";
            PATCH_SUFFIX="bz2"
        ;;
        gz | Z | z)
            PIPE_CMD="gzip -dc";
            PATCH_SUFFIX="gz"
        ;;
        ZIP | zip)
            PIPE_CMD="unzip -p";
            PATCH_SUFFIX="zip"
        ;;
        *)
            PIPE_CMD="cat";
            PATCH_SUFFIX="patch"
        ;;
    esac;
    if [ "${SINGLE_PATCH}" = "no" ]; then
        einfo "${EPATCH_MULTI_MSG}";
    fi;
    for x in ${EPATCH_SOURCE};
    do
        if [ -f ${x} ] && ( [ "${SINGLE_PATCH}" = "yes" -o "${x/_all_}" != "${x}" -o "${x/_${ARCH}_}" != "${x}" ] || [ "${EPATCH_FORCE}" = "yes" ] ); then
            local count=0;
            local popts="${EPATCH_OPTS}";
            local patchname=${x##*/};
            if [ -n "${EPATCH_EXCLUDE}" ]; then
                if [ "${EPATCH_EXCLUDE/${patchname}}" != "${EPATCH_EXCLUDE}" ]; then
                    continue;
                fi;
            fi;
            if [ "${SINGLE_PATCH}" = "yes" ]; then
                if [ -n "${EPATCH_SINGLE_MSG}" ]; then
                    einfo "${EPATCH_SINGLE_MSG}";
                else
                    einfo "Applying ${patchname} ...";
                fi;
            else
                einfo "  ${patchname} ...";
            fi;
            echo "***** ${patchname} *****" > ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/};
            echo >> ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/};
            if [[ ${PATCH_SUFFIX} != "patch" ]]; then
                echo -n "PIPE_COMMAND:	" >> ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/};
                echo "${PIPE_CMD} ${x} > ${PATCH_TARGET}" >> ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/};
                if ! ( ${PIPE_CMD} ${x} > ${PATCH_TARGET} ) >> ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/} 2>&1; then
                    echo;
                    eerror "Could not extract patch!";
                    count=5;
                    break;
                fi;
            else
                PATCH_TARGET="${x}";
            fi;
            local abs_paths=$(egrep -n '^[-+]{3} /' "${PATCH_TARGET}" | awk '$2 != "/dev/null" { print }');
            if [[ -n ${abs_paths} ]]; then
                count=1;
                echo "NOTE: skipping -p0 due to absolute paths in patch:" >> ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/};
                echo "${abs_paths}" >> ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/};
            fi;
            while [ "${count}" -lt 5 ]; do
                _epatch_draw_line "***** ${patchname} *****" >> ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/};
                echo >> ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/};
                echo -n "PATCH COMMAND:	 " >> ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/};
                echo "patch -p${count} ${popts} < ${PATCH_TARGET}" >> ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/};
                echo >> ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/};
                _epatch_draw_line "***** ${patchname} *****" >> ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/};
                if ( cat ${PATCH_TARGET} | patch -p${count} ${popts} --dry-run -f;
                _epatch_assert ) >> ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/} 2>&1; then
                    _epatch_draw_line "***** ${patchname} *****" > ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/}.real;
                    echo >> ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/}.real;
                    echo "ACTUALLY APPLYING ${patchname} ..." >> ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/}.real;
                    echo >> ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/}.real;
                    _epatch_draw_line "***** ${patchname} *****" >> ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/}.real;
                    cat ${PATCH_TARGET} | patch -p${count} ${popts} >> ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/}.real 2>&1;
                    _epatch_assert;
                    if [ "$?" -ne 0 ]; then
                        cat ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/}.real >> ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/};
                        echo;
                        eerror "A dry-run of patch command succeeded, but actually";
                        eerror "applying the patch failed!";
                        count=5;
                    fi;
                    rm -f ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/}.real;
                    break;
                fi;
                count=$((count + 1));
            done;
            if [ "${PATCH_SUFFIX}" != "patch" ]; then
                rm -f ${PATCH_TARGET};
            fi;
            if [ "${count}" -eq 5 ]; then
                echo;
                eerror "Failed Patch: ${patchname} !";
                eerror " ( ${PATCH_TARGET} )";
                eerror;
                eerror "Include in your bugreport the contents of:";
                eerror;
                eerror "  ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/}";
                echo;
                die "Failed Patch: ${patchname}!";
            fi;
            rm -f ${STDERR_TARGET%/*}/${patchname}-${STDERR_TARGET##*/};
            eend 0;
        fi;
    done;
    if [ "${SINGLE_PATCH}" = "no" ]; then
        einfo "Done with patching";
    fi
}
epatch_user () 
{ 
    [[ $# -ne 0 ]] && die "epatch_user takes no options";
    local EPATCH_SOURCE check base=${PORTAGE_CONFIGROOT}/etc/portage/patches;
    for check in {${CATEGORY}/${PF},${CATEGORY}/${P},${CATEGORY}/${PN}};
    do
        EPATCH_SOURCE=${base}/${CTARGET}/${check};
        [[ -r ${EPATCH_SOURCE} ]] || EPATCH_SOURCE=${base}/${CHOST}/${check};
        [[ -r ${EPATCH_SOURCE} ]] || EPATCH_SOURCE=${base}/${check};
        if [[ -d ${EPATCH_SOURCE} ]]; then
            EPATCH_SOURCE=${EPATCH_SOURCE} EPATCH_SUFFIX="patch" EPATCH_FORCE="yes" EPATCH_MULTI_MSG="Applying user patches from ${EPATCH_SOURCE} ..." epatch;
            break;
        fi;
    done
}
epause () 
{ 
    [[ -z ${EPAUSE_IGNORE} ]] && sleep ${1:-5}
}
epunt_cxx () 
{ 
    local dir=$1;
    [[ -z ${dir} ]] && dir=${S};
    ebegin "Removing useless C++ checks";
    local f;
    find "${dir}" -name configure | while read f; do
        patch --no-backup-if-mismatch -p0 "${f}" "${PORTDIR}/eclass/ELT-patches/nocxx/nocxx.patch" > /dev/null;
    done;
    eend 0
}
esvn_clean () 
{ 
    [[ -z $* ]] && set -- .;
    find "$@" -type d -name '.svn' -prune -print0 | xargs -0 rm -rf
}
filter-flags () 
{ 
    _filter-hardened "$@";
    _filter-var CFLAGS "$@";
    _filter-var CPPFLAGS "$@";
    _filter-var CXXFLAGS "$@";
    _filter-var FFLAGS "$@";
    _filter-var FCFLAGS "$@";
    return 0
}
filter-ldflags () 
{ 
    _filter-var LDFLAGS "$@";
    return 0
}
filter-lfs-flags () 
{ 
    [[ -n $@ ]] && die "filter-lfs-flags takes no arguments";
    filter-flags -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE
}
filter-mfpmath () 
{ 
    local orig_mfpmath new_math prune_math;
    orig_mfpmath=$(get-flag -mfpmath);
    new_math=$(get-flag mfpmath);
    new_math=" ${new_math//,/ } ";
    prune_math="";
    for prune_math in "$@";
    do
        new_math=${new_math/ ${prune_math} / };
    done;
    new_math=$(echo ${new_math});
    new_math=${new_math// /,};
    if [[ -z ${new_math} ]]; then
        filter-flags ${orig_mfpmath};
    else
        replace-flags ${orig_mfpmath} -mfpmath=${new_math};
    fi;
    return 0
}
find_unpackable_file () 
{ 
    local src=$1;
    if [[ -z ${src} ]]; then
        src=${DISTDIR}/${A};
    else
        if [[ -e ${DISTDIR}/${src} ]]; then
            src=${DISTDIR}/${src};
        else
            if [[ -e ${PWD}/${src} ]]; then
                src=${PWD}/${src};
            else
                if [[ -e ${src} ]]; then
                    src=${src};
                fi;
            fi;
        fi;
    fi;
    [[ ! -e ${src} ]] && return 1;
    echo "${src}"
}
gcc-fullversion () 
{ 
    $(tc-getCC "$@") -dumpversion
}
gcc-major-version () 
{ 
    gcc-version "$@" | cut -f1 -d.
}
gcc-micro-version () 
{ 
    gcc-fullversion "$@" | cut -f3 -d. | cut -f1 -d-
}
gcc-minor-version () 
{ 
    gcc-version "$@" | cut -f2 -d.
}
gcc-specs-directive () 
{ 
    local directive subdname subdirective;
    directive="$(_gcc-specs-directive_raw $1)";
    while [[ ${directive} == *%\(*\)* ]]; do
        subdname=${directive/*%\(};
        subdname=${subdname/\)*};
        subdirective="$(_gcc-specs-directive_raw ${subdname})";
        directive="${directive//\%(${subdname})/${subdirective}}";
    done;
    echo "${directive}";
    return 0
}
gcc-specs-nostrict () 
{ 
    local directive;
    directive=$(gcc-specs-directive cc1);
    return $([[ "${directive/\{!fstrict-overflow:}" != "${directive}" ]])
}
gcc-specs-now () 
{ 
    local directive;
    directive=$(gcc-specs-directive link_command);
    return $([[ "${directive/\{!nonow:}" != "${directive}" ]])
}
gcc-specs-pie () 
{ 
    local directive;
    directive=$(gcc-specs-directive cc1);
    return $([[ "${directive/\{!nopie:}" != "${directive}" ]])
}
gcc-specs-relro () 
{ 
    local directive;
    directive=$(gcc-specs-directive link_command);
    return $([[ "${directive/\{!norelro:}" != "${directive}" ]])
}
gcc-specs-ssp () 
{ 
    local directive;
    directive=$(gcc-specs-directive cc1);
    return $([[ "${directive/\{!fno-stack-protector:}" != "${directive}" ]])
}
gcc-specs-ssp-to-all () 
{ 
    local directive;
    directive=$(gcc-specs-directive cc1);
    return $([[ "${directive/\{!fno-stack-protector-all:}" != "${directive}" ]])
}
gcc-version () 
{ 
    gcc-fullversion "$@" | cut -f1,2 -d.
}
gen_usr_ldscript () 
{ 
    local lib libdir=$(get_libdir) output_format="" auto=false suffix=$(get_libname);
    [[ -z ${ED+set} ]] && local ED=${D%/}${EPREFIX}/;
    tc-is-static-only && return;
    dodir /usr/${libdir};
    if [[ $1 == "-a" ]]; then
        auto=true;
        shift;
        dodir /${libdir};
    fi;
    output_format=$($(tc-getCC) ${CFLAGS} ${LDFLAGS} -Wl,--verbose 2>&1 | sed -n 's/^OUTPUT_FORMAT("\([^"]*\)",.*/\1/p');
    [[ -n ${output_format} ]] && output_format="OUTPUT_FORMAT ( ${output_format} )";
    for lib in "$@";
    do
        local tlib;
        if ${auto}; then
            lib="lib${lib}${suffix}";
        else
            [[ -r ${ED}/${libdir}/${lib} ]] || continue;
        fi;
        case ${CTARGET:-${CHOST}} in 
            *-darwin*)
                if ${auto}; then
                    tlib=$(scanmacho -qF'%S#F' "${ED}"/usr/${libdir}/${lib});
                else
                    tlib=$(scanmacho -qF'%S#F' "${ED}"/${libdir}/${lib});
                fi;
                [[ -z ${tlib} ]] && die "unable to read install_name from ${lib}";
                tlib=${tlib##*/};
                if ${auto}; then
                    mv "${ED}"/usr/${libdir}/${lib%${suffix}}.*${suffix#.} "${ED}"/${libdir}/ || die;
                    if [[ ${tlib} != ${lib%${suffix}}.*${suffix#.} ]]; then
                        mv "${ED}"/usr/${libdir}/${tlib%${suffix}}.*${suffix#.} "${ED}"/${libdir}/ || die;
                    fi;
                    rm -f "${ED}"/${libdir}/${lib};
                fi;
                if [[ ! -w "${ED}/${libdir}/${tlib}" ]]; then
                    chmod u+w "${ED}${libdir}/${tlib}";
                    local nowrite=yes;
                fi;
                install_name_tool -id "${EPREFIX}"/${libdir}/${tlib} "${ED}"/${libdir}/${tlib} || die "install_name_tool failed";
                [[ -n ${nowrite} ]] && chmod u-w "${ED}${libdir}/${tlib}";
                pushd "${ED}/usr/${libdir}" > /dev/null;
                ln -snf "../../${libdir}/${tlib}" "${lib}";
                popd > /dev/null
            ;;
            *-aix* | *-irix* | *64*-hpux* | *-interix* | *-winnt*)
                if ${auto}; then
                    mv "${ED}"/usr/${libdir}/${lib}* "${ED}"/${libdir}/ || die;
                    tlib=$(readlink "${ED}"/${libdir}/${lib});
                    tlib=${tlib##*/};
                    if [[ -z ${tlib} ]]; then
                        tlib=${lib};
                    else
                        rm -f "${ED}"/${libdir}/${lib};
                    fi;
                else
                    tlib=${lib};
                fi;
                pushd "${ED}/usr/${libdir}" > /dev/null;
                ln -snf "../../${libdir}/${tlib}" "${lib}";
                popd > /dev/null
            ;;
            hppa*-hpux*)
                if ${auto}; then
                    tlib=$(chatr "${ED}"/usr/${libdir}/${lib} | sed -n '/internal name:/{n;s/^ *//;p;q}');
                    [[ -z ${tlib} ]] && tlib=${lib};
                    tlib=${tlib##*/};
                    mv "${ED}"/usr/${libdir}/${lib}* "${ED}"/${libdir}/ || die;
                    if [[ ${tlib} != ${lib}* ]]; then
                        mv "${ED}"/usr/${libdir}/${tlib}* "${ED}"/${libdir}/ || die;
                    fi;
                    [[ ${tlib} != ${lib} ]] && rm -f "${ED}"/${libdir}/${lib};
                else
                    tlib=$(chatr "${ED}"/${libdir}/${lib} | sed -n '/internal name:/{n;s/^ *//;p;q}');
                    [[ -z ${tlib} ]] && tlib=${lib};
                    tlib=${tlib##*/};
                fi;
                pushd "${ED}"/usr/${libdir} > /dev/null;
                ln -snf "../../${libdir}/${tlib}" "${lib}";
                [[ ${tlib} != ${lib} ]] && ln -snf "../../${libdir}/${tlib}" "${tlib}";
                popd > /dev/null
            ;;
            *)
                if ${auto}; then
                    tlib=$(scanelf -qF'%S#F' "${ED}"/usr/${libdir}/${lib});
                    [[ -z ${tlib} ]] && die "unable to read SONAME from ${lib}";
                    mv "${ED}"/usr/${libdir}/${lib}* "${ED}"/${libdir}/ || die;
                    if [[ ${tlib} != ${lib}* ]]; then
                        mv "${ED}"/usr/${libdir}/${tlib}* "${ED}"/${libdir}/ || die;
                    fi;
                    rm -f "${ED}"/${libdir}/${lib};
                else
                    tlib=${lib};
                fi;
                cat > "${ED}/usr/${libdir}/${lib}"  <<-END_LDSCRIPT
/* GNU ld script
   Since Gentoo has critical dynamic libraries in /lib, and the static versions
   in /usr/lib, we need to have a "fake" dynamic lib in /usr/lib, otherwise we
   run into linking problems.  This "fake" dynamic lib is a linker script that
   redirects the linker to the real lib.  And yes, this works in the cross-
   compiling scenario as the sysroot-ed linker will prepend the real path.

   See bug http://bugs.gentoo.org/4411 for more info.
 */
${output_format}
GROUP ( ${EPREFIX}/${libdir}/${tlib} )
END_LDSCRIPT

            ;;
        esac
        fperms a+x "/usr/${libdir}/${lib}" || die "could not change perms on ${lib}";
    done
}
get-flag () 
{ 
    local f findflag="$1";
    for f in ${CFLAGS} ${CXXFLAGS} ${FFLAGS} ${FCFLAGS};
    do
        if [ "${f/${findflag}}" != "${f}" ]; then
            printf "%s\n" "${f/-${findflag}=}";
            return 0;
        fi;
    done;
    return 1
}
get_abi_ASFLAGS () 
{ 
    get_abi_var ASFLAGS "$@"
}
get_abi_CDEFINE () 
{ 
    get_abi_var CDEFINE "$@"
}
get_abi_CFLAGS () 
{ 
    get_abi_var CFLAGS "$@"
}
get_abi_CHOST () 
{ 
    get_abi_var CHOST "$@"
}
get_abi_CTARGET () 
{ 
    get_abi_var CTARGET "$@"
}
get_abi_FAKE_TARGETS () 
{ 
    get_abi_var FAKE_TARGETS "$@"
}
get_abi_LDFLAGS () 
{ 
    get_abi_var LDFLAGS "$@"
}
get_abi_LIBDIR () 
{ 
    get_abi_var LIBDIR "$@"
}
get_abi_var () 
{ 
    local flag=$1;
    local abi;
    if [ $# -gt 1 ]; then
        abi=${2};
    else
        if [ -n "${ABI}" ]; then
            abi=${ABI};
        else
            if [ -n "${DEFAULT_ABI}" ]; then
                abi=${DEFAULT_ABI};
            else
                abi="default";
            fi;
        fi;
    fi;
    local var="${flag}_${abi}";
    echo ${!var}
}
get_after_major_version () 
{ 
    __versionator_shopt_toggle on;
    echo $(get_version_component_range 2- "${1:-${PV}}" );
    __versionator_shopt_toggle off
}
get_all_abis () 
{ 
    local order="";
    if [[ -z ${MULTILIB_ABIS} ]]; then
        echo "default";
        return 0;
    fi;
    for x in ${MULTILIB_ABIS};
    do
        if [[ ${x} != ${DEFAULT_ABI} ]]; then
            order="${order:+${order} }${x}";
        fi;
    done;
    order="${order:+${order} }${DEFAULT_ABI}";
    echo ${order};
    return 0
}
get_all_libdirs () 
{ 
    local libdirs="lib";
    local abi;
    local dir;
    for abi in ${MULTILIB_ABIS};
    do
        [ "$(get_abi_LIBDIR ${abi})" != "lib" ] && libdirs="${libdirs} $(get_abi_LIBDIR ${abi})";
    done;
    echo "${libdirs}"
}
get_all_version_components () 
{ 
    __versionator_shopt_toggle on;
    local ver_str=${1:-${PV}} result result_idx=0;
    result=();
    if [[ "${VERSIONATOR_CACHE_VER_STR}" == "${ver_str}" ]]; then
        echo ${VERSIONATOR_CACHE_RESULT};
        __versionator_shopt_toggle off;
        return;
    fi;
    export VERSIONATOR_CACHE_VER_STR="${ver_str}";
    while [[ -n "$ver_str" ]]; do
        case "${ver_str:0:1}" in 
            [[:digit:]])
                result[$result_idx]="${ver_str%%[^[:digit:]]*}";
                ver_str="${ver_str##+([[:digit:]])}";
                result_idx=$(($result_idx + 1))
            ;;
            [-_.])
                result[$result_idx]="${ver_str:0:1}";
                ver_str="${ver_str:1}";
                result_idx=$(($result_idx + 1))
            ;;
            [[:alpha:]])
                local not_match="${ver_str##+([[:alpha:]])*([[:digit:]])}";
                result[$result_idx]=${ver_str:0:$((${#ver_str} - ${#not_match}))};
                ver_str="${not_match}";
                result_idx=$(($result_idx + 1))
            ;;
            *)
                result[$result_idx]="${ver_str:0:1}";
                ver_str="${ver_str:1}";
                result_idx=$(($result_idx + 1))
            ;;
        esac;
    done;
    export VERSIONATOR_CACHE_RESULT="${result[@]}";
    echo ${result[@]};
    __versionator_shopt_toggle off
}
get_bmake () 
{ 
    if [[ ${USERLAND} == *BSD ]]; then
        echo make;
    else
        if [[ ${USERLAND} == "Darwin" ]]; then
            echo bsdmake;
        else
            echo pmake;
        fi;
    fi
}
get_install_abis () 
{ 
    local order="";
    if [[ -z ${MULTILIB_ABIS} ]]; then
        echo "default";
        return 0;
    fi;
    if [[ ${EMULTILIB_PKG} == "true" ]]; then
        for x in ${MULTILIB_ABIS};
        do
            if [[ ${x} != "${DEFAULT_ABI}" ]]; then
                hasq ${x} ${ABI_DENY} || ordera="${ordera} ${x}";
            fi;
        done;
        hasq ${DEFAULT_ABI} ${ABI_DENY} || order="${ordera} ${DEFAULT_ABI}";
        if [[ -n ${ABI_ALLOW} ]]; then
            local ordera="";
            for x in ${order};
            do
                if hasq ${x} ${ABI_ALLOW}; then
                    ordera="${ordera} ${x}";
                fi;
            done;
            order=${ordera};
        fi;
    else
        order=${DEFAULT_ABI};
    fi;
    if [[ -z ${order} ]]; then
        die "The ABI list is empty.  Are you using a proper multilib profile?  Perhaps your USE flags or MULTILIB_ABIS are too restrictive for this package.";
    fi;
    echo ${order};
    return 0
}
get_last_version_component_index () 
{ 
    __versionator_shopt_toggle on;
    echo $(( $(get_version_component_count "${1:-${PV}}" ) - 1 ));
    __versionator_shopt_toggle off
}
get_libdir () 
{ 
    local CONF_LIBDIR;
    if [ -n "${CONF_LIBDIR_OVERRIDE}" ]; then
        echo ${CONF_LIBDIR_OVERRIDE};
    else
        get_abi_LIBDIR;
    fi
}
get_libdir_override () 
{ 
    if has_multilib_profile; then
        eerror "get_libdir_override called, but it shouldn't be needed with the new multilib approach.  Please file a bug at http://bugs.gentoo.org and assign it to eradicator@gentoo.org";
        exit 1;
    fi;
    CONF_LIBDIR="$1";
    CONF_LIBDIR_OVERRIDE="$1";
    LIBDIR_default="$1"
}
get_libname () 
{ 
    local libname;
    local ver=$1;
    case ${CHOST} in 
        *-cygwin | mingw* | *-mingw*)
            libname="dll"
        ;;
        *-darwin*)
            libname="dylib"
        ;;
        *-aix*)
            libname="a"
        ;;
        *-mint*)
            libname="irrelevant"
        ;;
        hppa*-hpux*)
            libname="sl"
        ;;
        *)
            libname="so"
        ;;
    esac;
    if [[ -z $* ]]; then
        echo ".${libname}";
    else
        for ver in "$@";
        do
            case ${CHOST} in 
                *-darwin*)
                    echo ".${ver}.${libname}"
                ;;
                *-aix*)
                    echo ".${libname}"
                ;;
                *-mint*)
                    echo ".${libname}"
                ;;
                *)
                    echo ".${libname}.${ver}"
                ;;
            esac;
        done;
    fi
}
get_major_version () 
{ 
    __versionator_shopt_toggle on;
    local c;
    c=($(get_all_version_components "${1:-${PV}}" ));
    echo ${c[0]};
    __versionator_shopt_toggle off
}
get_ml_incdir () 
{ 
    local dir=/usr/include;
    if [[ $# -gt 0 ]]; then
        incdir=$1;
        shift;
    fi;
    if [[ -z "${MULTILIB_ABIS}" ]]; then
        echo ${incdir};
        return 0;
    fi;
    local abi=${ABI-${DEFAULT_ABI}};
    if [[ $# -gt 0 ]]; then
        abi=$1;
        shift;
    fi;
    if [[ -d "${dir}/gentoo-multilib/${abi}" ]]; then
        echo ${dir}/gentoo-multilib/${abi};
    else
        echo ${dir};
    fi
}
get_modname () 
{ 
    local modname;
    local ver=$1;
    case ${CHOST} in 
        *-darwin*)
            modname="bundle"
        ;;
        *)
            modname="so"
        ;;
    esac;
    echo ".${modname}"
}
get_mounts () 
{ 
    local point= node= fs= opts= foo=;
    if [[ $(uname -s) == "Linux" ]]; then
        while read node point fs opts foo; do
            echo "${point} ${node} ${fs} ${opts}";
        done < /proc/mounts;
        return;
    fi;
    local IFS='	';
    LC_ALL=C mount -p | while read node point fs foo; do
        opts=${fs#* };
        fs=${fs%% *};
        echo "${point// /\040} ${node// /\040} ${fs%% *} ${opts// /\040}";
    done
}
get_multilibdir () 
{ 
    if has_multilib_profile; then
        eerror "get_multilibdir called, but it shouldn't be needed with the new multilib approach.  Please file a bug at http://bugs.gentoo.org and assign it to eradicator@gentoo.org";
        exit 1;
    fi;
    echo ${CONF_MULTILIBDIR:=lib32}
}
get_version_component_count () 
{ 
    __versionator_shopt_toggle on;
    local a;
    a=($(get_version_components "${1:-${PV}}" ));
    echo ${#a[@]};
    __versionator_shopt_toggle off
}
get_version_component_range () 
{ 
    __versionator_shopt_toggle on;
    local c v="${2:-${PV}}" range="${1}" range_start range_end i=-1 j=0;
    c=($(get_all_version_components ${v} ));
    range_start="${range%-*}";
    range_start="${range_start:-1}";
    range_end="${range#*-}";
    range_end="${range_end:-${#c[@]}}";
    while (( j < ${range_start} )); do
        i=$(($i + 1));
        [[ $i -gt ${#c[@]} ]] && __versionator_shopt_toggle off && return;
        [[ -n "${c[${i}]//[-._]}" ]] && j=$(($j + 1));
    done;
    while (( j <= ${range_end} )); do
        echo -n ${c[$i]};
        [[ $i -gt ${#c[@]} ]] && __versionator_shopt_toggle off && return;
        [[ -n "${c[${i}]//[-._]}" ]] && j=$(($j + 1));
        i=$(($i + 1));
    done;
    __versionator_shopt_toggle off
}
get_version_components () 
{ 
    __versionator_shopt_toggle on;
    local c="$(get_all_version_components "${1:-${PV}}")";
    c=(${c[@]//[-._]/ });
    echo ${c[@]};
    __versionator_shopt_toggle off
}
gnuconfig_do_update () 
{ 
    local configsubs_dir target targetlist file;
    [[ $# -eq 0 ]] && die "do not call gnuconfig_do_update; use gnuconfig_update";
    configsubs_dir=$(gnuconfig_findnewest);
    einfo "Using GNU config files from ${configsubs_dir}";
    for file in "$@";
    do
        if [[ ! -r ${configsubs_dir}/${file} ]]; then
            eerror "Can't read ${configsubs_dir}/${file}, skipping..";
            continue;
        fi;
        targetlist=$(find "${startdir}" -name "${file}");
        if [[ -n ${targetlist} ]]; then
            for target in ${targetlist};
            do
                [[ -L ${target} ]] && rm -f "${target}";
                einfo "  Updating ${target/$startdir\//}";
                cp -f "${configsubs_dir}/${file}" "${target}";
                eend $?;
            done;
        else
            ewarn "  No ${file} found in ${startdir}, skipping ...";
        fi;
    done;
    return 0
}
gnuconfig_findnewest () 
{ 
    local locations="
		/usr/share/gnuconfig/config.sub
		/usr/share/automake-1.9/config.sub
		/usr/share/automake-1.8/config.sub
		/usr/share/automake-1.7/config.sub
		/usr/share/automake-1.6/config.sub
		/usr/share/automake-1.5/config.sub
		/usr/share/automake-1.4/config.sub
		/usr/share/libtool/config.sub
	";
    grep -s '^timestamp' ${locations} | sort -n -t\' -k2 | tail -n 1 | sed 's,/config.sub:.*$,,'
}
gnuconfig_update () 
{ 
    local startdir;
    if [[ $1 == /* ]]; then
        startdir=$1;
        shift;
    else
        startdir=${S};
    fi;
    if [[ $# -gt 0 ]]; then
        gnuconfig_do_update "$@";
    else
        gnuconfig_do_update config.sub config.guess;
    fi;
    return $?
}
has_hardened () 
{ 
    ewarn "has_hardened: deprecated, please use gcc-specs-{relro,now}()!" 1>&2;
    test_version_info Hardened && return 0;
    [[ -f ${GCC_SPECS} && ${GCC_SPECS} != ${GCC_SPECS/hardened/} ]]
}
has_m32 () 
{ 
    [ "$(tc-arch)" = "amd64" ] && has_multilib_profile && return 0;
    local temp=$(emktemp);
    echo "int main() { return(0); }" > "${temp}".c;
    MY_CC=$(tc-getCC);
    ${MY_CC/ .*/} -m32 -o "$(emktemp)" "${temp}".c > /dev/null 2>&1;
    local ret=$?;
    rm -f "${temp}".c;
    [[ ${ret} != 1 ]] && return 0;
    return 1
}
has_m64 () 
{ 
    local temp="$(emktemp)";
    echo "int main() { return(0); }" > "${temp}".c;
    MY_CC=$(tc-getCC);
    ${MY_CC/ .*/} -m64 -o "$(emktemp)" "${temp}".c > /dev/null 2>&1;
    local ret=$?;
    rm -f "${temp}".c;
    [[ ${ret} != 1 ]] && return 0;
    return 1
}
has_multilib_profile () 
{ 
    [ -n "${MULTILIB_ABIS}" -a "${MULTILIB_ABIS}" != "${MULTILIB_ABIS/ /}" ]
}
has_pic () 
{ 
    ewarn "has_pic: deprecated, please use gcc-specs-pie()!" 1>&2;
    [[ ${CFLAGS/-fPIC} != ${CFLAGS} || ${CFLAGS/-fpic} != ${CFLAGS} ]] || gcc-specs-pie
}
has_pie () 
{ 
    ewarn "has_pie: deprecated, please use gcc-specs-pie()!" 1>&2;
    [[ ${CFLAGS/-fPIE} != ${CFLAGS} || ${CFLAGS/-fpie} != ${CFLAGS} ]] || gcc-specs-pie
}
has_ssp () 
{ 
    ewarn "has_ssp: deprecated, please use gcc-specs-ssp()!" 1>&2;
    [[ ${CFLAGS/-fstack-protector} != ${CFLAGS} || -n $(echo | $(tc-getCC) ${CFLAGS} -E -dM - | grep __SSP__) ]] || gcc-specs-ssp
}
has_ssp_all () 
{ 
    ewarn "has_ssp_all: deprecated, please use gcc-specs-ssp()!" 1>&2;
    [[ ${CFLAGS/-fstack-protector-all} != ${CFLAGS} || -n $(echo | $(tc-getCC) ${CFLAGS} -E -dM - | grep __SSP_ALL__) ]] || gcc-specs-ssp-to-all
}
is-flag () 
{ 
    is-flagq "$@" && echo true
}
is-flagq () 
{ 
    [[ -n $2 ]] && die "Usage: is-flag <flag>";
    _is_flagq CFLAGS $1 || _is_flagq CXXFLAGS $1 || _is_flagq FFLAGS $1 || _is_flagq FCFLAGS $1
}
is-ldflag () 
{ 
    is-ldflagq "$@" && echo true
}
is-ldflagq () 
{ 
    [[ -n $2 ]] && die "Usage: is-ldflag <flag>";
    _is_flagq LDFLAGS $1
}
is-login-disabled () 
{ 
    shell=$(egetshell "$1");
    case ${shell} in 
        /bin/false | /usr/bin/false | /sbin/nologin | /usr/sbin/nologin)
            return 0
        ;;
        *)
            return 1
        ;;
    esac
}
is_cross () 
{ 
    [[ ${CHOST} != ${CTARGET} ]]
}
is_final_abi () 
{ 
    has_multilib_profile || return 0;
    local ALL_ABIS=$(get_install_abis);
    local LAST_ABI=${ALL_ABIS/* /};
    [[ ${LAST_ABI} == ${ABI} ]]
}
make_desktop_entry () 
{ 
    [[ -z $1 ]] && eerror "make_desktop_entry: You must specify the executable" && return 1;
    local exec=${1};
    local name=${2:-${PN}};
    local icon=${3:-${PN}};
    local type=${4};
    local path=${5};
    if [[ -z ${type} ]]; then
        local catmaj=${CATEGORY%%-*};
        local catmin=${CATEGORY##*-};
        case ${catmaj} in 
            app)
                case ${catmin} in 
                    accessibility)
                        type=Accessibility
                    ;;
                    admin)
                        type=System
                    ;;
                    antivirus)
                        type=System
                    ;;
                    arch)
                        type=Archiving
                    ;;
                    backup)
                        type=Archiving
                    ;;
                    cdr)
                        type=DiscBurning
                    ;;
                    dicts)
                        type=Dictionary
                    ;;
                    doc)
                        type=Documentation
                    ;;
                    editors)
                        type=TextEditor
                    ;;
                    emacs)
                        type=TextEditor
                    ;;
                    emulation)
                        type=Emulator
                    ;;
                    laptop)
                        type=HardwareSettings
                    ;;
                    office)
                        type=Office
                    ;;
                    pda)
                        type=PDA
                    ;;
                    vim)
                        type=TextEditor
                    ;;
                    xemacs)
                        type=TextEditor
                    ;;
                    *)
                        type=
                    ;;
                esac
            ;;
            dev)
                type="Development"
            ;;
            games)
                case ${catmin} in 
                    action | fps)
                        type=ActionGame
                    ;;
                    arcade)
                        type=ArcadeGame
                    ;;
                    board)
                        type=BoardGame
                    ;;
                    emulation)
                        type=Emulator
                    ;;
                    kids)
                        type=KidsGame
                    ;;
                    puzzle)
                        type=LogicGame
                    ;;
                    roguelike)
                        type=RolePlaying
                    ;;
                    rpg)
                        type=RolePlaying
                    ;;
                    simulation)
                        type=Simulation
                    ;;
                    sports)
                        type=SportsGame
                    ;;
                    strategy)
                        type=StrategyGame
                    ;;
                    *)
                        type=
                    ;;
                esac;
                type="Game;${type}"
            ;;
            gnome)
                type="Gnome;GTK"
            ;;
            kde)
                type="KDE;Qt"
            ;;
            mail)
                type="Network;Email"
            ;;
            media)
                case ${catmin} in 
                    gfx)
                        type=Graphics
                    ;;
                    radio)
                        type=Tuner
                    ;;
                    sound)
                        type=Audio
                    ;;
                    tv)
                        type=TV
                    ;;
                    video)
                        type=Video
                    ;;
                    *)
                        type=
                    ;;
                esac;
                type="AudioVideo;${type}"
            ;;
            net)
                case ${catmin} in 
                    dialup)
                        type=Dialup
                    ;;
                    ftp)
                        type=FileTransfer
                    ;;
                    im)
                        type=InstantMessaging
                    ;;
                    irc)
                        type=IRCClient
                    ;;
                    mail)
                        type=Email
                    ;;
                    news)
                        type=News
                    ;;
                    nntp)
                        type=News
                    ;;
                    p2p)
                        type=FileTransfer
                    ;;
                    *)
                        type=
                    ;;
                esac;
                type="Network;${type}"
            ;;
            sci)
                case ${catmin} in 
                    astro*)
                        type=Astronomy
                    ;;
                    bio*)
                        type=Biology
                    ;;
                    calc*)
                        type=Calculator
                    ;;
                    chem*)
                        type=Chemistry
                    ;;
                    elec*)
                        type=Electronics
                    ;;
                    geo*)
                        type=Geology
                    ;;
                    math*)
                        type=Math
                    ;;
                    physics)
                        type=Physics
                    ;;
                    visual*)
                        type=DataVisualization
                    ;;
                    *)
                        type=
                    ;;
                esac;
                type="Science;${type}"
            ;;
            sys)
                type="System"
            ;;
            www)
                case ${catmin} in 
                    client)
                        type=WebBrowser
                    ;;
                    *)
                        type=
                    ;;
                esac;
                type="Network"
            ;;
            *)
                type=
            ;;
        esac;
    fi;
    if [ "${SLOT}" == "0" ]; then
        local desktop_name="${PN}";
    else
        local desktop_name="${PN}-${SLOT}";
    fi;
    local desktop="${T}/$(echo ${exec} | sed 's:[[:space:]/:]:_:g')-${desktop_name}.desktop";
    cat > "${desktop}"  <<-EOF
[Desktop Entry]
Name=${name}
Type=Application
Comment=${DESCRIPTION}
Exec=${exec}
TryExec=${exec%% *}
Icon=${icon}
Categories=${type};
EOF

    [[ -n ${path} ]] && echo "Path=${path}" >> "${desktop}";
    ( insinto /usr/share/applications;
    doins "${desktop}" )
}
make_session_desktop () 
{ 
    [[ -z $1 ]] && eerror "$0: You must specify the title" && return 1;
    [[ -z $2 ]] && eerror "$0: You must specify the command" && return 1;
    local title=$1;
    local command=$2;
    local desktop=${T}/${wm:-${PN}}.desktop;
    shift 2;
    cat > "${desktop}"  <<-EOF
[Desktop Entry]
Name=${title}
Comment=This session logs you into ${title}
Exec=${command} $*
TryExec=${command}
Type=XSession
EOF

    ( insinto /usr/share/xsessions;
    doins "${desktop}" )
}
make_wrapper () 
{ 
    local wrapper=$1 bin=$2 chdir=$3 libdir=$4 path=$5;
    local tmpwrapper=$(emktemp);
    cat > "${tmpwrapper}"  <<EOF
#!/bin/sh
cd "${chdir:-.}"
if [ -n "${libdir}" ] ; then
	if [ "\${LD_LIBRARY_PATH+set}" = "set" ] ; then
		export LD_LIBRARY_PATH="\${LD_LIBRARY_PATH}:${libdir}"
	else
		export LD_LIBRARY_PATH="${libdir}"
	fi
fi
exec ${bin} "\$@"
EOF

    chmod go+rx "${tmpwrapper}";
    if [[ -n ${path} ]]; then
        ( exeinto "${path}";
        newexe "${tmpwrapper}" "${wrapper}" ) || die;
    else
        newbin "${tmpwrapper}" "${wrapper}" || die;
    fi
}
multilib_env () 
{ 
    local CTARGET=${1:-${CTARGET}};
    case ${CTARGET} in 
        x86_64*)
            export CFLAGS_x86=${CFLAGS_x86--m32};
            export CHOST_x86=${CTARGET/x86_64/i686};
            export CTARGET_x86=${CHOST_x86};
            export CDEFINE_x86="__i386__";
            export LIBDIR_x86="lib";
            export CFLAGS_amd64=${CFLAGS_amd64--m64};
            export CHOST_amd64=${CTARGET};
            export CTARGET_amd64=${CHOST_amd64};
            export CDEFINE_amd64="__x86_64__";
            export LIBDIR_amd64="lib64";
            export MULTILIB_ABIS="amd64 x86";
            export DEFAULT_ABI="amd64"
        ;;
        mips64*)
            export CFLAGS_o32=${CFLAGS_o32--mabi=32};
            export CHOST_o32=${CTARGET/mips64/mips};
            export CTARGET_o32=${CHOST_o32};
            export CDEFINE_o32="_MIPS_SIM == _ABIO32";
            export LIBDIR_o32="lib";
            export CFLAGS_n32=${CFLAGS_n32--mabi=n32};
            export CHOST_n32=${CTARGET};
            export CTARGET_n32=${CHOST_n32};
            export CDEFINE_n32="_MIPS_SIM == _ABIN32";
            export LIBDIR_n32="lib32";
            export CFLAGS_n64=${CFLAGS_n64--mabi=64};
            export CHOST_n64=${CTARGET};
            export CTARGET_n64=${CHOST_n64};
            export CDEFINE_n64="_MIPS_SIM == _ABI64";
            export LIBDIR_n64="lib64";
            export MULTILIB_ABIS="n64 n32 o32";
            export DEFAULT_ABI="n32"
        ;;
        powerpc64*)
            export CFLAGS_ppc=${CFLAGS_ppc--m32};
            export CHOST_ppc=${CTARGET/powerpc64/powerpc};
            export CTARGET_ppc=${CHOST_ppc};
            export CDEFINE_ppc="!__powerpc64__";
            export LIBDIR_ppc="lib";
            export CFLAGS_ppc64=${CFLAGS_ppc64--m64};
            export CHOST_ppc64=${CTARGET};
            export CTARGET_ppc64=${CHOST_ppc64};
            export CDEFINE_ppc64="__powerpc64__";
            export LIBDIR_ppc64="lib64";
            export MULTILIB_ABIS="ppc64 ppc";
            export DEFAULT_ABI="ppc64"
        ;;
        s390x*)
            export CFLAGS_s390=${CFLAGS_s390--m31};
            export CHOST_s390=${CTARGET/s390x/s390};
            export CTARGET_s390=${CHOST_s390};
            export CDEFINE_s390="!__s390x__";
            export LIBDIR_s390="lib";
            export CFLAGS_s390x=${CFLAGS_s390x--m64};
            export CHOST_s390x=${CTARGET};
            export CTARGET_s390x=${CHOST_s390x};
            export CDEFINE_s390x="__s390x__";
            export LIBDIR_s390x="lib64";
            export MULTILIB_ABIS="s390x s390";
            export DEFAULT_ABI="s390x"
        ;;
        sparc*)
            export CFLAGS_sparc32=${CFLAGS_sparc32};
            export CHOST_sparc32=${CTARGET/sparc64/sparc};
            export CTARGET_sparc32=${CHOST_sparc32};
            export CDEFINE_sparc32="!__arch64__";
            export LIBDIR_sparc32="lib";
            export CFLAGS_sparc64=${CFLAGS_sparc64--m64};
            export CHOST_sparc64=${CTARGET};
            export CTARGET_sparc64=${CHOST_sparc64};
            export CDEFINE_sparc64="__arch64__";
            export LIBDIR_sparc64="lib64";
            export MULTILIB_ABIS="${MULTILIB_ABIS-sparc64 sparc32}";
            export DEFAULT_ABI="${DEFAULT_ABI-sparc64}"
        ;;
        *)
            export MULTILIB_ABIS="default";
            export DEFAULT_ABI="default"
        ;;
    esac
}
multilib_toolchain_setup () 
{ 
    local v vv;
    export ABI=$1;
    if [[ ${ABI} != ${DEFAULT_ABI} ]]; then
        if [[ ${DEFAULT_ABI_SAVED} != "true" ]]; then
            for v in CHOST CBUILD AS CC CXX LD;
            do
                export __abi_saved_${v}="${!v}";
            done;
            export DEFAULT_ABI_SAVED="true";
        fi;
        export CHOST=$(get_abi_CHOST ${DEFAULT_ABI});
        export AS="$(tc-getAS) $(get_abi_ASFLAGS)";
        export CC="$(tc-getCC) $(get_abi_CFLAGS)";
        export CXX="$(tc-getCXX) $(get_abi_CFLAGS)";
        export LD="$(tc-getLD) $(get_abi_LDFLAGS)";
        export CHOST=$(get_abi_CHOST $1);
        export CBUILD=$(get_abi_CHOST $1);
    else
        if [[ ${DEFAULT_ABI_SAVED} == "true" ]]; then
            for v in CHOST CBUILD AS CC CXX LD;
            do
                vv="__abi_saved_${v}";
                export ${v}=${!vv};
            done;
        fi;
    fi
}
newicon () 
{ 
    ( insinto /usr/share/pixmaps;
    newins "$@" )
}
newmenu () 
{ 
    ( insinto /usr/share/applications;
    newins "$@" )
}
no-as-needed () 
{ 
    case $($(tc-getLD) -v 2>&1 </dev/null) in 
        *GNU*)
            echo "-Wl,--no-as-needed"
        ;;
    esac
}
number_abis () 
{ 
    get_install_abis | wc -w
}
pkg_nofetch () 
{ 
    _eapi0_pkg_nofetch "$@"
}
pkg_postinst () 
{ 
    toolchain-binutils_pkg_postinst "$@"
}
pkg_postrm () 
{ 
    toolchain-binutils_pkg_postrm "$@"
}
prep_ml_includes () 
{ 
    if [[ $(number_abis) -gt 1 ]]; then
        local dir;
        local dirs;
        local base;
        if [[ $# -eq 0 ]]; then
            dirs=/usr/include;
        else
            dirs="$@";
        fi;
        for dir in ${dirs};
        do
            base=${T}/gentoo-multilib/${dir}/gentoo-multilib;
            mkdir -p "${base}";
            [[ -d ${base}/${ABI} ]] && rm -rf "${base}/${ABI}";
            mv "${D}/${dir}" "${base}/${ABI}";
        done;
        if is_final_abi; then
            base=${T}/gentoo-multilib;
            pushd "${base}";
            find . | tar -c -T - -f - | tar -x --no-same-owner -f - -C "${D}";
            popd;
            set --;
            for dir in ${dirs};
            do
                set -- "$@" "${dir}";
                local abi;
                for abi in $(get_install_abis);
                do
                    set -- "$@" "$(get_abi_CDEFINE ${abi}):${dir}/gentoo-multilib/${abi}";
                done;
                create_ml_includes "$@";
            done;
        fi;
    fi
}
preserve_old_lib () 
{ 
    if [[ ${EBUILD_PHASE} != "preinst" ]]; then
        eerror "preserve_old_lib() must be called from pkg_preinst() only";
        die "Invalid preserve_old_lib() usage";
    fi;
    [[ -z $1 ]] && die "Usage: preserve_old_lib <library to preserve> [more libraries to preserve]";
    has preserve-libs ${FEATURES} && return 0;
    local lib dir;
    for lib in "$@";
    do
        [[ -e ${ROOT}/${lib} ]] || continue;
        dir=${lib%/*};
        dodir ${dir} || die "dodir ${dir} failed";
        cp "${ROOT}"/${lib} "${D}"/${lib} || die "cp ${lib} failed";
        touch "${D}"/${lib};
    done
}
preserve_old_lib_notify () 
{ 
    if [[ ${EBUILD_PHASE} != "postinst" ]]; then
        eerror "preserve_old_lib_notify() must be called from pkg_postinst() only";
        die "Invalid preserve_old_lib_notify() usage";
    fi;
    has preserve-libs ${FEATURES} && return 0;
    local lib notice=0;
    for lib in "$@";
    do
        [[ -e ${ROOT}/${lib} ]] || continue;
        if [[ ${notice} -eq 0 ]]; then
            notice=1;
            ewarn "Old versions of installed libraries were detected on your system.";
            ewarn "In order to avoid breaking packages that depend on these old libs,";
            ewarn "the libraries are not being removed.  You need to run revdep-rebuild";
            ewarn "in order to remove these old dependencies.  If you do not have this";
            ewarn "helper program, simply emerge the 'gentoolkit' package.";
            ewarn;
        fi;
        ewarn "  # revdep-rebuild --library ${lib##*/}";
    done;
    if [[ ${notice} -eq 1 ]]; then
        ewarn;
        ewarn "Once you've finished running revdep-rebuild, it should be safe to";
        ewarn "delete the old libraries.  Here is a copy & paste for the lazy:";
        for lib in "$@";
        do
            ewarn "  # rm '${lib}'";
        done;
    fi
}
raw-ldflags () 
{ 
    local x input="$@";
    [[ -z ${input} ]] && input=${LDFLAGS};
    set --;
    for x in ${input};
    do
        x=${x#-Wl,};
        set -- "$@" ${x//,/ };
    done;
    echo "$@"
}
replace-cpu-flags () 
{ 
    local newcpu="$#";
    newcpu="${!newcpu}";
    while [ $# -gt 1 ]; do
        replace-flags "-march=${1}" "-march=${newcpu}";
        replace-flags "-mcpu=${1}" "-mcpu=${newcpu}";
        replace-flags "-mtune=${1}" "-mtune=${newcpu}";
        shift;
    done;
    return 0
}
replace-flags () 
{ 
    [[ $# != 2 ]] && echo && eerror "Usage: replace-flags <old flag> <new flag>" && die "replace-flags takes 2 arguments, not $#";
    local f fset;
    declare -a new_CFLAGS new_CXXFLAGS new_FFLAGS new_FCFLAGS;
    for fset in CFLAGS CXXFLAGS FFLAGS FCFLAGS;
    do
        for f in ${!fset};
        do
            [[ ${f} == ${1} ]] && f=${2};
            eval new_${fset}\[\${\#new_${fset}\[@]}]=\${f};
        done;
        eval export ${fset}=\${new_${fset}\[*]};
    done;
    return 0
}
replace-sparc64-flags () 
{ 
    local SPARC64_CPUS="ultrasparc3 ultrasparc v9";
    if [ "${CFLAGS/mtune}" != "${CFLAGS}" ]; then
        for x in ${SPARC64_CPUS};
        do
            CFLAGS="${CFLAGS/-mcpu=${x}/-mcpu=v8}";
        done;
    else
        for x in ${SPARC64_CPUS};
        do
            CFLAGS="${CFLAGS/-mcpu=${x}/-mcpu=v8 -mtune=${x}}";
        done;
    fi;
    if [ "${CXXFLAGS/mtune}" != "${CXXFLAGS}" ]; then
        for x in ${SPARC64_CPUS};
        do
            CXXFLAGS="${CXXFLAGS/-mcpu=${x}/-mcpu=v8}";
        done;
    else
        for x in ${SPARC64_CPUS};
        do
            CXXFLAGS="${CXXFLAGS/-mcpu=${x}/-mcpu=v8 -mtune=${x}}";
        done;
    fi;
    export CFLAGS CXXFLAGS
}
replace_all_version_separators () 
{ 
    __versionator_shopt_toggle on;
    local c;
    c=($(get_all_version_components "${2:-${PV}}" ));
    c="${c[@]//[-._]/$1}";
    echo ${c// };
    __versionator_shopt_toggle off
}
replace_version_separator () 
{ 
    __versionator_shopt_toggle on;
    local w i c found=0 v="${3:-${PV}}";
    w=${1:-1};
    c=($(get_all_version_components ${v} ));
    if [[ "${w//[[:digit:]]/}" == "${w}" ]]; then
        for ((i = 0 ; i < ${#c[@]} ; i = $i + 1 ))
        do
            if [[ "${c[${i}]}" == "${w}" ]]; then
                c[${i}]="${2}";
                break;
            fi;
        done;
    else
        for ((i = 0 ; i < ${#c[@]} ; i = $i + 1 ))
        do
            if [[ -n "${c[${i}]//[^-._]}" ]]; then
                found=$(($found + 1));
                if [[ "$found" == "${w}" ]]; then
                    c[${i}]="${2}";
                    break;
                fi;
            fi;
        done;
    fi;
    c=${c[@]};
    echo ${c// };
    __versionator_shopt_toggle off
}
seq () 
{ 
    local p=$(type -P seq);
    case $# in 
        1)
            min=1 max=$1 step=1
        ;;
        2)
            min=$1 max=$2 step=1
        ;;
        3)
            min=$1 max=$3 step=$2
        ;;
        *)
            die "seq called with wrong number of arguments"
        ;;
    esac;
    if [[ -z ${p} ]]; then
        local reps;
        if [[ ${step} != 0 ]]; then
            reps=$(( ($max-$min) / $step +1 ));
        else
            reps=0;
        fi;
        jot $reps $min $max $step;
    else
        "${p}" $min $step $max;
    fi
}
setup-allowed-flags () 
{ 
    if [[ -z ${ALLOWED_FLAGS} ]]; then
        export ALLOWED_FLAGS="-pipe";
        export ALLOWED_FLAGS="${ALLOWED_FLAGS} -O -O0 -O1 -O2 -mcpu -march -mtune";
        export ALLOWED_FLAGS="${ALLOWED_FLAGS} -fstack-protector -fstack-protector-all";
        export ALLOWED_FLAGS="${ALLOWED_FLAGS} -fbounds-checking -fno-strict-overflow";
        export ALLOWED_FLAGS="${ALLOWED_FLAGS} -fno-PIE -fno-pie -fno-unit-at-a-time";
        export ALLOWED_FLAGS="${ALLOWED_FLAGS} -g -g[0-9] -ggdb -ggdb[0-9] -gstabs -gstabs+";
        export ALLOWED_FLAGS="${ALLOWED_FLAGS} -fno-ident";
        export ALLOWED_FLAGS="${ALLOWED_FLAGS} -W* -w";
    fi;
    ALLOWED_FLAGS="${ALLOWED_FLAGS} -fno-stack-protector -fno-stack-protector-all 		-fno-strict-aliasing -fno-bounds-checking -fstrict-overflow -fno-omit-frame-pointer";
    ALLOWED_FLAGS="${ALLOWED_FLAGS} -mregparm -mno-app-regs -mapp-regs 		-mno-mmx -mno-sse -mno-sse2 -mno-sse3 -mno-ssse3 -mno-sse4 -mno-sse4.1 		-mno-sse4.2 -mno-avx -mno-aes -mno-pclmul -mno-sse4a -mno-3dnow 		-mno-popcnt -mno-abm 		-mips1 -mips2 -mips3 -mips4 -mips32 -mips64 -mips16 -mplt 		-msoft-float -mno-soft-float -mhard-float -mno-hard-float -mfpu 		-mieee -mieee-with-inexact -mschedule 		-mtls-direct-seg-refs -mno-tls-direct-seg-refs 		-mflat -mno-flat -mno-faster-structs -mfaster-structs 		-m32 -m64 -mabi -mlittle-endian -mbig-endian -EL -EB -fPIC 		-mlive-g0 -mcmodel -mstack-bias -mno-stack-bias 		-msecure-plt -m*-toc -D* -U*";
    export UNSTABLE_FLAGS="-Os -O3 -freorder-blocks";
    return 0
}
src_compile () 
{ 
    toolchain-binutils_src_compile "$@"
}
src_install () 
{ 
    toolchain-binutils_src_install "$@"
}
src_test () 
{ 
    toolchain-binutils_src_test "$@"
}
src_unpack () 
{ 
    toolchain-binutils_src_unpack "$@"
}
strip-flags () 
{ 
    local x y flag NEW_CFLAGS NEW_CXXFLAGS NEW_FFLAGS NEW_FCFLAGS;
    setup-allowed-flags;
    local NEW_CFLAGS="";
    local NEW_CXXFLAGS="";
    local NEW_FFLAGS="";
    local NEW_FCFLAGS="";
    if has "~$(tc-arch)" ${ACCEPT_KEYWORDS}; then
        ALLOWED_FLAGS="${ALLOWED_FLAGS} ${UNSTABLE_FLAGS}";
    fi;
    set -f;
    for x in ${CFLAGS};
    do
        for y in ${ALLOWED_FLAGS};
        do
            flag=${x%%=*};
            if [ "${flag%%${y}}" = "" ]; then
                NEW_CFLAGS="${NEW_CFLAGS} ${x}";
                break;
            fi;
        done;
    done;
    for x in ${CXXFLAGS};
    do
        for y in ${ALLOWED_FLAGS};
        do
            flag=${x%%=*};
            if [ "${flag%%${y}}" = "" ]; then
                NEW_CXXFLAGS="${NEW_CXXFLAGS} ${x}";
                break;
            fi;
        done;
    done;
    for x in ${FFLAGS};
    do
        for y in ${ALLOWED_FLAGS};
        do
            flag=${x%%=*};
            if [ "${flag%%${y}}" = "" ]; then
                NEW_FFLAGS="${NEW_FFLAGS} ${x}";
                break;
            fi;
        done;
    done;
    for x in ${FCFLAGS};
    do
        for y in ${ALLOWED_FLAGS};
        do
            flag=${x%%=*};
            if [ "${flag%%${y}}" = "" ]; then
                NEW_FCFLAGS="${NEW_FCFLAGS} ${x}";
                break;
            fi;
        done;
    done;
    if [ "${CFLAGS/-O}" != "${CFLAGS}" -a "${NEW_CFLAGS/-O}" = "${NEW_CFLAGS}" ]; then
        NEW_CFLAGS="${NEW_CFLAGS} -O2";
    fi;
    if [ "${CXXFLAGS/-O}" != "${CXXFLAGS}" -a "${NEW_CXXFLAGS/-O}" = "${NEW_CXXFLAGS}" ]; then
        NEW_CXXFLAGS="${NEW_CXXFLAGS} -O2";
    fi;
    if [ "${FFLAGS/-O}" != "${FFLAGS}" -a "${NEW_FFLAGS/-O}" = "${NEW_FFLAGS}" ]; then
        NEW_FFLAGS="${NEW_FFLAGS} -O2";
    fi;
    if [ "${FCFLAGS/-O}" != "${FCFLAGS}" -a "${NEW_FCFLAGS/-O}" = "${NEW_FCFLAGS}" ]; then
        NEW_FCFLAGS="${NEW_FCFLAGS} -O2";
    fi;
    set +f;
    export CFLAGS="${NEW_CFLAGS}";
    export CXXFLAGS="${NEW_CXXFLAGS}";
    export FFLAGS="${NEW_FFLAGS}";
    export FCFLAGS="${NEW_FCFLAGS}";
    return 0
}
strip-linguas () 
{ 
    local ls newls nols;
    if [[ $1 == "-i" ]] || [[ $1 == "-u" ]]; then
        local op=$1;
        shift;
        ls=$(find "$1" -name '*.po' -exec basename {} .po ';');
        shift;
        local d f;
        for d in "$@";
        do
            if [[ ${op} == "-u" ]]; then
                newls=${ls};
            else
                newls="";
            fi;
            for f in $(find "$d" -name '*.po' -exec basename {} .po ';');
            do
                if [[ ${op} == "-i" ]]; then
                    hasq ${f} ${ls} && newls="${newls} ${f}";
                else
                    hasq ${f} ${ls} || newls="${newls} ${f}";
                fi;
            done;
            ls=${newls};
        done;
    else
        ls="$@";
    fi;
    nols="";
    newls="";
    for f in ${LINGUAS};
    do
        if hasq ${f} ${ls}; then
            newls="${newls} ${f}";
        else
            nols="${nols} ${f}";
        fi;
    done;
    [[ -n ${nols} ]] && ewarn "Sorry, but ${PN} does not support the LINGUAS:" ${nols};
    export LINGUAS=${newls:1}
}
strip-unsupported-flags () 
{ 
    export CFLAGS=$(test-flags-CC ${CFLAGS});
    export CXXFLAGS=$(test-flags-CXX ${CXXFLAGS});
    export FFLAGS=$(test-flags-F77 ${FFLAGS});
    export FCFLAGS=$(test-flags-FC ${FCFLAGS})
}
tc-arch () 
{ 
    tc-ninja_magic_to_arch portage "$@"
}
tc-arch-kernel () 
{ 
    tc-ninja_magic_to_arch kern "$@"
}
tc-binutils_apply_patches () 
{ 
    cd "${S}";
    if ! use vanilla; then
        if [[ -n ${PATCHVER} ]]; then
            EPATCH_SOURCE=${WORKDIR}/patch;
            if [[ ${CTARGET} == mips* ]]; then
                EPATCH_EXCLUDE="77_all_generate-gnu-hash.patch";
            fi;
            [[ -n $(ls "${EPATCH_SOURCE}"/*.bz2 2>/dev/null) ]] && EPATCH_SUFFIX="patch.bz2" || EPATCH_SUFFIX="patch";
            epatch;
        fi;
        if [[ -n ${UCLIBC_PATCHVER} ]]; then
            EPATCH_SOURCE=${WORKDIR}/uclibc-patches;
            [[ -n $(ls "${EPATCH_SOURCE}"/*.bz2 2>/dev/null) ]] && EPATCH_SUFFIX="patch.bz2" || EPATCH_SUFFIX="patch";
            EPATCH_MULTI_MSG="Applying uClibc fixes ..." epatch;
        else
            if [[ ${CTARGET} == *-uclibc* ]]; then
                if grep -qs 'linux-gnu' "${S}"/ltconfig; then
                    die "sorry, but this binutils doesn't yet support uClibc :(";
                fi;
            fi;
        fi;
        epatch_user;
    fi;
    if [[ -e ${FILESDIR}/binutils-configure-LANG.patch ]]; then
        einfo "Fixing misc issues in configure files";
        for f in $(grep -l 'autoconf version 2.13' $(find "${S}" -name configure));
        do
            ebegin "  Updating ${f/${S}\/}";
            patch "${f}" "${FILESDIR}"/binutils-configure-LANG.patch &>"${T}"/configure-patch.log || eerror "Please file a bug about this";
            eend $?;
        done;
    fi;
    if [[ -e libiberty/testsuite/test-demangle.c ]]; then
        sed -i 's:\<getline\>:get_line:g' libiberty/testsuite/test-demangle.c;
    fi;
    sed -i -e '/^datadir = /s:$(prefix)/@DATADIRNAME@:@datadir@:' -e '/^gnulocaledir = /s:$(prefix)/share:$(datadir):' */po/Make-in || die "sed po's failed";
    gnuconfig_update;
    elibtoolize --portage --no-uclibc
}
tc-binutils_unpack () 
{ 
    unpack ${A};
    mkdir -p "${MY_BUILDDIR}";
    [[ -d ${WORKDIR}/patch ]] && mkdir "${WORKDIR}"/patch/skip
}
tc-endian () 
{ 
    local host=$1;
    [[ -z ${host} ]] && host=${CTARGET:-${CHOST}};
    host=${host%%-*};
    case ${host} in 
        alpha*)
            echo big
        ;;
        arm*b*)
            echo big
        ;;
        arm*)
            echo little
        ;;
        cris*)
            echo little
        ;;
        hppa*)
            echo big
        ;;
        i?86*)
            echo little
        ;;
        ia64*)
            echo little
        ;;
        m68*)
            echo big
        ;;
        mips*l*)
            echo little
        ;;
        mips*)
            echo big
        ;;
        powerpc*)
            echo big
        ;;
        s390*)
            echo big
        ;;
        sh*b*)
            echo big
        ;;
        sh*)
            echo little
        ;;
        sparc*)
            echo big
        ;;
        x86_64*)
            echo little
        ;;
        *)
            echo wtf
        ;;
    esac
}
tc-export () 
{ 
    local var;
    for var in "$@";
    do
        [[ $(type -t tc-get${var}) != "function" ]] && die "tc-export: invalid export variable '${var}'";
        eval tc-get${var} > /dev/null;
    done
}
tc-getAR () 
{ 
    tc-getPROG AR ar "$@"
}
tc-getAS () 
{ 
    tc-getPROG AS as "$@"
}
tc-getBUILD_CC () 
{ 
    local v;
    for v in CC_FOR_BUILD BUILD_CC HOSTCC;
    do
        if [[ -n ${!v} ]]; then
            export BUILD_CC=${!v};
            echo "${!v}";
            return 0;
        fi;
    done;
    local search=;
    if [[ -n ${CBUILD} ]]; then
        search=$(type -p ${CBUILD}-gcc);
        search=${search##*/};
    fi;
    search=${search:-gcc};
    export BUILD_CC=${search};
    echo "${search}"
}
tc-getCC () 
{ 
    tc-getPROG CC gcc "$@"
}
tc-getCPP () 
{ 
    tc-getPROG CPP cpp "$@"
}
tc-getCXX () 
{ 
    tc-getPROG CXX g++ "$@"
}
tc-getF77 () 
{ 
    tc-getPROG F77 f77 "$@"
}
tc-getFC () 
{ 
    tc-getPROG FC gfortran "$@"
}
tc-getGCJ () 
{ 
    tc-getPROG GCJ gcj "$@"
}
tc-getLD () 
{ 
    tc-getPROG LD ld "$@"
}
tc-getNM () 
{ 
    tc-getPROG NM nm "$@"
}
tc-getOBJCOPY () 
{ 
    tc-getPROG OBJCOPY objcopy "$@"
}
tc-getPROG () 
{ 
    local var=$1;
    local prog=$2;
    if [[ -n ${!var} ]]; then
        echo "${!var}";
        return 0;
    fi;
    local search=;
    [[ -n $3 ]] && search=$(type -p "$3-${prog}");
    [[ -z ${search} && -n ${CHOST} ]] && search=$(type -p "${CHOST}-${prog}");
    [[ -n ${search} ]] && prog=${search##*/};
    export ${var}=${prog};
    echo "${!var}"
}
tc-getRANLIB () 
{ 
    tc-getPROG RANLIB ranlib "$@"
}
tc-getSTRIP () 
{ 
    tc-getPROG STRIP strip "$@"
}
tc-is-cross-compiler () 
{ 
    return $([[ ${CBUILD:-${CHOST}} != ${CHOST} ]])
}
tc-is-softfloat () 
{ 
    case ${CTARGET} in 
        bfin* | h8300*)
            echo "only"
        ;;
        *)
            [[ ${CTARGET//_/-} == *-softfloat-* ]] && echo "yes" || echo "no"
        ;;
    esac
}
tc-is-static-only () 
{ 
    local host=${CTARGET:-${CHOST}};
    return $([[ ${host} == *-mint* ]])
}
tc-ninja_magic_to_arch () 
{ 
    function ninj () 
    { 
        [[ ${type} == "kern" ]] && echo $1 || echo $2
    };
    local type=$1;
    local host=$2;
    [[ -z ${host} ]] && host=${CTARGET:-${CHOST}};
    case ${host} in 
        alpha*)
            echo alpha
        ;;
        arm*)
            echo arm
        ;;
        avr*)
            ninj avr32 avr
        ;;
        bfin*)
            ninj blackfin bfin
        ;;
        cris*)
            echo cris
        ;;
        hppa*)
            ninj parisc hppa
        ;;
        i?86*)
            if [[ ${type} == "kern" ]] && [[ $(KV_to_int ${KV}) -lt $(KV_to_int 2.6.24) || ${host} == *freebsd* ]]; then
                echo i386;
            else
                echo x86;
            fi
        ;;
        ia64*)
            echo ia64
        ;;
        m68*)
            echo m68k
        ;;
        mips*)
            echo mips
        ;;
        nios2*)
            echo nios2
        ;;
        nios*)
            echo nios
        ;;
        powerpc*)
            if [[ $(KV_to_int ${KV}) -ge $(KV_to_int 2.6.16) ]] && [[ ${type} == "kern" ]]; then
                echo powerpc;
            else
                if [[ $(KV_to_int ${KV}) -eq $(KV_to_int 2.6.15) ]] && [[ ${type} == "kern" ]]; then
                    if [[ ${host} == powerpc64* ]] || [[ ${PROFILE_ARCH} == "ppc64" ]]; then
                        echo powerpc;
                    else
                        echo ppc;
                    fi;
                else
                    if [[ ${host} == powerpc64* ]]; then
                        echo ppc64;
                    else
                        if [[ ${PROFILE_ARCH} == "ppc64" ]]; then
                            ninj ppc64 ppc;
                        else
                            echo ppc;
                        fi;
                    fi;
                fi;
            fi
        ;;
        s390*)
            echo s390
        ;;
        sh64*)
            ninj sh64 sh
        ;;
        sh*)
            echo sh
        ;;
        sparc64*)
            ninj sparc64 sparc
        ;;
        sparc*)
            [[ ${PROFILE_ARCH} == "sparc64" ]] && ninj sparc64 sparc || echo sparc
        ;;
        vax*)
            echo vax
        ;;
        x86_64*)
            if [[ ${type} == "kern" ]] && [[ $(KV_to_int ${KV}) -ge $(KV_to_int 2.6.24) ]]; then
                echo x86;
            else
                ninj x86_64 amd64;
            fi
        ;;
        *)
            echo unknown
        ;;
    esac
}
test-flag-CC () 
{ 
    test-flag-PROG "CC" "$1"
}
test-flag-CXX () 
{ 
    test-flag-PROG "CXX" "$1"
}
test-flag-F77 () 
{ 
    test-flag-PROG "F77" "$1"
}
test-flag-FC () 
{ 
    test-flag-PROG "FC" "$1"
}
test-flag-PROG () 
{ 
    local comp=$1;
    local flags="$2";
    [[ -z ${comp} || -z ${flags} ]] && return 1;
    local PROG=$(tc-get${comp});
    ${PROG} ${flags} -S -o /dev/null -xc /dev/null > /dev/null 2>&1
}
test-flags () 
{ 
    test-flags-CC "$@"
}
test-flags-CC () 
{ 
    test-flags-PROG "CC" "$@"
}
test-flags-CXX () 
{ 
    test-flags-PROG "CXX" "$@"
}
test-flags-F77 () 
{ 
    test-flags-PROG "F77" "$@"
}
test-flags-FC () 
{ 
    test-flags-PROG "FC" "$@"
}
test-flags-PROG () 
{ 
    local comp=$1;
    local flags;
    local x;
    shift;
    [[ -z ${comp} ]] && return 1;
    x="";
    for x in "$@";
    do
        test-flag-${comp} "${x}" && flags="${flags}${flags:+ }${x}";
    done;
    echo "${flags}";
    [[ -n ${flags} ]]
}
test_flag () 
{ 
    ewarn "test_flag: deprecated, please use test-flags()!" 1>&2;
    test-flags-CC "$@"
}
test_version_info () 
{ 
    if [[ $($(tc-getCC) --version 2>&1) == *$1* ]]; then
        return 0;
    else
        return 1;
    fi
}
toolchain-binutils_pkg_postinst () 
{ 
    [[ -e ${ROOT}/etc/env.d/binutils/config-${CTARGET} ]] && return 0;
    binutils-config ${CTARGET}-${BVER}
}
toolchain-binutils_pkg_postrm () 
{ 
    local current_profile=$(binutils-config -c ${CTARGET});
    if [[ ! -e ${BINPATH}/ld ]] && [[ ${current_profile} == ${CTARGET}-${BVER} ]]; then
        local choice=$(binutils-config -l | grep ${CTARGET} | awk '{print $2}');
        choice=${choice//'
'/ };
        choice=${choice/* };
        if [[ -z ${choice} ]]; then
            env -i binutils-config -u ${CTARGET};
        else
            binutils-config ${choice};
        fi;
    else
        if [[ $(CHOST=${CTARGET} binutils-config -c) == ${CTARGET}-${BVER} ]]; then
            binutils-config ${CTARGET}-${BVER};
        fi;
    fi
}
toolchain-binutils_src_compile () 
{ 
    find . '(' -name '*.info' -o -name '*.texi' ')' -print0 | xargs -0 touch -r .;
    strip-linguas -u */po;
    strip-flags;
    local x;
    echo;
    for x in CATEGORY CBUILD CHOST CTARGET CFLAGS LDFLAGS;
    do
        einfo "$(printf '%10s' ${x}:) ${!x}";
    done;
    echo;
    cd "${MY_BUILDDIR}";
    local myconf="";
    use nls && myconf="${myconf} --without-included-gettext" || myconf="${myconf} --disable-nls";
    use multitarget && myconf="${myconf} --enable-targets=all";
    [[ -n ${CBUILD} ]] && myconf="${myconf} --build=${CBUILD}";
    is_cross && myconf="${myconf} --with-sysroot=/usr/${CTARGET}";
    has_version ">=${CATEGORY}/glibc-2.5" && myconf="${myconf} --enable-secureplt";
    has_version ">=sys-libs/glibc-2.5" && myconf="${myconf} --enable-secureplt";
    myconf="--prefix=/usr 		--host=${CHOST} 		--target=${CTARGET} 		--datadir=${DATAPATH} 		--infodir=${DATAPATH}/info 		--mandir=${DATAPATH}/man 		--bindir=${BINPATH} 		--libdir=${LIBPATH} 		--libexecdir=${LIBPATH} 		--includedir=${INCPATH} 		--enable-64-bit-bfd 		--enable-shared 		--disable-werror 		$(use_enable gold) 		${myconf} ${EXTRA_ECONF}";
    echo ./configure ${myconf};
    "${S}"/configure ${myconf} || die "configure failed";
    emake all || die "emake failed";
    if ! has noinfo ${FEATURES}; then
        if type -p makeinfo > /dev/null; then
            make info || die "make info failed";
        fi;
    fi;
    find . -name '*.1' -a -size 0 | xargs rm -f;
    if [[ -n ${ELF2FLT_VER} ]] && [[ ${CTARGET} == *linux* || ${CTARGET} == *-elf* ]]; then
        cd "${WORKDIR}"/elf2flt-${ELF2FLT_VER};
        local x supported_arches=$(sed -n '/defined(TARGET_/{s:^.*TARGET_::;s:)::;p}' elf2flt.c | sort -u);
        for x in ${supported_arches} UNSUPPORTED;
        do
            [[ ${CTARGET} == ${x}* ]] && break;
        done;
        if [[ ${x} != "UNSUPPORTED" ]]; then
            append-flags -I"${S}"/include;
            myconf="--with-bfd-include-dir=${MY_BUILDDIR}/bfd 				--with-libbfd=${MY_BUILDDIR}/bfd/libbfd.a 				--with-libiberty=${MY_BUILDDIR}/libiberty/libiberty.a 				--with-binutils-ldscript-dir=${LIBPATH}/ldscripts 				${myconf}";
            echo ./configure ${myconf};
            ./configure ${myconf} || die "configure elf2flt failed";
            emake || die "make elf2flt failed";
        fi;
    fi
}
toolchain-binutils_src_install () 
{ 
    local x d;
    cd "${MY_BUILDDIR}";
    emake DESTDIR="${D}" tooldir="${LIBPATH}" install || die;
    rm -rf "${D}"/${LIBPATH}/bin;
    cd "${D}"/${LIBPATH};
    for d in ../*;
    do
        [[ ${d} == ../${BVER} ]] && continue;
        mv ${d}/* . || die;
        rmdir ${d} || die;
    done;
    if is_cross; then
        cd "${D}"/${BINPATH};
        for x in *;
        do
            mv ${x} ${x/${CTARGET}-};
        done;
        if [[ -d ${D}/usr/${CHOST}/${CTARGET} ]]; then
            mv "${D}"/usr/${CHOST}/${CTARGET}/include "${D}"/${INCPATH};
            mv "${D}"/usr/${CHOST}/${CTARGET}/lib/* "${D}"/${LIBPATH}/;
            rm -r "${D}"/usr/${CHOST}/{include,lib};
        fi;
    fi;
    insinto ${INCPATH};
    doins "${S}/include/libiberty.h";
    if [[ -d ${D}/${LIBPATH}/lib ]]; then
        mv "${D}"/${LIBPATH}/lib/* "${D}"/${LIBPATH}/;
        rm -r "${D}"/${LIBPATH}/lib;
    fi;
    if [[ -x ${WORKDIR}/elf2flt-${ELF2FLT_VER}/elf2flt ]]; then
        cd "${WORKDIR}"/elf2flt-${ELF2FLT_VER};
        insinto ${LIBPATH}/ldscripts;
        doins elf2flt.ld || die "doins elf2flt.ld failed";
        exeinto ${BINPATH};
        doexe elf2flt flthdr || die "doexe elf2flt flthdr failed";
        mv "${D}"/${BINPATH}/{ld,ld.real} || die;
        newexe ld-elf2flt ld || die "doexe ld-elf2flt failed";
        newdoc README README.elf2flt;
    fi;
    local targ=${CTARGET/-*} src="" dst="";
    local FAKE_TARGETS=${CTARGET};
    case ${targ} in 
        mips*)
            src="mips" dst="mips64"
        ;;
        powerpc*)
            src="powerpc" dst="powerpc64"
        ;;
        s390*)
            src="s390" dst="s390x"
        ;;
        sparc*)
            src="sparc" dst="sparc64"
        ;;
    esac;
    case ${targ} in 
        mips64* | powerpc64* | s390x* | sparc64*)
            targ=${src} src=${dst} dst=${targ}
        ;;
    esac;
    [[ -n ${src}${dst} ]] && FAKE_TARGETS="${FAKE_TARGETS} ${CTARGET/${src}/${dst}}";
    cd "${S}";
    insinto /etc/env.d/binutils;
    cat > env.d  <<-EOF
TARGET="${CTARGET}"
VER="${BVER}"
LIBPATH="${LIBPATH}"
FAKE_TARGETS="${FAKE_TARGETS}"
EOF

    newins env.d ${CTARGET}-${BVER};
    if ! is_cross; then
        cd "${S}";
        dodoc README;
        docinto bfd;
        dodoc bfd/ChangeLog* bfd/README bfd/PORTING bfd/TODO;
        docinto binutils;
        dodoc binutils/ChangeLog binutils/NEWS binutils/README;
        docinto gas;
        dodoc gas/ChangeLog* gas/CONTRIBUTORS gas/NEWS gas/README*;
        docinto gprof;
        dodoc gprof/ChangeLog* gprof/TEST gprof/TODO gprof/bbconv.pl;
        docinto ld;
        dodoc ld/ChangeLog* ld/README ld/NEWS ld/TODO;
        docinto libiberty;
        dodoc libiberty/ChangeLog* libiberty/README;
        docinto opcodes;
        dodoc opcodes/ChangeLog*;
    fi;
    has noinfo ${FEATURES} && rm -r "${D}"/${DATAPATH}/info;
    has noman ${FEATURES} && rm -r "${D}"/${DATAPATH}/man;
    rm -f "${D}"/${DATAPATH}/info/{dir,configure.info,standards.info};
    find "${D}" -type d | xargs rmdir &>/dev/null
}
toolchain-binutils_src_test () 
{ 
    cd "${MY_BUILDDIR}";
    make check || die "check failed :("
}
toolchain-binutils_src_unpack () 
{ 
    is_cross && [[ $(binutils-config -V) != binutils-config-1.9* ]] && die "You need to upgrade your binutils-config to 1.9 or newer";
    tc-binutils_unpack;
    tc-binutils_apply_patches
}
treecopy () 
{ 
    dest=${!#};
    files_count=$#;
    while (( $# > 1 )); do
        dirstruct=$(dirname "$1");
        mkdir -p "${dest}/${dirstruct}";
        cp -pPR "$1" "${dest}/${dirstruct}";
        shift;
    done
}
uclibctoolize () 
{ 
    ewarn "uclibctoolize() is deprecated, please just use elibtoolize()!";
    elibtoolize
}
unpack_makeself () 
{ 
    local src_input=${1:-${A}};
    local src=$(find_unpackable_file "${src_input}");
    local skip=$2;
    local exe=$3;
    [[ -z ${src} ]] && die "Could not locate source for '${src_input}'";
    local shrtsrc=$(basename "${src}");
    echo ">>> Unpacking ${shrtsrc} to ${PWD}";
    if [[ -z ${skip} ]]; then
        local ver=$(grep -a '#.*Makeself' "${src}" | awk '{print $NF}');
        local skip=0;
        exe=tail;
        case ${ver} in 
            1.5.* | 1.6.0-nv)
                skip=$(grep -a ^skip= "${src}" | cut -d= -f2)
            ;;
            2.0 | 2.0.1)
                skip=$(grep -a ^'	'tail "${src}" | awk '{print $2}' | cut -b2-)
            ;;
            2.1.1)
                skip=$(grep -a ^offset= "${src}" | awk '{print $2}' | cut -b2-);
                let skip="skip + 1"
            ;;
            2.1.2)
                skip=$(grep -a ^offset= "${src}" | awk '{print $3}' | head -n 1);
                let skip="skip + 1"
            ;;
            2.1.3)
                skip=`grep -a ^offset= "${src}" | awk '{print $3}'`;
                let skip="skip + 1"
            ;;
            2.1.4 | 2.1.5)
                skip=$(grep -a offset=.*head.*wc "${src}" | awk '{print $3}' | head -n 1);
                skip=$(head -n ${skip} "${src}" | wc -c);
                exe="dd"
            ;;
            *)
                eerror "I'm sorry, but I was unable to support the Makeself file.";
                eerror "The version I detected was '${ver}'.";
                eerror "Please file a bug about the file ${shrtsrc} at";
                eerror "http://bugs.gentoo.org/ so that support can be added.";
                die "makeself version '${ver}' not supported"
            ;;
        esac;
        debug-print "Detected Makeself version ${ver} ... using ${skip} as offset";
    fi;
    case ${exe} in 
        tail)
            exe="tail -n +${skip} '${src}'"
        ;;
        dd)
            exe="dd ibs=${skip} skip=1 obs=1024 conv=sync if='${src}'"
        ;;
        *)
            die "makeself cant handle exe '${exe}'"
        ;;
    esac;
    local tmpfile=$(emktemp);
    eval ${exe} 2> /dev/null | head -c 512 > "${tmpfile}";
    local filetype=$(file -b "${tmpfile}");
    case ${filetype} in 
        *tar\ archive*)
            eval ${exe} | tar --no-same-owner -xf -
        ;;
        bzip2*)
            eval ${exe} | bzip2 -dc | tar --no-same-owner -xf -
        ;;
        gzip*)
            eval ${exe} | tar --no-same-owner -xzf -
        ;;
        compress*)
            eval ${exe} | gunzip | tar --no-same-owner -xf -
        ;;
        *)
            eerror "Unknown filetype \"${filetype}\" ?";
            false
        ;;
    esac;
    _pipestatus="${PIPESTATUS[*]}";
    [[ "${_pipestatus// /}" -eq 0 ]] || die "failure unpacking (${filetype}) makeself ${shrtsrc} ('${ver}' +${skip})"
}
unpack_pdv () 
{ 
    local src=$(find_unpackable_file "$1");
    local sizeoff_t=$2;
    [[ -z ${src} ]] && die "Could not locate source for '$1'";
    [[ -z ${sizeoff_t} ]] && die "No idea what off_t size was used for this pdv :(";
    local shrtsrc=$(basename "${src}");
    echo ">>> Unpacking ${shrtsrc} to ${PWD}";
    local metaskip=$(tail -c ${sizeoff_t} "${src}" | hexdump -e \"%i\");
    local tailskip=$(tail -c $((${sizeoff_t}*2)) "${src}" | head -c ${sizeoff_t} | hexdump -e \"%i\");
    local metafile=$(emktemp);
    tail -c +$((${metaskip}+1)) "${src}" > "${metafile}";
    local datafile=$(tail -c +$((${metaskip}+1)) "${src}" | strings | head -n 1);
    datafile=$(basename "${datafile}");
    local tmpfile=$(emktemp);
    tail -c +$((${tailskip}+1)) ${src} 2> /dev/null | head -c 512 > ${tmpfile};
    local iscompressed=$(file -b "${tmpfile}");
    if [[ ${iscompressed:0:8} == "compress" ]]; then
        iscompressed=1;
        mv ${tmpfile}{,.Z};
        gunzip ${tmpfile};
    else
        iscompressed=0;
    fi;
    local istar=$(file -b "${tmpfile}");
    if [[ ${istar:0:9} == "POSIX tar" ]]; then
        istar=1;
    else
        istar=0;
    fi;
    if [ ${iscompressed} -eq 1 ]; then
        if [ ${istar} -eq 1 ]; then
            tail -c +$((${tailskip}+1)) ${src} 2> /dev/null | head -c $((${metaskip}-${tailskip})) | tar -xzf -;
        else
            tail -c +$((${tailskip}+1)) ${src} 2> /dev/null | head -c $((${metaskip}-${tailskip})) | gzip -dc > ${datafile};
        fi;
    else
        if [ ${istar} -eq 1 ]; then
            tail -c +$((${tailskip}+1)) ${src} 2> /dev/null | head -c $((${metaskip}-${tailskip})) | tar --no-same-owner -xf -;
        else
            tail -c +$((${tailskip}+1)) ${src} 2> /dev/null | head -c $((${metaskip}-${tailskip})) > ${datafile};
        fi;
    fi;
    true
}
validate_desktop_entries () 
{ 
    if [[ -x /usr/bin/desktop-file-validate ]]; then
        einfo "Checking desktop entry validity";
        local directories="";
        for d in /usr/share/applications $@;
        do
            [[ -d ${D}${d} ]] && directories="${directories} ${D}${d}";
        done;
        if [[ -n ${directories} ]]; then
            for FILE in $(find ${directories} -name "*\.desktop" 							-not -path '*.hidden*' | sort -u 2>/dev/null);
            do
                local temp=$(desktop-file-validate ${FILE} | grep -v "warning:" | 								sed -e "s|error: ||" -e "s|${FILE}:|--|g" );
                [[ -n $temp ]] && elog ${temp/--/${FILE/${D}/}:};
            done;
        fi;
        echo "";
    else
        einfo "Passing desktop entry validity check. Install dev-util/desktop-file-utils, if you want to help to improve Gentoo.";
    fi
}
version_compare () 
{ 
    __versionator_shopt_toggle on;
    local ver_a=${1} ver_b=${2} parts_a parts_b cur_idx_a=0 cur_idx_b=0;
    parts_a=($(get_all_version_components "${ver_a}" ));
    parts_b=($(get_all_version_components "${ver_b}" ));
    local inf_loop=0;
    while true; do
        inf_loop=$(( ${inf_loop} + 1 ));
        [[ ${inf_loop} -gt 20 ]] && die "versionator compare bug [numbers, ${ver_a}, ${ver_b}]";
        local cur_tok_a=${parts_a[${cur_idx_a}]};
        local cur_tok_b=${parts_b[${cur_idx_b}]};
        if [[ -n ${cur_tok_a} ]] && [[ -z ${cur_tok_a//[[:digit:]]} ]]; then
            cur_idx_a=$(( ${cur_idx_a} + 1 ));
            [[ ${parts_a[${cur_idx_a}]} == "." ]] && cur_idx_a=$(( ${cur_idx_a} + 1 ));
        else
            cur_tok_a="";
        fi;
        if [[ -n ${cur_tok_b} ]] && [[ -z ${cur_tok_b//[[:digit:]]} ]]; then
            cur_idx_b=$(( ${cur_idx_b} + 1 ));
            [[ ${parts_b[${cur_idx_b}]} == "." ]] && cur_idx_b=$(( ${cur_idx_b} + 1 ));
        else
            cur_tok_b="";
        fi;
        [[ -z ${cur_tok_a} ]] && [[ -z ${cur_tok_b} ]] && break;
        cur_tok_a=${cur_tok_a##+(0)};
        cur_tok_b=${cur_tok_b##+(0)};
        [[ -z ${cur_tok_a} ]] && cur_tok_a=0;
        [[ -z ${cur_tok_b} ]] && cur_tok_b=0;
        [[ ${cur_tok_a} -lt ${cur_tok_b} ]] && __versionator_shopt_toggle off && return 1;
        [[ ${cur_tok_a} -gt ${cur_tok_b} ]] && __versionator_shopt_toggle off && return 3;
    done;
    local letter_a=;
    letter_a=${parts_a[${cur_idx_a}]};
    if [[ ${#letter_a} -eq 1 ]] && [[ -z ${letter_a/[a-z]} ]]; then
        cur_idx_a=$(( ${cur_idx_a} + 1 ));
    else
        letter_a="@";
    fi;
    local letter_b=;
    letter_b=${parts_b[${cur_idx_b}]};
    if [[ ${#letter_b} -eq 1 ]] && [[ -z ${letter_b/[a-z]} ]]; then
        cur_idx_b=$(( ${cur_idx_b} + 1 ));
    else
        letter_b="@";
    fi;
    [[ ${letter_a} < ${letter_b} ]] && __versionator_shopt_toggle off && return 1;
    [[ ${letter_a} > ${letter_b} ]] && __versionator_shopt_toggle off && return 3;
    local suffix rule part r_lt r_gt;
    for rule in "alpha=1" "beta=1" "pre=1" "rc=1" "p=3" "r=3";
    do
        suffix=${rule%%=*};
        r_lt=${rule##*=};
        [[ ${r_lt} -eq 1 ]] && r_gt=3 || r_gt=1;
        local suffix_a=;
        for part in ${parts_a[@]};
        do
            [[ ${part#${suffix}} != ${part} ]] && [[ -z ${part##${suffix}*([[:digit:]])} ]] && suffix_a=${part#${suffix}}0;
        done;
        local suffix_b=;
        for part in ${parts_b[@]};
        do
            [[ ${part#${suffix}} != ${part} ]] && [[ -z ${part##${suffix}*([[:digit:]])} ]] && suffix_b=${part#${suffix}}0;
        done;
        [[ -z ${suffix_a} ]] && [[ -z ${suffix_b} ]] && continue;
        [[ -z ${suffix_a} ]] && __versionator_shopt_toggle off && return ${r_gt};
        [[ -z ${suffix_b} ]] && __versionator_shopt_toggle off && return ${r_lt};
        suffix_a=${suffix_a##+(0)};
        suffix_a=${suffix_a:-0};
        suffix_b=${suffix_b##+(0)};
        suffix_b=${suffix_b:-0};
        [[ ${suffix_a} -lt ${suffix_b} ]] && __versionator_shopt_toggle off && return 1;
        [[ ${suffix_a} -gt ${suffix_b} ]] && __versionator_shopt_toggle off && return 3;
    done;
    __versionator_shopt_toggle off;
    return 2
}
version_is_at_least () 
{ 
    __versionator_shopt_toggle on;
    local want_s="$1" have_s="${2:-${PVR}}" r;
    version_compare "${want_s}" "${have_s}";
    r=$?;
    case $r in 
        1 | 2)
            __versionator_shopt_toggle off;
            return 0
        ;;
        3)
            __versionator_shopt_toggle off;
            return 1
        ;;
        *)
            __versionator_shopt_toggle off;
            die "versionator compare bug [atleast, ${want_s}, ${have_s}, ${r}]"
        ;;
    esac;
    __versionator_shopt_toggle off
}
version_sort () 
{ 
    __versionator_shopt_toggle on;
    local items= left=0;
    items=($@);
    while [[ ${left} -lt ${#items[@]} ]]; do
        local lowest_idx=${left};
        local idx=$(( ${lowest_idx} + 1 ));
        while [[ ${idx} -lt ${#items[@]} ]]; do
            version_compare "${items[${lowest_idx}]}" "${items[${idx}]}";
            [[ $? -eq 3 ]] && lowest_idx=${idx};
            idx=$(( ${idx} + 1 ));
        done;
        local tmp=${items[${lowest_idx}]};
        items[${lowest_idx}]=${items[${left}]};
        items[${left}]=${tmp};
        left=$(( ${left} + 1 ));
    done;
    echo ${items[@]};
    __versionator_shopt_toggle off
}
declare -x ALLOWED_FLAGS="-pipe -O -O0 -O1 -O2 -mcpu -march -mtune -fstack-protector -fstack-protector-all -fbounds-checking -fno-strict-overflow -fno-PIE -fno-pie -fno-unit-at-a-time -g -g[0-9] -ggdb -ggdb[0-9] -gstabs -gstabs+ -fno-ident -W* -w -fno-stack-protector -fno-stack-protector-all 		-fno-strict-aliasing -fno-bounds-checking -fstrict-overflow -fno-omit-frame-pointer -mregparm -mno-app-regs -mapp-regs 		-mno-mmx -mno-sse -mno-sse2 -mno-sse3 -mno-ssse3 -mno-sse4 -mno-sse4.1 		-mno-sse4.2 -mno-avx -mno-aes -mno-pclmul -mno-sse4a -mno-3dnow 		-mno-popcnt -mno-abm 		-mips1 -mips2 -mips3 -mips4 -mips32 -mips64 -mips16 -mplt 		-msoft-float -mno-soft-float -mhard-float -mno-hard-float -mfpu 		-mieee -mieee-with-inexact -mschedule 		-mtls-direct-seg-refs -mno-tls-direct-seg-refs 		-mflat -mno-flat -mno-faster-structs -mfaster-structs 		-m32 -m64 -mabi -mlittle-endian -mbig-endian -EL -EB -fPIC 		-mlive-g0 -mcmodel -mstack-bias -mno-stack-bias 		-msecure-plt -m*-toc -D* -U*"
declare -x ALSA_CARDS=""
declare -x ALSA_PCM_PLUGINS="adpcm alaw asym copy dmix dshare dsnoop empty extplug file hooks iec958 ioplug ladspa lfloat linear meter mmap_emul mulaw multi null plug rate route share shm softvol"
declare -x APACHE2_MODULES="actions alias auth_basic authn_alias authn_anon authn_dbm authn_default authn_file authz_dbm authz_default authz_groupfile authz_host authz_owner authz_user autoindex cache dav dav_fs dav_lock deflate dir disk_cache env expires ext_filter file_cache filter headers include info log_config logio mem_cache mime mime_magic negotiation rewrite setenvif speling status unique_id userdir usertrack vhost_alias"
declare -x ARCH="alpha"
declare -x CBUILD="alpha-unknown-linux-gnu"
declare -x CCFLAGS="-O3 -host"
declare -x CCXXFLAGS="-O3 -host"
declare -x CDEFINE_default="__unix__"
declare -x CFLAGS=" -g3 -O2 -mcpu=ev67 -mieee -pipe"
declare -x CFLAGS_default=""
declare -x CHOST="alpha-unknown-linux-gnu"
declare -x CHOST_default="alpha-unknown-linux-gnu"
declare -x CROSSCOMPILE_OPTS=""
declare -x CTARGET="alpha-unknown-linux-gnu"
declare -x CTARGET_default="alpha-unknown-linux-gnu"
declare -x CVS_RSH="ssh"
declare -x CXXFLAGS=" -g3 -O2 -mcpu=ev67 -mieee -pipe"
declare -x DCCC_PATH="/usr/lib/distcc/bin"
declare -x DEFAULT_ABI="default"
declare -x DEFINED_PHASES=" compile install postinst postrm test unpack"
declare -x DESTTREE="/usr"
declare -x DIROPTIONS="-m0755"
declare -x EAPI="0"
declare -x ELIBC="glibc"
declare -x ELT_APPLIED_PATCHES=" 1.5.4 2.2 1.5.6 2.2.6"
declare -x ELT_LTMAIN_SH="/var/tmp/portage/sys-devel/binutils-2.19.1-r1/work/binutils-2.19.1/ltmain.sh"
declare -x EXEOPTIONS="-m0755"
declare -x FCFLAGS=""
declare -x FEATURES="ccache distlocks fixpackages parallel-fetch protect-owned sandbox sfperms splitdebug strict test unmerge-orphans userfetch"
declare -x FFLAGS=""
declare -x GCC_SPECS=""
declare -x GDK_USE_XFT="1"
declare -x INHERITED="toolchain-funcs portability flag-o-matic versionator multilib toolchain-binutils libtool gnuconfig eutils"
declare -x INPUT_DEVICES=""
declare -x INSDESTTREE=""
declare -x INSOPTIONS="-m0644"
declare -x KERNEL="linux"
declare -x KERNEL_ABI="default"
declare -x KEYWORDS="~alpha ~amd64 ~arm ~hppa ~ia64 ~mips ~ppc ~ppc64 s390 ~sh ~sparc ~x86 ~sparc-fbsd ~x86-fbsd"
declare -x KV="2.6.31-rc9"
declare -x LCD_DEVICES=""
declare -x LDFLAGS="-Wl,-O1"
declare -x LDFLAGS_default=""
declare -x LIBDIR_default="lib"
declare -x LIBOPTIONS="-m0644"
declare -x LICENSE="|| ( GPL-3 LGPL-3 )"
declare -x LINGUAS=""
declare -x MAKEOPTS="-j2"
declare -x MULTILIB_ABIS="default"
declare -x NETBEANS="apisupport cnd groovy gsf harness ide identity j2ee java mobility nb php profiler soa visualweb webcommon websvccommon xml"
declare -x OPENGL_PROFILE="xorg-x11"
declare -x PORTAGE_COMPRESS_EXCLUDE_SUFFIXES="css gif htm[l]? jp[e]?g js pdf png"
declare -x PROFILE_ONLY_VARIABLES="ARCH ELIBC KERNEL USERLAND"
declare -x PROPERTIES=""
declare -x PROVIDE=""
declare -x RDEPEND="  >=sys-devel/binutils-config-1.9"
declare -x RESTRICT=""
declare -x S="/var/tmp/portage/sys-devel/binutils-2.19.1-r1/work/binutils-2.19.1"
declare -x SANDBOX_DEBUG="0"
declare -x SANDBOX_DENY="/etc/ld.so.preload"
declare -x SANDBOX_PID="3437"
declare -x SANDBOX_PREDICT="/dev/console:/dev/crypto:/dev/random:/proc/self/maps:/var/tmp/portage/sys-devel/binutils-2.19.1-r1/homedir"
declare -x SANDBOX_READ="/:/dev/shm:/dev/stdin:/var/tmp:/var/tmp/ccache:/var/tmp/ccache"
declare -x SANDBOX_VERBOSE="1"
declare -x SANDBOX_WRITE=":/dev/console:/dev/fd:/dev/full:/dev/null:/dev/pts/:/dev/pty:/dev/shm:/dev/stderr:/dev/stdout:/dev/tts:/dev/tty:/dev/vc/:/dev/zero:/proc/self/fd:/tmp/:/usr/lib/cf:/usr/lib/conftest:/usr/lib32/cf:/usr/lib32/conftest:/usr/lib64/cf:/usr/lib64/conftest:/usr/tmp/cf:/usr/tmp/conftest:/var/tmp:/var/tmp/:/var/tmp/ccache:/var/tmp/portage/sys-devel/binutils-2.19.1-r1/homedir/.bash_history:/var/tmp/ccache"
declare -x SLOT="0"
declare -x SSH_CLIENT="10.113.10.85 43712 22"
declare -x SSH_CONNECTION="10.113.10.85 43712 10.113.10.251 22"
declare -x SSH_TTY="/dev/pts/0"
declare -x UNSTABLE_FLAGS="-Os -O3 -freorder-blocks"
declare -x USE="alpha elibc_glibc kernel_linux test userland_GNU"
declare -x USERLAND="GNU"
declare -x VIDEO_CARDS=""
declare -x _E_DOCDESTTREE_=""
declare -x _E_EXEDESTTREE_=""
